<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
          "DTD/xhtml1-strict.dtd">
<html>
  <head>
    <title>Lib.email.charset.Charset : API documentation</title>

    <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
    <link rel="stylesheet" type="text/css" href="bootstrap.min.css" />
    <link rel="stylesheet" type="text/css" href="apidocs.css" />
  </head>
  <body>

    <nav class="navbar navbar-default">
      <div class="container">
        <div class="navbar-header">
          <a class="navbar-brand" href="index.html">
            Python3.8 API Documentation
          </a>
        </div>
      </div>
    </nav>

    <div id="showPrivate">
      <button class="btn btn-link" onclick="togglePrivate()">Toggle Private API</button>
    </div>

    <div class="container">

      <div class="page-header">
        <h1 class="class"><code><a href="Lib.html" class="code" data-type="Package">Lib</a>.<a href="Lib.email.html" class="code" data-type="Package">email</a>.<a href="Lib.email.charset.html" class="code" data-type="Module">charset</a>.<a href="Lib.email.charset.Charset.html" class="code" data-type="Class">Charset</a></code></h1>
      </div>

      <div class="categoryHeader">
        class documentation
      </div>

      <div class="extrasDocstring">
        <p><code><span class="py-keyword">class</span> Lib.email.charset.Charset:</code></p>
        <p><a href="classIndex.html#Lib.email.charset.Charset">View In Hierarchy</a></p>
      </div>

      <div class="moduleDocstring">
        <div><p class="pre">Map character sets to their email properties.

This class provides information about the requirements imposed on email
for a specific character set.  It also provides convenience routines for
converting between character sets, given the availability of the
applicable codecs.  Given a character set, it will do its best to provide
information on how to use that character set in an email in an
RFC-compliant way.

Certain character sets must be encoded with quoted-printable or base64
when used in email headers or bodies.  Certain character sets must be
converted outright, and are not allowed in email.  Instances of this
module expose the following information about a character set:

input_charset: The initial character set specified.  Common aliases
               are converted to their `official' email names (e.g. latin_1
               is converted to iso-8859-1).  Defaults to 7-bit us-ascii.

header_encoding: If the character set must be encoded before it can be
                 used in an email header, this attribute will be set to
                 Charset.QP (for quoted-printable), Charset.BASE64 (for
                 base64 encoding), or Charset.SHORTEST for the shortest of
                 QP or BASE64 encoding.  Otherwise, it will be None.

body_encoding: Same as header_encoding, but describes the encoding for the
               mail message's body, which indeed may be different than the
               header encoding.  Charset.SHORTEST is not allowed for
               body_encoding.

output_charset: Some character sets must be converted before they can be
                used in email headers or bodies.  If the input_charset is
                one of them, this attribute will contain the name of the
                charset output will be converted to.  Otherwise, it will
                be None.

input_codec: The name of the Python codec used to convert the
             input_charset to Unicode.  If no conversion codec is
             necessary, this attribute will be None.

output_codec: The name of the Python codec used to convert Unicode
              to the output_charset.  If no conversion codec is necessary,
              this attribute will have the same value as the input_codec.</p></div>
      </div>

      <div id="splitTables">
        <table class="children sortable" id="id1259">
  
  <tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.email.charset.Charset.html#__init__" class="code" data-type="Method">__init__</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="instancevariable">
    
    <td>Instance Variable</td>
    <td><a href="Lib.email.charset.Charset.html#input_charset" class="code" data-type="Instance Variable">input_charset</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="instancevariable">
    
    <td>Instance Variable</td>
    <td><a href="Lib.email.charset.Charset.html#header_encoding" class="code" data-type="Instance Variable">header_encoding</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="instancevariable">
    
    <td>Instance Variable</td>
    <td><a href="Lib.email.charset.Charset.html#body_encoding" class="code" data-type="Instance Variable">body_encoding</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="instancevariable">
    
    <td>Instance Variable</td>
    <td><a href="Lib.email.charset.Charset.html#output_charset" class="code" data-type="Instance Variable">output_charset</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="instancevariable">
    
    <td>Instance Variable</td>
    <td><a href="Lib.email.charset.Charset.html#input_codec" class="code" data-type="Instance Variable">input_codec</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="instancevariable">
    
    <td>Instance Variable</td>
    <td><a href="Lib.email.charset.Charset.html#output_codec" class="code" data-type="Instance Variable">output_codec</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.email.charset.Charset.html#__repr__" class="code" data-type="Method">__repr__</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.email.charset.Charset.html#__eq__" class="code" data-type="Method">__eq__</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.email.charset.Charset.html#get_body_encoding" class="code" data-type="Method">get_body_encoding</a></td>
    <td><span>Return the content-transfer-encoding used for body encoding.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.email.charset.Charset.html#get_output_charset" class="code" data-type="Method">get_output_charset</a></td>
    <td><span>Return the output character set.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.email.charset.Charset.html#header_encode" class="code" data-type="Method">header_encode</a></td>
    <td><span>Header-encode a string by converting it first to bytes.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.email.charset.Charset.html#header_encode_lines" class="code" data-type="Method">header_encode_lines</a></td>
    <td><span>Header-encode a string by converting it first to bytes.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.email.charset.Charset.html#body_encode" class="code" data-type="Method">body_encode</a></td>
    <td><span>Body-encode a string by converting it first to bytes.</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><a href="Lib.email.charset.Charset.html#_get_encoder" class="code" data-type="Method">_get_encoder</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr>
</table>
        

          
      </div>

      <div id="childList">

        <div class="basemethod">
  
  <a name="Lib.email.charset.Charset.__init__">
    
  </a>
  <a name="__init__">
    
  </a>
  <div class="functionHeader">
    
    def
    __init__(self, input_charset=DEFAULT_CHARSET):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="baseinstancevariable">
  
  <a name="Lib.email.charset.Charset.input_charset">
    
  </a>
  <a name="input_charset">
    
  </a>
  <div class="functionHeader">
    input_charset =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="baseinstancevariable">
  
  <a name="Lib.email.charset.Charset.header_encoding">
    
  </a>
  <a name="header_encoding">
    
  </a>
  <div class="functionHeader">
    header_encoding =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="baseinstancevariable">
  
  <a name="Lib.email.charset.Charset.body_encoding">
    
  </a>
  <a name="body_encoding">
    
  </a>
  <div class="functionHeader">
    body_encoding =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="baseinstancevariable">
  
  <a name="Lib.email.charset.Charset.output_charset">
    
  </a>
  <a name="output_charset">
    
  </a>
  <div class="functionHeader">
    output_charset =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="baseinstancevariable">
  
  <a name="Lib.email.charset.Charset.input_codec">
    
  </a>
  <a name="input_codec">
    
  </a>
  <div class="functionHeader">
    input_codec =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="baseinstancevariable">
  
  <a name="Lib.email.charset.Charset.output_codec">
    
  </a>
  <a name="output_codec">
    
  </a>
  <div class="functionHeader">
    output_codec =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.email.charset.Charset.__repr__">
    
  </a>
  <a name="__repr__">
    
  </a>
  <div class="functionHeader">
    
    def
    __repr__(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.email.charset.Charset.__eq__">
    
  </a>
  <a name="__eq__">
    
  </a>
  <div class="functionHeader">
    
    def
    __eq__(self, other):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.email.charset.Charset.get_body_encoding">
    
  </a>
  <a name="get_body_encoding">
    
  </a>
  <div class="functionHeader">
    
    def
    get_body_encoding(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Return the content-transfer-encoding used for body encoding.

This is either the string `quoted-printable' or `base64' depending on
the encoding used, or it is a function in which case you should call
the function with a single argument, the Message object being
encoded.  The function should then set the Content-Transfer-Encoding
header itself to whatever is appropriate.

Returns "quoted-printable" if self.body_encoding is QP.
Returns "base64" if self.body_encoding is BASE64.
Returns conversion function otherwise.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.email.charset.Charset.get_output_charset">
    
  </a>
  <a name="get_output_charset">
    
  </a>
  <div class="functionHeader">
    
    def
    get_output_charset(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Return the output character set.

This is self.output_charset if that is not None, otherwise it is
self.input_charset.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.email.charset.Charset.header_encode">
    
  </a>
  <a name="header_encode">
    
  </a>
  <div class="functionHeader">
    
    def
    header_encode(self, string):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Header-encode a string by converting it first to bytes.

The type of encoding (base64 or quoted-printable) will be based on
this charset's `header_encoding`.

:param string: A unicode string for the header.  It must be possible
    to encode this string to bytes using the character set's
    output codec.
:return: The encoded string, with RFC 2047 chrome.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.email.charset.Charset.header_encode_lines">
    
  </a>
  <a name="header_encode_lines">
    
  </a>
  <div class="functionHeader">
    
    def
    header_encode_lines(self, string, maxlengths):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Header-encode a string by converting it first to bytes.

This is similar to `header_encode()` except that the string is fit
into maximum line lengths as given by the argument.

:param string: A unicode string for the header.  It must be possible
    to encode this string to bytes using the character set's
    output codec.
:param maxlengths: Maximum line length iterator.  Each element
    returned from this iterator will provide the next maximum line
    length.  This parameter is used as an argument to built-in next()
    and should never be exhausted.  The maximum line lengths should
    not count the RFC 2047 chrome.  These line lengths are only a
    hint; the splitter does the best it can.
:return: Lines of encoded strings, each with RFC 2047 chrome.</p></div>
  </div>
</div><div class="basemethod private">
  
  <a name="Lib.email.charset.Charset._get_encoder">
    
  </a>
  <a name="_get_encoder">
    
  </a>
  <div class="functionHeader">
    
    def
    _get_encoder(self, header_bytes):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.email.charset.Charset.body_encode">
    
  </a>
  <a name="body_encode">
    
  </a>
  <div class="functionHeader">
    
    def
    body_encode(self, string):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Body-encode a string by converting it first to bytes.

The type of encoding (base64 or quoted-printable) will be based on
self.body_encoding.  If body_encoding is None, we assume the
output charset is a 7bit encoding, so re-encoding the decoded
string using the ascii codec produces the correct string version
of the content.</p></div>
  </div>
</div>

      </div>
      <address>
        <a href="index.html">API Documentation</a> for Python3.8, generated by <a href="https://github.com/twisted/pydoctor/">pydoctor</a> 20.7.1 at 2020-11-24 05:11:37.
      </address>

    </div>

    <script src="pydoctor.js" type="text/javascript"></script>

  </body>
</html>