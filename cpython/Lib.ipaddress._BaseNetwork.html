<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
          "DTD/xhtml1-strict.dtd">
<html>
  <head>
    <title>Lib.ipaddress._BaseNetwork : API documentation</title>

    <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
    <link rel="stylesheet" type="text/css" href="bootstrap.min.css" />
    <link rel="stylesheet" type="text/css" href="apidocs.css" />
  </head>
  <body>

    <nav class="navbar navbar-default">
      <div class="container">
        <div class="navbar-header">
          <a class="navbar-brand" href="index.html">
            Python3.8 API Documentation
          </a>
        </div>
      </div>
    </nav>

    <div id="showPrivate">
      <button class="btn btn-link" onclick="togglePrivate()">Toggle Private API</button>
    </div>

    <div class="container">

      <div class="page-header">
        <h1 class="class private"><code><a href="Lib.html" class="code" data-type="Package">Lib</a>.<a href="Lib.ipaddress.html" class="code" data-type="Module">ipaddress</a>.<a href="Lib.ipaddress._BaseNetwork.html" class="code" data-type="Class">_BaseNetwork</a></code></h1>
      </div>

      <div class="categoryHeader">
        class documentation
      </div>

      <div class="extrasDocstring">
        <p><code><span class="py-keyword">class</span> Lib.ipaddress._BaseNetwork(<a href="Lib.ipaddress._IPAddressBase.html" class="code" data-type="Class">_IPAddressBase</a>):</code></p><p>Known subclasses: <a href="Lib.ipaddress.IPv4Network.html" class="code" data-type="Class">Lib.ipaddress.IPv4Network</a>, <a href="Lib.ipaddress.IPv6Network.html" class="code" data-type="Class">Lib.ipaddress.IPv6Network</a></p>
        <p><a href="classIndex.html#Lib.ipaddress._BaseNetwork">View In Hierarchy</a></p>
      </div>

      <div class="moduleDocstring">
        <div><p class="pre">A generic IP network object.

This IP class contains the version independent methods which are
used by networks.</p></div>
      </div>

      <div id="splitTables">
        <table class="children sortable" id="id2618">
  
  <tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.ipaddress._BaseNetwork.html#__repr__" class="code" data-type="Method">__repr__</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.ipaddress._BaseNetwork.html#__str__" class="code" data-type="Method">__str__</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.ipaddress._BaseNetwork.html#hosts" class="code" data-type="Method">hosts</a></td>
    <td><span>Generate Iterator over usable hosts in a network.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.ipaddress._BaseNetwork.html#__iter__" class="code" data-type="Method">__iter__</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.ipaddress._BaseNetwork.html#__getitem__" class="code" data-type="Method">__getitem__</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.ipaddress._BaseNetwork.html#__lt__" class="code" data-type="Method">__lt__</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.ipaddress._BaseNetwork.html#__eq__" class="code" data-type="Method">__eq__</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.ipaddress._BaseNetwork.html#__hash__" class="code" data-type="Method">__hash__</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.ipaddress._BaseNetwork.html#__contains__" class="code" data-type="Method">__contains__</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.ipaddress._BaseNetwork.html#overlaps" class="code" data-type="Method">overlaps</a></td>
    <td><span>Tell if self is partly contained in other.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.ipaddress._BaseNetwork.html#broadcast_address" class="code" data-type="Method">broadcast_address</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.ipaddress._BaseNetwork.html#hostmask" class="code" data-type="Method">hostmask</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.ipaddress._BaseNetwork.html#with_prefixlen" class="code" data-type="Method">with_prefixlen</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.ipaddress._BaseNetwork.html#with_netmask" class="code" data-type="Method">with_netmask</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.ipaddress._BaseNetwork.html#with_hostmask" class="code" data-type="Method">with_hostmask</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.ipaddress._BaseNetwork.html#num_addresses" class="code" data-type="Method">num_addresses</a></td>
    <td><span>Number of hosts in the current subnet.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.ipaddress._BaseNetwork.html#prefixlen" class="code" data-type="Method">prefixlen</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.ipaddress._BaseNetwork.html#address_exclude" class="code" data-type="Method">address_exclude</a></td>
    <td><span>Remove an address from a larger block.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.ipaddress._BaseNetwork.html#compare_networks" class="code" data-type="Method">compare_networks</a></td>
    <td><span>Compare two IP objects.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.ipaddress._BaseNetwork.html#subnets" class="code" data-type="Method">subnets</a></td>
    <td><span>The subnets which join to make the current subnet.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.ipaddress._BaseNetwork.html#supernet" class="code" data-type="Method">supernet</a></td>
    <td><span>The supernet containing the current network.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.ipaddress._BaseNetwork.html#is_multicast" class="code" data-type="Method">is_multicast</a></td>
    <td><span>Test if the address is reserved for multicast use.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.ipaddress._BaseNetwork.html#subnet_of" class="code" data-type="Method">subnet_of</a></td>
    <td><span>Return True if this network is a subnet of other.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.ipaddress._BaseNetwork.html#supernet_of" class="code" data-type="Method">supernet_of</a></td>
    <td><span>Return True if this network is a supernet of other.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.ipaddress._BaseNetwork.html#is_reserved" class="code" data-type="Method">is_reserved</a></td>
    <td><span>Test if the address is otherwise IETF reserved.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.ipaddress._BaseNetwork.html#is_link_local" class="code" data-type="Method">is_link_local</a></td>
    <td><span>Test if the address is reserved for link-local.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.ipaddress._BaseNetwork.html#is_private" class="code" data-type="Method">is_private</a></td>
    <td><span>Test if this address is allocated for private networks.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.ipaddress._BaseNetwork.html#is_global" class="code" data-type="Method">is_global</a></td>
    <td><span>Test if this address is allocated for public networks.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.ipaddress._BaseNetwork.html#is_unspecified" class="code" data-type="Method">is_unspecified</a></td>
    <td><span>Test if the address is unspecified.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.ipaddress._BaseNetwork.html#is_loopback" class="code" data-type="Method">is_loopback</a></td>
    <td><span>Test if the address is a loopback address.</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><a href="Lib.ipaddress._BaseNetwork.html#_address_class" class="code" data-type="Method">_address_class</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><a href="Lib.ipaddress._BaseNetwork.html#_get_networks_key" class="code" data-type="Method">_get_networks_key</a></td>
    <td><span>Network-only key function.</span></td>
  </tr><tr class="staticmethod private">
    
    <td>Static Method</td>
    <td><a href="Lib.ipaddress._BaseNetwork.html#_is_subnet_of" class="code" data-type="Static Method">_is_subnet_of</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr>
</table>
        
          <p class="inheritedFrom">
            Inherited from <a href="Lib.ipaddress._IPAddressBase.html" class="code" data-type="Class">_IPAddressBase</a>:
          </p>
          <table class="children sortable" id="id2619">
  
  <tr class="baseclassvariable">
    
    <td>Class Variable</td>
    <td><a href="Lib.ipaddress._IPAddressBase.html#__slots__" class="code" data-type="Class Variable">__slots__</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><a href="Lib.ipaddress._IPAddressBase.html#exploded" class="code" data-type="Method">exploded</a></td>
    <td><span>Return the longhand version of the IP address as a string.</span></td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><a href="Lib.ipaddress._IPAddressBase.html#compressed" class="code" data-type="Method">compressed</a></td>
    <td><span>Return the shorthand version of the IP address as a string.</span></td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><a href="Lib.ipaddress._IPAddressBase.html#reverse_pointer" class="code" data-type="Method">reverse_pointer</a></td>
    <td><span class="undocumented">No summary</span></td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><a href="Lib.ipaddress._IPAddressBase.html#version" class="code" data-type="Method">version</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><a href="Lib.ipaddress._IPAddressBase.html#__reduce__" class="code" data-type="Method">__reduce__</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="basemethod private">
    
    <td>Method</td>
    <td><a href="Lib.ipaddress._IPAddressBase.html#_check_int_address" class="code" data-type="Method">_check_int_address</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="basemethod private">
    
    <td>Method</td>
    <td><a href="Lib.ipaddress._IPAddressBase.html#_check_packed_address" class="code" data-type="Method">_check_packed_address</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="baseclassmethod private">
    
    <td>Class Method</td>
    <td><a href="Lib.ipaddress._IPAddressBase.html#_ip_int_from_prefix" class="code" data-type="Class Method">_ip_int_from_prefix</a></td>
    <td><span>Turn the prefix length into a bitwise netmask</span></td>
  </tr><tr class="baseclassmethod private">
    
    <td>Class Method</td>
    <td><a href="Lib.ipaddress._IPAddressBase.html#_prefix_from_ip_int" class="code" data-type="Class Method">_prefix_from_ip_int</a></td>
    <td><span>Return prefix length from the bitwise netmask.</span></td>
  </tr><tr class="baseclassmethod private">
    
    <td>Class Method</td>
    <td><a href="Lib.ipaddress._IPAddressBase.html#_report_invalid_netmask" class="code" data-type="Class Method">_report_invalid_netmask</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="baseclassmethod private">
    
    <td>Class Method</td>
    <td><a href="Lib.ipaddress._IPAddressBase.html#_prefix_from_prefix_string" class="code" data-type="Class Method">_prefix_from_prefix_string</a></td>
    <td><span>Return prefix length from a numeric string</span></td>
  </tr><tr class="baseclassmethod private">
    
    <td>Class Method</td>
    <td><a href="Lib.ipaddress._IPAddressBase.html#_prefix_from_ip_string" class="code" data-type="Class Method">_prefix_from_ip_string</a></td>
    <td><span>Turn a netmask/hostmask string into a prefix length</span></td>
  </tr><tr class="baseclassmethod private">
    
    <td>Class Method</td>
    <td><a href="Lib.ipaddress._IPAddressBase.html#_split_addr_prefix" class="code" data-type="Class Method">_split_addr_prefix</a></td>
    <td><span>Helper function to parse address of Network/Interface.</span></td>
  </tr>
</table>
          

          
      </div>

      <div id="childList">

        <div class="basemethod">
  
  <a name="Lib.ipaddress._BaseNetwork.__repr__">
    
  </a>
  <a name="__repr__">
    
  </a>
  <div class="functionHeader">
    
    def
    __repr__(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.ipaddress._BaseNetwork.__str__">
    
  </a>
  <a name="__str__">
    
  </a>
  <div class="functionHeader">
    
    def
    __str__(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.ipaddress._BaseNetwork.hosts">
    
  </a>
  <a name="hosts">
    
  </a>
  <div class="functionHeader">
    
    def
    hosts(self):
    
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overridden in <a href="Lib.ipaddress.IPv4Network.html" class="code" data-type="Class">Lib.ipaddress.IPv4Network</a>, <a href="Lib.ipaddress.IPv6Network.html" class="code" data-type="Class">Lib.ipaddress.IPv6Network</a></div>
    
    <div><p class="pre">Generate Iterator over usable hosts in a network.

This is like __iter__ except it doesn't return the network
or broadcast addresses.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.ipaddress._BaseNetwork.__iter__">
    
  </a>
  <a name="__iter__">
    
  </a>
  <div class="functionHeader">
    
    def
    __iter__(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.ipaddress._BaseNetwork.__getitem__">
    
  </a>
  <a name="__getitem__">
    
  </a>
  <div class="functionHeader">
    
    def
    __getitem__(self, n):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.ipaddress._BaseNetwork.__lt__">
    
  </a>
  <a name="__lt__">
    
  </a>
  <div class="functionHeader">
    
    def
    __lt__(self, other):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.ipaddress._BaseNetwork.__eq__">
    
  </a>
  <a name="__eq__">
    
  </a>
  <div class="functionHeader">
    
    def
    __eq__(self, other):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.ipaddress._BaseNetwork.__hash__">
    
  </a>
  <a name="__hash__">
    
  </a>
  <div class="functionHeader">
    
    def
    __hash__(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.ipaddress._BaseNetwork.__contains__">
    
  </a>
  <a name="__contains__">
    
  </a>
  <div class="functionHeader">
    
    def
    __contains__(self, other):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.ipaddress._BaseNetwork.overlaps">
    
  </a>
  <a name="overlaps">
    
  </a>
  <div class="functionHeader">
    
    def
    overlaps(self, other):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Tell if self is partly contained in other.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.ipaddress._BaseNetwork.broadcast_address">
    
  </a>
  <a name="broadcast_address">
    
  </a>
  <div class="functionHeader">
    @functools.cached_property<br />
    def
    broadcast_address(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.ipaddress._BaseNetwork.hostmask">
    
  </a>
  <a name="hostmask">
    
  </a>
  <div class="functionHeader">
    @functools.cached_property<br />
    def
    hostmask(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.ipaddress._BaseNetwork.with_prefixlen">
    
  </a>
  <a name="with_prefixlen">
    
  </a>
  <div class="functionHeader">
    @property<br />
    def
    with_prefixlen(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.ipaddress._BaseNetwork.with_netmask">
    
  </a>
  <a name="with_netmask">
    
  </a>
  <div class="functionHeader">
    @property<br />
    def
    with_netmask(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.ipaddress._BaseNetwork.with_hostmask">
    
  </a>
  <a name="with_hostmask">
    
  </a>
  <div class="functionHeader">
    @property<br />
    def
    with_hostmask(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.ipaddress._BaseNetwork.num_addresses">
    
  </a>
  <a name="num_addresses">
    
  </a>
  <div class="functionHeader">
    @property<br />
    def
    num_addresses(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Number of hosts in the current subnet.</p></div>
  </div>
</div><div class="basemethod private">
  
  <a name="Lib.ipaddress._BaseNetwork._address_class">
    
  </a>
  <a name="_address_class">
    
  </a>
  <div class="functionHeader">
    @property<br />
    def
    _address_class(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.ipaddress._BaseNetwork.prefixlen">
    
  </a>
  <a name="prefixlen">
    
  </a>
  <div class="functionHeader">
    @property<br />
    def
    prefixlen(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.ipaddress._BaseNetwork.address_exclude">
    
  </a>
  <a name="address_exclude">
    
  </a>
  <div class="functionHeader">
    
    def
    address_exclude(self, other):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Remove an address from a larger block.

For example:

    addr1 = ip_network('192.0.2.0/28')
    addr2 = ip_network('192.0.2.1/32')
    list(addr1.address_exclude(addr2)) =
        [IPv4Network('192.0.2.0/32'), IPv4Network('192.0.2.2/31'),
         IPv4Network('192.0.2.4/30'), IPv4Network('192.0.2.8/29')]

or IPv6:

    addr1 = ip_network('2001:db8::1/32')
    addr2 = ip_network('2001:db8::1/128')
    list(addr1.address_exclude(addr2)) =
        [ip_network('2001:db8::1/128'),
         ip_network('2001:db8::2/127'),
         ip_network('2001:db8::4/126'),
         ip_network('2001:db8::8/125'),
         ...
         ip_network('2001:db8:8000::/33')]

Args:
    other: An IPv4Network or IPv6Network object of the same type.

Returns:
    An iterator of the IPv(4|6)Network objects which is self
    minus other.

Raises:
    TypeError: If self and other are of differing address
      versions, or if other is not a network object.
    ValueError: If other is not completely contained by self.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.ipaddress._BaseNetwork.compare_networks">
    
  </a>
  <a name="compare_networks">
    
  </a>
  <div class="functionHeader">
    
    def
    compare_networks(self, other):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Compare two IP objects.

This is only concerned about the comparison of the integer
representation of the network addresses.  This means that the
host bits aren't considered at all in this method.  If you want
to compare host bits, you can easily enough do a
'HostA._ip &lt; HostB._ip'

Args:
    other: An IP object.

Returns:
    If the IP versions of self and other are the same, returns:

    -1 if self &lt; other:
      eg: IPv4Network('192.0.2.0/25') &lt; IPv4Network('192.0.2.128/25')
      IPv6Network('2001:db8::1000/124') &lt;
          IPv6Network('2001:db8::2000/124')
    0 if self == other
      eg: IPv4Network('192.0.2.0/24') == IPv4Network('192.0.2.0/24')
      IPv6Network('2001:db8::1000/124') ==
          IPv6Network('2001:db8::1000/124')
    1 if self &gt; other
      eg: IPv4Network('192.0.2.128/25') &gt; IPv4Network('192.0.2.0/25')
          IPv6Network('2001:db8::2000/124') &gt;
              IPv6Network('2001:db8::1000/124')

  Raises:
      TypeError if the IP versions are different.</p></div>
  </div>
</div><div class="basemethod private">
  
  <a name="Lib.ipaddress._BaseNetwork._get_networks_key">
    
  </a>
  <a name="_get_networks_key">
    
  </a>
  <div class="functionHeader">
    
    def
    _get_networks_key(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Network-only key function.

Returns an object that identifies this address' network and
netmask. This function is a suitable "key" argument for sorted()
and list.sort().</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.ipaddress._BaseNetwork.subnets">
    
  </a>
  <a name="subnets">
    
  </a>
  <div class="functionHeader">
    
    def
    subnets(self, prefixlen_diff=1, new_prefix=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">The subnets which join to make the current subnet.

In the case that self contains only one IP
(self._prefixlen == 32 for IPv4 or self._prefixlen == 128
for IPv6), yield an iterator with just ourself.

Args:
    prefixlen_diff: An integer, the amount the prefix length
      should be increased by. This should not be set if
      new_prefix is also set.
    new_prefix: The desired new prefix length. This must be a
      larger number (smaller prefix) than the existing prefix.
      This should not be set if prefixlen_diff is also set.

Returns:
    An iterator of IPv(4|6) objects.

Raises:
    ValueError: The prefixlen_diff is too small or too large.
        OR
    prefixlen_diff and new_prefix are both set or new_prefix
      is a smaller number than the current prefix (smaller
      number means a larger network)</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.ipaddress._BaseNetwork.supernet">
    
  </a>
  <a name="supernet">
    
  </a>
  <div class="functionHeader">
    
    def
    supernet(self, prefixlen_diff=1, new_prefix=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">The supernet containing the current network.

Args:
    prefixlen_diff: An integer, the amount the prefix length of
      the network should be decreased by.  For example, given a
      /24 network and a prefixlen_diff of 3, a supernet with a
      /21 netmask is returned.

Returns:
    An IPv4 network object.

Raises:
    ValueError: If self.prefixlen - prefixlen_diff &lt; 0. I.e., you have
      a negative prefix length.
        OR
    If prefixlen_diff and new_prefix are both set or new_prefix is a
      larger number than the current prefix (larger number means a
      smaller network)</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.ipaddress._BaseNetwork.is_multicast">
    
  </a>
  <a name="is_multicast">
    
  </a>
  <div class="functionHeader">
    @property<br />
    def
    is_multicast(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Test if the address is reserved for multicast use.

Returns:
    A boolean, True if the address is a multicast address.
    See RFC 2373 2.7 for details.</p></div>
  </div>
</div><div class="basestaticmethod private">
  
  <a name="Lib.ipaddress._BaseNetwork._is_subnet_of">
    
  </a>
  <a name="_is_subnet_of">
    
  </a>
  <div class="functionHeader">
    @staticmethod<br />
    def
    _is_subnet_of(a, b):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.ipaddress._BaseNetwork.subnet_of">
    
  </a>
  <a name="subnet_of">
    
  </a>
  <div class="functionHeader">
    
    def
    subnet_of(self, other):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Return True if this network is a subnet of other.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.ipaddress._BaseNetwork.supernet_of">
    
  </a>
  <a name="supernet_of">
    
  </a>
  <div class="functionHeader">
    
    def
    supernet_of(self, other):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Return True if this network is a supernet of other.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.ipaddress._BaseNetwork.is_reserved">
    
  </a>
  <a name="is_reserved">
    
  </a>
  <div class="functionHeader">
    @property<br />
    def
    is_reserved(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Test if the address is otherwise IETF reserved.

Returns:
    A boolean, True if the address is within one of the
    reserved IPv6 Network ranges.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.ipaddress._BaseNetwork.is_link_local">
    
  </a>
  <a name="is_link_local">
    
  </a>
  <div class="functionHeader">
    @property<br />
    def
    is_link_local(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Test if the address is reserved for link-local.

Returns:
    A boolean, True if the address is reserved per RFC 4291.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.ipaddress._BaseNetwork.is_private">
    
  </a>
  <a name="is_private">
    
  </a>
  <div class="functionHeader">
    @property<br />
    def
    is_private(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Test if this address is allocated for private networks.

Returns:
    A boolean, True if the address is reserved per
    iana-ipv4-special-registry or iana-ipv6-special-registry.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.ipaddress._BaseNetwork.is_global">
    
  </a>
  <a name="is_global">
    
  </a>
  <div class="functionHeader">
    @property<br />
    def
    is_global(self):
    
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overridden in <a href="Lib.ipaddress.IPv4Network.html" class="code" data-type="Class">Lib.ipaddress.IPv4Network</a></div>
    
    <div><p class="pre">Test if this address is allocated for public networks.

Returns:
    A boolean, True if the address is not reserved per
    iana-ipv4-special-registry or iana-ipv6-special-registry.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.ipaddress._BaseNetwork.is_unspecified">
    
  </a>
  <a name="is_unspecified">
    
  </a>
  <div class="functionHeader">
    @property<br />
    def
    is_unspecified(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Test if the address is unspecified.

Returns:
    A boolean, True if this is the unspecified address as defined in
    RFC 2373 2.5.2.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.ipaddress._BaseNetwork.is_loopback">
    
  </a>
  <a name="is_loopback">
    
  </a>
  <div class="functionHeader">
    @property<br />
    def
    is_loopback(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Test if the address is a loopback address.

Returns:
    A boolean, True if the address is a loopback address as defined in
    RFC 2373 2.5.3.</p></div>
  </div>
</div>

      </div>
      <address>
        <a href="index.html">API Documentation</a> for Python3.8, generated by <a href="https://github.com/twisted/pydoctor/">pydoctor</a> 20.7.1 at 2020-11-24 05:11:37.
      </address>

    </div>

    <script src="pydoctor.js" type="text/javascript"></script>

  </body>
</html>