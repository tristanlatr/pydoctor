<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
          "DTD/xhtml1-strict.dtd">
<html>
  <head>
    <title>Lib.asyncio.protocols.BufferedProtocol : API documentation</title>

    <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
    <link rel="stylesheet" type="text/css" href="bootstrap.min.css" />
    <link rel="stylesheet" type="text/css" href="apidocs.css" />
  </head>
  <body>

    <nav class="navbar navbar-default">
      <div class="container">
        <div class="navbar-header">
          <a class="navbar-brand" href="index.html">
            Python3.8 API Documentation
          </a>
        </div>
      </div>
    </nav>

    <div id="showPrivate">
      <button class="btn btn-link" onclick="togglePrivate()">Toggle Private API</button>
    </div>

    <div class="container">

      <div class="page-header">
        <h1 class="class"><code><a href="Lib.html" class="code" data-type="Package">Lib</a>.<a href="Lib.asyncio.html" class="code" data-type="Package">asyncio</a>.<a href="Lib.asyncio.protocols.html" class="code" data-type="Module">protocols</a>.<a href="Lib.asyncio.protocols.BufferedProtocol.html" class="code" data-type="Class">BufferedProtocol</a></code></h1>
      </div>

      <div class="categoryHeader">
        class documentation
      </div>

      <div class="extrasDocstring">
        <p><code><span class="py-keyword">class</span> Lib.asyncio.protocols.BufferedProtocol(<a href="Lib.asyncio.protocols.BaseProtocol.html" class="code" data-type="Class">BaseProtocol</a>):</code></p>
        <p><a href="classIndex.html#Lib.asyncio.protocols.BufferedProtocol">View In Hierarchy</a></p>
      </div>

      <div class="moduleDocstring">
        <div><p class="pre">Interface for stream protocol with manual buffer control.

Important: this has been added to asyncio in Python 3.7
*on a provisional basis*!  Consider it as an experimental API that
might be changed or removed in Python 3.8.

Event methods, such as `create_server` and `create_connection`,
accept factories that return protocols that implement this interface.

The idea of BufferedProtocol is that it allows to manually allocate
and control the receive buffer.  Event loops can then use the buffer
provided by the protocol to avoid unnecessary data copies.  This
can result in noticeable performance improvement for protocols that
receive big amounts of data.  Sophisticated protocols can allocate
the buffer only once at creation time.

State machine of calls:

  start -&gt; CM [-&gt; GB [-&gt; BU?]]* [-&gt; ER?] -&gt; CL -&gt; end

* CM: connection_made()
* GB: get_buffer()
* BU: buffer_updated()
* ER: eof_received()
* CL: connection_lost()</p></div>
      </div>

      <div id="splitTables">
        <table class="children sortable" id="id357">
  
  <tr class="classvariable">
    
    <td>Class Variable</td>
    <td><a href="Lib.asyncio.protocols.BufferedProtocol.html#__slots__" class="code" data-type="Class Variable">__slots__</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.asyncio.protocols.BufferedProtocol.html#get_buffer" class="code" data-type="Method">get_buffer</a></td>
    <td><span>Called to allocate a new receive buffer.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.asyncio.protocols.BufferedProtocol.html#buffer_updated" class="code" data-type="Method">buffer_updated</a></td>
    <td><span>Called when the buffer was updated with the received data.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.asyncio.protocols.BufferedProtocol.html#eof_received" class="code" data-type="Method">eof_received</a></td>
    <td><span>Called when the other end calls write_eof() or equivalent.</span></td>
  </tr>
</table>
        
          <p class="inheritedFrom">
            Inherited from <a href="Lib.asyncio.protocols.BaseProtocol.html" class="code" data-type="Class">BaseProtocol</a>:
          </p>
          <table class="children sortable" id="id358">
  
  <tr class="basemethod">
    
    <td>Method</td>
    <td><a href="Lib.asyncio.protocols.BaseProtocol.html#connection_made" class="code" data-type="Method">connection_made</a></td>
    <td><span>Called when a connection is made.</span></td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><a href="Lib.asyncio.protocols.BaseProtocol.html#connection_lost" class="code" data-type="Method">connection_lost</a></td>
    <td><span>Called when the connection is lost or closed.</span></td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><a href="Lib.asyncio.protocols.BaseProtocol.html#pause_writing" class="code" data-type="Method">pause_writing</a></td>
    <td><span>Called when the transport's buffer goes over the high-water mark.</span></td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><a href="Lib.asyncio.protocols.BaseProtocol.html#resume_writing" class="code" data-type="Method">resume_writing</a></td>
    <td><span>Called when the transport's buffer drains below the low-water mark.</span></td>
  </tr>
</table>
          

          
      </div>

      <div id="childList">

        <div class="baseclassvariable">
  
  <a name="Lib.asyncio.protocols.BufferedProtocol.__slots__">
    
  </a>
  <a name="__slots__">
    
  </a>
  <div class="functionHeader">
    __slots__ =
    
  </div>
  <div class="functionBody">
    <div class="interfaceinfo">overrides <a href="Lib.asyncio.protocols.BaseProtocol.html#__slots__" class="code" data-type="Class Variable">Lib.asyncio.protocols.BaseProtocol.__slots__</a></div>
    <div class="undocumented">Undocumented</div> (type: <code>Tuple</code>)
  </div>
</div><div class="basemethod">
  
  <a name="Lib.asyncio.protocols.BufferedProtocol.get_buffer">
    
  </a>
  <a name="get_buffer">
    
  </a>
  <div class="functionHeader">
    
    def
    get_buffer(self, sizehint):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Called to allocate a new receive buffer.

*sizehint* is a recommended minimal size for the returned
buffer.  When set to -1, the buffer size can be arbitrary.

Must return an object that implements the
:ref:`buffer protocol &lt;bufferobjects&gt;`.
It is an error to return a zero-sized buffer.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.asyncio.protocols.BufferedProtocol.buffer_updated">
    
  </a>
  <a name="buffer_updated">
    
  </a>
  <div class="functionHeader">
    
    def
    buffer_updated(self, nbytes):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Called when the buffer was updated with the received data.

*nbytes* is the total number of bytes that were written to
the buffer.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.asyncio.protocols.BufferedProtocol.eof_received">
    
  </a>
  <a name="eof_received">
    
  </a>
  <div class="functionHeader">
    
    def
    eof_received(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Called when the other end calls write_eof() or equivalent.

If this returns a false value (including None), the transport
will close itself.  If it returns a true value, closing the
transport is up to the protocol.</p></div>
  </div>
</div>

      </div>
      <address>
        <a href="index.html">API Documentation</a> for Python3.8, generated by <a href="https://github.com/twisted/pydoctor/">pydoctor</a> 20.7.1 at 2020-11-24 05:40:36.
      </address>

    </div>

    <script src="pydoctor.js" type="text/javascript"></script>

  </body>
</html>