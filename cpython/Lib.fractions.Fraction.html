<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
          "DTD/xhtml1-strict.dtd">
<html>
  <head>
    <title>Lib.fractions.Fraction : API documentation</title>

    <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
    <link rel="stylesheet" type="text/css" href="bootstrap.min.css" />
    <link rel="stylesheet" type="text/css" href="apidocs.css" />
  </head>
  <body>

    <nav class="navbar navbar-default">
      <div class="container">
        <div class="navbar-header">
          <a class="navbar-brand" href="index.html">
            Python3.8 API Documentation
          </a>
        </div>
      </div>
    </nav>

    <div id="showPrivate">
      <button class="btn btn-link" onclick="togglePrivate()">Toggle Private API</button>
    </div>

    <div class="container">

      <div class="page-header">
        <h1 class="class"><code><a href="Lib.html" class="code" data-type="Package">Lib</a>.<a href="Lib.fractions.html" class="code" data-type="Module">fractions</a>.<a href="Lib.fractions.Fraction.html" class="code" data-type="Class">Fraction</a></code></h1>
      </div>

      <div class="categoryHeader">
        class documentation
      </div>

      <div class="extrasDocstring">
        <p><code><span class="py-keyword">class</span> Lib.fractions.Fraction(<span title="numbers.Rational">numbers.Rational</span>):</code></p>
        <p><a href="classIndex.html#Lib.fractions.Fraction">View In Hierarchy</a></p>
      </div>

      <div class="moduleDocstring">
        <div><p class="pre">This class implements rational numbers.

In the two-argument form of the constructor, Fraction(8, 6) will
produce a rational number equivalent to 4/3. Both arguments must
be Rational. The numerator defaults to 0 and the denominator
defaults to 1 so that Fraction(3) == 3 and Fraction() == 0.

Fractions can also be constructed from:

  - numeric strings similar to those accepted by the
    float constructor (for example, '-2.3' or '1e10')

  - strings of the form '123/456'

  - float and Decimal instances

  - other Rational instances (including integers)</p></div>
      </div>

      <div id="splitTables">
        <table class="children sortable" id="id1953">
  
  <tr class="classvariable">
    
    <td>Class Variable</td>
    <td><a href="Lib.fractions.Fraction.html#__slots__" class="code" data-type="Class Variable">__slots__</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.fractions.Fraction.html#__new__" class="code" data-type="Method">__new__</a></td>
    <td><span>Constructs a Rational.</span></td>
  </tr><tr class="classmethod">
    
    <td>Class Method</td>
    <td><a href="Lib.fractions.Fraction.html#from_float" class="code" data-type="Class Method">from_float</a></td>
    <td><span>Converts a finite float to a rational number, exactly.</span></td>
  </tr><tr class="classmethod">
    
    <td>Class Method</td>
    <td><a href="Lib.fractions.Fraction.html#from_decimal" class="code" data-type="Class Method">from_decimal</a></td>
    <td><span>Converts a finite Decimal instance to a rational number, exactly.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.fractions.Fraction.html#as_integer_ratio" class="code" data-type="Method">as_integer_ratio</a></td>
    <td><span>Return the integer ratio as a tuple.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.fractions.Fraction.html#limit_denominator" class="code" data-type="Method">limit_denominator</a></td>
    <td><span>Closest Fraction to self with denominator at most max_denominator.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.fractions.Fraction.html#numerator" class="code" data-type="Method">numerator</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.fractions.Fraction.html#denominator" class="code" data-type="Method">denominator</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.fractions.Fraction.html#__repr__" class="code" data-type="Method">__repr__</a></td>
    <td><span>repr(self)</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.fractions.Fraction.html#__str__" class="code" data-type="Method">__str__</a></td>
    <td><span>str(self)</span></td>
  </tr><tr class="classvariable">
    
    <td>Class Variable</td>
    <td><a href="Lib.fractions.Fraction.html#__add__" class="code" data-type="Class Variable">__add__</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="classvariable">
    
    <td>Class Variable</td>
    <td><a href="Lib.fractions.Fraction.html#__radd__" class="code" data-type="Class Variable">__radd__</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="classvariable">
    
    <td>Class Variable</td>
    <td><a href="Lib.fractions.Fraction.html#__sub__" class="code" data-type="Class Variable">__sub__</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="classvariable">
    
    <td>Class Variable</td>
    <td><a href="Lib.fractions.Fraction.html#__rsub__" class="code" data-type="Class Variable">__rsub__</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="classvariable">
    
    <td>Class Variable</td>
    <td><a href="Lib.fractions.Fraction.html#__mul__" class="code" data-type="Class Variable">__mul__</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="classvariable">
    
    <td>Class Variable</td>
    <td><a href="Lib.fractions.Fraction.html#__rmul__" class="code" data-type="Class Variable">__rmul__</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="classvariable">
    
    <td>Class Variable</td>
    <td><a href="Lib.fractions.Fraction.html#__truediv__" class="code" data-type="Class Variable">__truediv__</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="classvariable">
    
    <td>Class Variable</td>
    <td><a href="Lib.fractions.Fraction.html#__rtruediv__" class="code" data-type="Class Variable">__rtruediv__</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="classvariable">
    
    <td>Class Variable</td>
    <td><a href="Lib.fractions.Fraction.html#__floordiv__" class="code" data-type="Class Variable">__floordiv__</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="classvariable">
    
    <td>Class Variable</td>
    <td><a href="Lib.fractions.Fraction.html#__rfloordiv__" class="code" data-type="Class Variable">__rfloordiv__</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="classvariable">
    
    <td>Class Variable</td>
    <td><a href="Lib.fractions.Fraction.html#__divmod__" class="code" data-type="Class Variable">__divmod__</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="classvariable">
    
    <td>Class Variable</td>
    <td><a href="Lib.fractions.Fraction.html#__rdivmod__" class="code" data-type="Class Variable">__rdivmod__</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="classvariable">
    
    <td>Class Variable</td>
    <td><a href="Lib.fractions.Fraction.html#__mod__" class="code" data-type="Class Variable">__mod__</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="classvariable">
    
    <td>Class Variable</td>
    <td><a href="Lib.fractions.Fraction.html#__rmod__" class="code" data-type="Class Variable">__rmod__</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.fractions.Fraction.html#__pow__" class="code" data-type="Method">__pow__</a></td>
    <td><span>a ** b</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.fractions.Fraction.html#__rpow__" class="code" data-type="Method">__rpow__</a></td>
    <td><span>a ** b</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.fractions.Fraction.html#__pos__" class="code" data-type="Method">__pos__</a></td>
    <td><span>+a: Coerces a subclass instance to Fraction</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.fractions.Fraction.html#__neg__" class="code" data-type="Method">__neg__</a></td>
    <td><span>-a</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.fractions.Fraction.html#__abs__" class="code" data-type="Method">__abs__</a></td>
    <td><span>abs(a)</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.fractions.Fraction.html#__trunc__" class="code" data-type="Method">__trunc__</a></td>
    <td><span>trunc(a)</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.fractions.Fraction.html#__floor__" class="code" data-type="Method">__floor__</a></td>
    <td><span>math.floor(a)</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.fractions.Fraction.html#__ceil__" class="code" data-type="Method">__ceil__</a></td>
    <td><span>math.ceil(a)</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.fractions.Fraction.html#__round__" class="code" data-type="Method">__round__</a></td>
    <td><span>round(self, ndigits)</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.fractions.Fraction.html#__hash__" class="code" data-type="Method">__hash__</a></td>
    <td><span>hash(self)</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.fractions.Fraction.html#__eq__" class="code" data-type="Method">__eq__</a></td>
    <td><span>a == b</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.fractions.Fraction.html#__lt__" class="code" data-type="Method">__lt__</a></td>
    <td><span>a &lt; b</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.fractions.Fraction.html#__gt__" class="code" data-type="Method">__gt__</a></td>
    <td><span>a &gt; b</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.fractions.Fraction.html#__le__" class="code" data-type="Method">__le__</a></td>
    <td><span>a &lt;= b</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.fractions.Fraction.html#__ge__" class="code" data-type="Method">__ge__</a></td>
    <td><span>a &gt;= b</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.fractions.Fraction.html#__bool__" class="code" data-type="Method">__bool__</a></td>
    <td><span>a != 0</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.fractions.Fraction.html#__reduce__" class="code" data-type="Method">__reduce__</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.fractions.Fraction.html#__copy__" class="code" data-type="Method">__copy__</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.fractions.Fraction.html#__deepcopy__" class="code" data-type="Method">__deepcopy__</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="instancevariable private">
    
    <td>Instance Variable</td>
    <td><a href="Lib.fractions.Fraction.html#_numerator" class="code" data-type="Instance Variable">_numerator</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="instancevariable private">
    
    <td>Instance Variable</td>
    <td><a href="Lib.fractions.Fraction.html#_denominator" class="code" data-type="Instance Variable">_denominator</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><a href="Lib.fractions.Fraction.html#_operator_fallbacks" class="code" data-type="Method">_operator_fallbacks</a></td>
    <td><span>Generates forward and reverse operators given a purely-rational operator and a function from the operator module.</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><a href="Lib.fractions.Fraction.html#_add" class="code" data-type="Method">_add</a></td>
    <td><span>a + b</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><a href="Lib.fractions.Fraction.html#_sub" class="code" data-type="Method">_sub</a></td>
    <td><span>a - b</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><a href="Lib.fractions.Fraction.html#_mul" class="code" data-type="Method">_mul</a></td>
    <td><span>a * b</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><a href="Lib.fractions.Fraction.html#_div" class="code" data-type="Method">_div</a></td>
    <td><span>a / b</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><a href="Lib.fractions.Fraction.html#_floordiv" class="code" data-type="Method">_floordiv</a></td>
    <td><span>a // b</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><a href="Lib.fractions.Fraction.html#_divmod" class="code" data-type="Method">_divmod</a></td>
    <td><span>(a // b, a % b)</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><a href="Lib.fractions.Fraction.html#_mod" class="code" data-type="Method">_mod</a></td>
    <td><span>a % b</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><a href="Lib.fractions.Fraction.html#_richcmp" class="code" data-type="Method">_richcmp</a></td>
    <td><span>Helper for comparison operators, for internal use only.</span></td>
  </tr>
</table>
        

          
      </div>

      <div id="childList">

        <div class="baseclassvariable">
  
  <a name="Lib.fractions.Fraction.__slots__">
    
  </a>
  <a name="__slots__">
    
  </a>
  <div class="functionHeader">
    __slots__ =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div> (type: <code>Tuple[str, ...]</code>)
  </div>
</div><div class="basemethod">
  
  <a name="Lib.fractions.Fraction.__new__">
    
  </a>
  <a name="__new__">
    
  </a>
  <div class="functionHeader">
    
    def
    __new__(cls, numerator=0, denominator=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Constructs a Rational.

Takes a string like '3/2' or '1.5', another Rational instance, a
numerator/denominator pair, or a float.

Examples
--------

&gt;&gt;&gt; Fraction(10, -8)
Fraction(-5, 4)
&gt;&gt;&gt; Fraction(Fraction(1, 7), 5)
Fraction(1, 35)
&gt;&gt;&gt; Fraction(Fraction(1, 7), Fraction(2, 3))
Fraction(3, 14)
&gt;&gt;&gt; Fraction('314')
Fraction(314, 1)
&gt;&gt;&gt; Fraction('-35/4')
Fraction(-35, 4)
&gt;&gt;&gt; Fraction('3.1415') # conversion from numeric string
Fraction(6283, 2000)
&gt;&gt;&gt; Fraction('-47e-2') # string may include a decimal exponent
Fraction(-47, 100)
&gt;&gt;&gt; Fraction(1.47)  # direct construction from float (exact conversion)
Fraction(6620291452234629, 4503599627370496)
&gt;&gt;&gt; Fraction(2.25)
Fraction(9, 4)
&gt;&gt;&gt; Fraction(Decimal('1.47'))
Fraction(147, 100)</p></div>
  </div>
</div><div class="baseinstancevariable private">
  
  <a name="Lib.fractions.Fraction._numerator">
    
  </a>
  <a name="_numerator">
    
  </a>
  <div class="functionHeader">
    _numerator =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="baseinstancevariable private">
  
  <a name="Lib.fractions.Fraction._denominator">
    
  </a>
  <a name="_denominator">
    
  </a>
  <div class="functionHeader">
    _denominator =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="baseclassmethod">
  
  <a name="Lib.fractions.Fraction.from_float">
    
  </a>
  <a name="from_float">
    
  </a>
  <div class="functionHeader">
    @classmethod<br />
    def
    from_float(cls, f):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Converts a finite float to a rational number, exactly.

Beware that Fraction.from_float(0.3) != Fraction(3, 10).</p></div>
  </div>
</div><div class="baseclassmethod">
  
  <a name="Lib.fractions.Fraction.from_decimal">
    
  </a>
  <a name="from_decimal">
    
  </a>
  <div class="functionHeader">
    @classmethod<br />
    def
    from_decimal(cls, dec):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Converts a finite Decimal instance to a rational number, exactly.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.fractions.Fraction.as_integer_ratio">
    
  </a>
  <a name="as_integer_ratio">
    
  </a>
  <div class="functionHeader">
    
    def
    as_integer_ratio(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Return the integer ratio as a tuple.

Return a tuple of two integers, whose ratio is equal to the
Fraction and with a positive denominator.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.fractions.Fraction.limit_denominator">
    
  </a>
  <a name="limit_denominator">
    
  </a>
  <div class="functionHeader">
    
    def
    limit_denominator(self, max_denominator=1000000):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Closest Fraction to self with denominator at most max_denominator.

&gt;&gt;&gt; Fraction('3.141592653589793').limit_denominator(10)
Fraction(22, 7)
&gt;&gt;&gt; Fraction('3.141592653589793').limit_denominator(100)
Fraction(311, 99)
&gt;&gt;&gt; Fraction(4321, 8765).limit_denominator(10000)
Fraction(4321, 8765)</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.fractions.Fraction.numerator">
    
  </a>
  <a name="numerator">
    
  </a>
  <div class="functionHeader">
    @property<br />
    def
    numerator(a):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.fractions.Fraction.denominator">
    
  </a>
  <a name="denominator">
    
  </a>
  <div class="functionHeader">
    @property<br />
    def
    denominator(a):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.fractions.Fraction.__repr__">
    
  </a>
  <a name="__repr__">
    
  </a>
  <div class="functionHeader">
    
    def
    __repr__(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">repr(self)</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.fractions.Fraction.__str__">
    
  </a>
  <a name="__str__">
    
  </a>
  <div class="functionHeader">
    
    def
    __str__(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">str(self)</p></div>
  </div>
</div><div class="basemethod private">
  
  <a name="Lib.fractions.Fraction._operator_fallbacks">
    
  </a>
  <a name="_operator_fallbacks">
    
  </a>
  <div class="functionHeader">
    
    def
    _operator_fallbacks(monomorphic_operator, fallback_operator):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Generates forward and reverse operators given a purely-rational
operator and a function from the operator module.

Use this like:
__op__, __rop__ = _operator_fallbacks(just_rational_op, operator.op)

In general, we want to implement the arithmetic operations so
that mixed-mode operations either call an implementation whose
author knew about the types of both arguments, or convert both
to the nearest built in type and do the operation there. In
Fraction, that means that we define __add__ and __radd__ as:

    def __add__(self, other):
        # Both types have numerators/denominator attributes,
        # so do the operation directly
        if isinstance(other, (int, Fraction)):
            return Fraction(self.numerator * other.denominator +
                            other.numerator * self.denominator,
                            self.denominator * other.denominator)
        # float and complex don't have those operations, but we
        # know about those types, so special case them.
        elif isinstance(other, float):
            return float(self) + other
        elif isinstance(other, complex):
            return complex(self) + other
        # Let the other type take over.
        return NotImplemented

    def __radd__(self, other):
        # radd handles more types than add because there's
        # nothing left to fall back to.
        if isinstance(other, numbers.Rational):
            return Fraction(self.numerator * other.denominator +
                            other.numerator * self.denominator,
                            self.denominator * other.denominator)
        elif isinstance(other, Real):
            return float(other) + float(self)
        elif isinstance(other, Complex):
            return complex(other) + complex(self)
        return NotImplemented


There are 5 different cases for a mixed-type addition on
Fraction. I'll refer to all of the above code that doesn't
refer to Fraction, float, or complex as "boilerplate". 'r'
will be an instance of Fraction, which is a subtype of
Rational (r : Fraction &lt;: Rational), and b : B &lt;:
Complex. The first three involve 'r + b':

    1. If B &lt;: Fraction, int, float, or complex, we handle
       that specially, and all is well.
    2. If Fraction falls back to the boilerplate code, and it
       were to return a value from __add__, we'd miss the
       possibility that B defines a more intelligent __radd__,
       so the boilerplate should return NotImplemented from
       __add__. In particular, we don't handle Rational
       here, even though we could get an exact answer, in case
       the other type wants to do something special.
    3. If B &lt;: Fraction, Python tries B.__radd__ before
       Fraction.__add__. This is ok, because it was
       implemented with knowledge of Fraction, so it can
       handle those instances before delegating to Real or
       Complex.

The next two situations describe 'b + r'. We assume that b
didn't know about Fraction in its implementation, and that it
uses similar boilerplate code:

    4. If B &lt;: Rational, then __radd_ converts both to the
       builtin rational type (hey look, that's us) and
       proceeds.
    5. Otherwise, __radd__ tries to find the nearest common
       base ABC, and fall back to its builtin type. Since this
       class doesn't subclass a concrete type, there's no
       implementation to fall back to, so we need to try as
       hard as possible to return an actual value, or the user
       will get a TypeError.</p></div>
  </div>
</div><div class="basemethod private">
  
  <a name="Lib.fractions.Fraction._add">
    
  </a>
  <a name="_add">
    
  </a>
  <div class="functionHeader">
    
    def
    _add(a, b):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">a + b</p></div>
  </div>
</div><div class="baseclassvariable">
  
  <a name="Lib.fractions.Fraction.__add__">
    
  </a>
  <a name="__add__">
    
  </a>
  <div class="functionHeader">
    __add__ =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="baseclassvariable">
  
  <a name="Lib.fractions.Fraction.__radd__">
    
  </a>
  <a name="__radd__">
    
  </a>
  <div class="functionHeader">
    __radd__ =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basemethod private">
  
  <a name="Lib.fractions.Fraction._sub">
    
  </a>
  <a name="_sub">
    
  </a>
  <div class="functionHeader">
    
    def
    _sub(a, b):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">a - b</p></div>
  </div>
</div><div class="baseclassvariable">
  
  <a name="Lib.fractions.Fraction.__sub__">
    
  </a>
  <a name="__sub__">
    
  </a>
  <div class="functionHeader">
    __sub__ =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="baseclassvariable">
  
  <a name="Lib.fractions.Fraction.__rsub__">
    
  </a>
  <a name="__rsub__">
    
  </a>
  <div class="functionHeader">
    __rsub__ =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basemethod private">
  
  <a name="Lib.fractions.Fraction._mul">
    
  </a>
  <a name="_mul">
    
  </a>
  <div class="functionHeader">
    
    def
    _mul(a, b):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">a * b</p></div>
  </div>
</div><div class="baseclassvariable">
  
  <a name="Lib.fractions.Fraction.__mul__">
    
  </a>
  <a name="__mul__">
    
  </a>
  <div class="functionHeader">
    __mul__ =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="baseclassvariable">
  
  <a name="Lib.fractions.Fraction.__rmul__">
    
  </a>
  <a name="__rmul__">
    
  </a>
  <div class="functionHeader">
    __rmul__ =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basemethod private">
  
  <a name="Lib.fractions.Fraction._div">
    
  </a>
  <a name="_div">
    
  </a>
  <div class="functionHeader">
    
    def
    _div(a, b):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">a / b</p></div>
  </div>
</div><div class="baseclassvariable">
  
  <a name="Lib.fractions.Fraction.__truediv__">
    
  </a>
  <a name="__truediv__">
    
  </a>
  <div class="functionHeader">
    __truediv__ =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="baseclassvariable">
  
  <a name="Lib.fractions.Fraction.__rtruediv__">
    
  </a>
  <a name="__rtruediv__">
    
  </a>
  <div class="functionHeader">
    __rtruediv__ =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basemethod private">
  
  <a name="Lib.fractions.Fraction._floordiv">
    
  </a>
  <a name="_floordiv">
    
  </a>
  <div class="functionHeader">
    
    def
    _floordiv(a, b):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">a // b</p></div>
  </div>
</div><div class="baseclassvariable">
  
  <a name="Lib.fractions.Fraction.__floordiv__">
    
  </a>
  <a name="__floordiv__">
    
  </a>
  <div class="functionHeader">
    __floordiv__ =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="baseclassvariable">
  
  <a name="Lib.fractions.Fraction.__rfloordiv__">
    
  </a>
  <a name="__rfloordiv__">
    
  </a>
  <div class="functionHeader">
    __rfloordiv__ =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basemethod private">
  
  <a name="Lib.fractions.Fraction._divmod">
    
  </a>
  <a name="_divmod">
    
  </a>
  <div class="functionHeader">
    
    def
    _divmod(a, b):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">(a // b, a % b)</p></div>
  </div>
</div><div class="baseclassvariable">
  
  <a name="Lib.fractions.Fraction.__divmod__">
    
  </a>
  <a name="__divmod__">
    
  </a>
  <div class="functionHeader">
    __divmod__ =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="baseclassvariable">
  
  <a name="Lib.fractions.Fraction.__rdivmod__">
    
  </a>
  <a name="__rdivmod__">
    
  </a>
  <div class="functionHeader">
    __rdivmod__ =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basemethod private">
  
  <a name="Lib.fractions.Fraction._mod">
    
  </a>
  <a name="_mod">
    
  </a>
  <div class="functionHeader">
    
    def
    _mod(a, b):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">a % b</p></div>
  </div>
</div><div class="baseclassvariable">
  
  <a name="Lib.fractions.Fraction.__mod__">
    
  </a>
  <a name="__mod__">
    
  </a>
  <div class="functionHeader">
    __mod__ =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="baseclassvariable">
  
  <a name="Lib.fractions.Fraction.__rmod__">
    
  </a>
  <a name="__rmod__">
    
  </a>
  <div class="functionHeader">
    __rmod__ =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.fractions.Fraction.__pow__">
    
  </a>
  <a name="__pow__">
    
  </a>
  <div class="functionHeader">
    
    def
    __pow__(a, b):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">a ** b

If b is not an integer, the result will be a float or complex
since roots are generally irrational. If b is an integer, the
result will be rational.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.fractions.Fraction.__rpow__">
    
  </a>
  <a name="__rpow__">
    
  </a>
  <div class="functionHeader">
    
    def
    __rpow__(b, a):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">a ** b</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.fractions.Fraction.__pos__">
    
  </a>
  <a name="__pos__">
    
  </a>
  <div class="functionHeader">
    
    def
    __pos__(a):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">+a: Coerces a subclass instance to Fraction</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.fractions.Fraction.__neg__">
    
  </a>
  <a name="__neg__">
    
  </a>
  <div class="functionHeader">
    
    def
    __neg__(a):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">-a</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.fractions.Fraction.__abs__">
    
  </a>
  <a name="__abs__">
    
  </a>
  <div class="functionHeader">
    
    def
    __abs__(a):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">abs(a)</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.fractions.Fraction.__trunc__">
    
  </a>
  <a name="__trunc__">
    
  </a>
  <div class="functionHeader">
    
    def
    __trunc__(a):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">trunc(a)</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.fractions.Fraction.__floor__">
    
  </a>
  <a name="__floor__">
    
  </a>
  <div class="functionHeader">
    
    def
    __floor__(a):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">math.floor(a)</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.fractions.Fraction.__ceil__">
    
  </a>
  <a name="__ceil__">
    
  </a>
  <div class="functionHeader">
    
    def
    __ceil__(a):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">math.ceil(a)</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.fractions.Fraction.__round__">
    
  </a>
  <a name="__round__">
    
  </a>
  <div class="functionHeader">
    
    def
    __round__(self, ndigits=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">round(self, ndigits)

Rounds half toward even.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.fractions.Fraction.__hash__">
    
  </a>
  <a name="__hash__">
    
  </a>
  <div class="functionHeader">
    
    def
    __hash__(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">hash(self)</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.fractions.Fraction.__eq__">
    
  </a>
  <a name="__eq__">
    
  </a>
  <div class="functionHeader">
    
    def
    __eq__(a, b):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">a == b</p></div>
  </div>
</div><div class="basemethod private">
  
  <a name="Lib.fractions.Fraction._richcmp">
    
  </a>
  <a name="_richcmp">
    
  </a>
  <div class="functionHeader">
    
    def
    _richcmp(self, other, op):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Helper for comparison operators, for internal use only.

Implement comparison between a Rational instance `self`, and
either another Rational instance or a float `other`.  If
`other` is not a Rational instance or a float, return
NotImplemented. `op` should be one of the six standard
comparison operators.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.fractions.Fraction.__lt__">
    
  </a>
  <a name="__lt__">
    
  </a>
  <div class="functionHeader">
    
    def
    __lt__(a, b):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">a &lt; b</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.fractions.Fraction.__gt__">
    
  </a>
  <a name="__gt__">
    
  </a>
  <div class="functionHeader">
    
    def
    __gt__(a, b):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">a &gt; b</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.fractions.Fraction.__le__">
    
  </a>
  <a name="__le__">
    
  </a>
  <div class="functionHeader">
    
    def
    __le__(a, b):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">a &lt;= b</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.fractions.Fraction.__ge__">
    
  </a>
  <a name="__ge__">
    
  </a>
  <div class="functionHeader">
    
    def
    __ge__(a, b):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">a &gt;= b</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.fractions.Fraction.__bool__">
    
  </a>
  <a name="__bool__">
    
  </a>
  <div class="functionHeader">
    
    def
    __bool__(a):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">a != 0</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.fractions.Fraction.__reduce__">
    
  </a>
  <a name="__reduce__">
    
  </a>
  <div class="functionHeader">
    
    def
    __reduce__(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.fractions.Fraction.__copy__">
    
  </a>
  <a name="__copy__">
    
  </a>
  <div class="functionHeader">
    
    def
    __copy__(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.fractions.Fraction.__deepcopy__">
    
  </a>
  <a name="__deepcopy__">
    
  </a>
  <div class="functionHeader">
    
    def
    __deepcopy__(self, memo):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div class="undocumented">Undocumented</div>
  </div>
</div>

      </div>
      <address>
        <a href="index.html">API Documentation</a> for Python3.8, generated by <a href="https://github.com/twisted/pydoctor/">pydoctor</a> 20.7.1 at 2020-11-24 05:40:36.
      </address>

    </div>

    <script src="pydoctor.js" type="text/javascript"></script>

  </body>
</html>