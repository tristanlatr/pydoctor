<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
          "DTD/xhtml1-strict.dtd">
<html>
  <head>
    <title>Lib.collections.Counter : API documentation</title>

    <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
    <link rel="stylesheet" type="text/css" href="bootstrap.min.css" />
    <link rel="stylesheet" type="text/css" href="apidocs.css" />
  </head>
  <body>

    <nav class="navbar navbar-default">
      <div class="container">
        <div class="navbar-header">
          <a class="navbar-brand" href="index.html">
            Python3.8 API Documentation
          </a>
        </div>
      </div>
    </nav>

    <div id="showPrivate">
      <button class="btn btn-link" onclick="togglePrivate()">Toggle Private API</button>
    </div>

    <div class="container">

      <div class="page-header">
        <h1 class="class"><code><a href="Lib.html" class="code" data-type="Package">Lib</a>.<a href="Lib.collections.html" class="code" data-type="Package">collections</a>.<a href="Lib.collections.Counter.html" class="code" data-type="Class">Counter</a></code></h1>
      </div>

      <div class="categoryHeader">
        class documentation
      </div>

      <div class="extrasDocstring">
        <p><code><span class="py-keyword">class</span> Lib.collections.Counter(<span title="dict">dict</span>):</code></p>
        <p><a href="classIndex.html#Lib.collections.Counter">View In Hierarchy</a></p>
      </div>

      <div class="moduleDocstring">
        <div><p class="pre">Dict subclass for counting hashable items.  Sometimes called a bag
or multiset.  Elements are stored as dictionary keys and their counts
are stored as dictionary values.

&gt;&gt;&gt; c = Counter('abcdeabcdabcaba')  # count elements from a string

&gt;&gt;&gt; c.most_common(3)                # three most common elements
[('a', 5), ('b', 4), ('c', 3)]
&gt;&gt;&gt; sorted(c)                       # list all unique elements
['a', 'b', 'c', 'd', 'e']
&gt;&gt;&gt; ''.join(sorted(c.elements()))   # list elements with repetitions
'aaaaabbbbcccdde'
&gt;&gt;&gt; sum(c.values())                 # total of all counts
15

&gt;&gt;&gt; c['a']                          # count of letter 'a'
5
&gt;&gt;&gt; for elem in 'shazam':           # update counts from an iterable
...     c[elem] += 1                # by adding 1 to each element's count
&gt;&gt;&gt; c['a']                          # now there are seven 'a'
7
&gt;&gt;&gt; del c['b']                      # remove all 'b'
&gt;&gt;&gt; c['b']                          # now there are zero 'b'
0

&gt;&gt;&gt; d = Counter('simsalabim')       # make another counter
&gt;&gt;&gt; c.update(d)                     # add in the second counter
&gt;&gt;&gt; c['a']                          # now there are nine 'a'
9

&gt;&gt;&gt; c.clear()                       # empty the counter
&gt;&gt;&gt; c
Counter()

Note:  If a count is set to zero or reduced to zero, it will remain
in the counter until the entry is deleted or the counter is cleared:

&gt;&gt;&gt; c = Counter('aaabbc')
&gt;&gt;&gt; c['b'] -= 2                     # reduce the count of 'b' by two
&gt;&gt;&gt; c.most_common()                 # 'b' is still in, but its count is zero
[('a', 3), ('c', 1), ('b', 0)]</p></div>
      </div>

      <div id="splitTables">
        <table class="children sortable" id="id529">
  
  <tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.collections.Counter.html#__init__" class="code" data-type="Method">__init__</a></td>
    <td><span>Create a new, empty Counter object.  And if given, count elements from an input iterable.  Or, initialize the count from another mapping of elements to their counts.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.collections.Counter.html#__missing__" class="code" data-type="Method">__missing__</a></td>
    <td><span>The count of elements not in the Counter is zero.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.collections.Counter.html#most_common" class="code" data-type="Method">most_common</a></td>
    <td><span>List the n most common elements and their counts from the most common to the least.  If n is None, then list all element counts.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.collections.Counter.html#elements" class="code" data-type="Method">elements</a></td>
    <td><span>Iterator over elements repeating each as many times as its count.</span></td>
  </tr><tr class="classmethod">
    
    <td>Class Method</td>
    <td><a href="Lib.collections.Counter.html#fromkeys" class="code" data-type="Class Method">fromkeys</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.collections.Counter.html#update" class="code" data-type="Method">update</a></td>
    <td><span>Like dict.update() but add counts instead of replacing them.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.collections.Counter.html#subtract" class="code" data-type="Method">subtract</a></td>
    <td><span>Like dict.update() but subtracts counts instead of replacing them. Counts can be reduced below zero.  Both the inputs and outputs are allowed to contain zero and negative counts.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.collections.Counter.html#copy" class="code" data-type="Method">copy</a></td>
    <td><span>Return a shallow copy.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.collections.Counter.html#__reduce__" class="code" data-type="Method">__reduce__</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.collections.Counter.html#__delitem__" class="code" data-type="Method">__delitem__</a></td>
    <td><span>Like dict.__delitem__() but does not raise KeyError for missing values.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.collections.Counter.html#__eq__" class="code" data-type="Method">__eq__</a></td>
    <td><span>True if all counts agree. Missing counts are treated as zero.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.collections.Counter.html#__ne__" class="code" data-type="Method">__ne__</a></td>
    <td><span>True if any counts disagree. Missing counts are treated as zero.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.collections.Counter.html#__le__" class="code" data-type="Method">__le__</a></td>
    <td><span>True if all counts in self are a subset of those in other.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.collections.Counter.html#__lt__" class="code" data-type="Method">__lt__</a></td>
    <td><span>True if all counts in self are a proper subset of those in other.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.collections.Counter.html#__ge__" class="code" data-type="Method">__ge__</a></td>
    <td><span>True if all counts in self are a superset of those in other.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.collections.Counter.html#__gt__" class="code" data-type="Method">__gt__</a></td>
    <td><span>True if all counts in self are a proper superset of those in other.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.collections.Counter.html#__repr__" class="code" data-type="Method">__repr__</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.collections.Counter.html#__add__" class="code" data-type="Method">__add__</a></td>
    <td><span>Add counts from two counters.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.collections.Counter.html#__sub__" class="code" data-type="Method">__sub__</a></td>
    <td><span>Subtract count, but keep only results with positive counts.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.collections.Counter.html#__or__" class="code" data-type="Method">__or__</a></td>
    <td><span>Union is the maximum of value in either of the input counters.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.collections.Counter.html#__and__" class="code" data-type="Method">__and__</a></td>
    <td><span>Intersection is the minimum of corresponding counts.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.collections.Counter.html#__pos__" class="code" data-type="Method">__pos__</a></td>
    <td><span>Adds an empty counter, effectively stripping negative and zero counts</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.collections.Counter.html#__neg__" class="code" data-type="Method">__neg__</a></td>
    <td><span>Subtracts from an empty counter.  Strips positive and zero counts, and flips the sign on negative counts.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.collections.Counter.html#__iadd__" class="code" data-type="Method">__iadd__</a></td>
    <td><span>Inplace add from another counter, keeping only positive counts.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.collections.Counter.html#__isub__" class="code" data-type="Method">__isub__</a></td>
    <td><span>Inplace subtract counter, but keep only results with positive counts.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.collections.Counter.html#__ior__" class="code" data-type="Method">__ior__</a></td>
    <td><span>Inplace union is the maximum of value from either counter.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.collections.Counter.html#__iand__" class="code" data-type="Method">__iand__</a></td>
    <td><span>Inplace intersection is the minimum of corresponding counts.</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><a href="Lib.collections.Counter.html#_keep_positive" class="code" data-type="Method">_keep_positive</a></td>
    <td><span>Internal method to strip elements with a negative or zero count</span></td>
  </tr>
</table>
        

          
      </div>

      <div id="childList">

        <div class="basemethod">
  
  <a name="Lib.collections.Counter.__init__">
    
  </a>
  <a name="__init__">
    
  </a>
  <div class="functionHeader">
    
    def
    __init__(**kwds):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Create a new, empty Counter object.  And if given, count elements
from an input iterable.  Or, initialize the count from another mapping
of elements to their counts.

&gt;&gt;&gt; c = Counter()                           # a new, empty counter
&gt;&gt;&gt; c = Counter('gallahad')                 # a new counter from an iterable
&gt;&gt;&gt; c = Counter({'a': 4, 'b': 2})           # a new counter from a mapping
&gt;&gt;&gt; c = Counter(a=4, b=2)                   # a new counter from keyword args</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.collections.Counter.__missing__">
    
  </a>
  <a name="__missing__">
    
  </a>
  <div class="functionHeader">
    
    def
    __missing__(self, key):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">The count of elements not in the Counter is zero.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.collections.Counter.most_common">
    
  </a>
  <a name="most_common">
    
  </a>
  <div class="functionHeader">
    
    def
    most_common(self, n=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">List the n most common elements and their counts from the most
common to the least.  If n is None, then list all element counts.

&gt;&gt;&gt; Counter('abracadabra').most_common(3)
[('a', 5), ('b', 2), ('r', 2)]</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.collections.Counter.elements">
    
  </a>
  <a name="elements">
    
  </a>
  <div class="functionHeader">
    
    def
    elements(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Iterator over elements repeating each as many times as its count.

&gt;&gt;&gt; c = Counter('ABCABC')
&gt;&gt;&gt; sorted(c.elements())
['A', 'A', 'B', 'B', 'C', 'C']

# Knuth's example for prime factors of 1836:  2**2 * 3**3 * 17**1
&gt;&gt;&gt; prime_factors = Counter({2: 2, 3: 3, 17: 1})
&gt;&gt;&gt; product = 1
&gt;&gt;&gt; for factor in prime_factors.elements():     # loop over factors
...     product *= factor                       # and multiply them
&gt;&gt;&gt; product
1836

Note, if an element's count has been set to zero or is a negative
number, elements() will ignore it.</p></div>
  </div>
</div><div class="baseclassmethod">
  
  <a name="Lib.collections.Counter.fromkeys">
    
  </a>
  <a name="fromkeys">
    
  </a>
  <div class="functionHeader">
    @classmethod<br />
    def
    fromkeys(cls, iterable, v=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.collections.Counter.update">
    
  </a>
  <a name="update">
    
  </a>
  <div class="functionHeader">
    
    def
    update(**kwds):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Like dict.update() but add counts instead of replacing them.

Source can be an iterable, a dictionary, or another Counter instance.

&gt;&gt;&gt; c = Counter('which')
&gt;&gt;&gt; c.update('witch')           # add elements from another iterable
&gt;&gt;&gt; d = Counter('watch')
&gt;&gt;&gt; c.update(d)                 # add elements from another counter
&gt;&gt;&gt; c['h']                      # four 'h' in which, witch, and watch
4</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.collections.Counter.subtract">
    
  </a>
  <a name="subtract">
    
  </a>
  <div class="functionHeader">
    
    def
    subtract(**kwds):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Like dict.update() but subtracts counts instead of replacing them.
Counts can be reduced below zero.  Both the inputs and outputs are
allowed to contain zero and negative counts.

Source can be an iterable, a dictionary, or another Counter instance.

&gt;&gt;&gt; c = Counter('which')
&gt;&gt;&gt; c.subtract('witch')             # subtract elements from another iterable
&gt;&gt;&gt; c.subtract(Counter('watch'))    # subtract elements from another counter
&gt;&gt;&gt; c['h']                          # 2 in which, minus 1 in witch, minus 1 in watch
0
&gt;&gt;&gt; c['w']                          # 1 in which, minus 1 in witch, minus 1 in watch
-1</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.collections.Counter.copy">
    
  </a>
  <a name="copy">
    
  </a>
  <div class="functionHeader">
    
    def
    copy(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Return a shallow copy.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.collections.Counter.__reduce__">
    
  </a>
  <a name="__reduce__">
    
  </a>
  <div class="functionHeader">
    
    def
    __reduce__(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.collections.Counter.__delitem__">
    
  </a>
  <a name="__delitem__">
    
  </a>
  <div class="functionHeader">
    
    def
    __delitem__(self, elem):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Like dict.__delitem__() but does not raise KeyError for missing values.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.collections.Counter.__eq__">
    
  </a>
  <a name="__eq__">
    
  </a>
  <div class="functionHeader">
    
    def
    __eq__(self, other):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">True if all counts agree. Missing counts are treated as zero.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.collections.Counter.__ne__">
    
  </a>
  <a name="__ne__">
    
  </a>
  <div class="functionHeader">
    
    def
    __ne__(self, other):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">True if any counts disagree. Missing counts are treated as zero.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.collections.Counter.__le__">
    
  </a>
  <a name="__le__">
    
  </a>
  <div class="functionHeader">
    
    def
    __le__(self, other):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">True if all counts in self are a subset of those in other.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.collections.Counter.__lt__">
    
  </a>
  <a name="__lt__">
    
  </a>
  <div class="functionHeader">
    
    def
    __lt__(self, other):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">True if all counts in self are a proper subset of those in other.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.collections.Counter.__ge__">
    
  </a>
  <a name="__ge__">
    
  </a>
  <div class="functionHeader">
    
    def
    __ge__(self, other):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">True if all counts in self are a superset of those in other.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.collections.Counter.__gt__">
    
  </a>
  <a name="__gt__">
    
  </a>
  <div class="functionHeader">
    
    def
    __gt__(self, other):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">True if all counts in self are a proper superset of those in other.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.collections.Counter.__repr__">
    
  </a>
  <a name="__repr__">
    
  </a>
  <div class="functionHeader">
    
    def
    __repr__(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.collections.Counter.__add__">
    
  </a>
  <a name="__add__">
    
  </a>
  <div class="functionHeader">
    
    def
    __add__(self, other):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Add counts from two counters.

&gt;&gt;&gt; Counter('abbb') + Counter('bcc')
Counter({'b': 4, 'c': 2, 'a': 1})</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.collections.Counter.__sub__">
    
  </a>
  <a name="__sub__">
    
  </a>
  <div class="functionHeader">
    
    def
    __sub__(self, other):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Subtract count, but keep only results with positive counts.

&gt;&gt;&gt; Counter('abbbc') - Counter('bccd')
Counter({'b': 2, 'a': 1})</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.collections.Counter.__or__">
    
  </a>
  <a name="__or__">
    
  </a>
  <div class="functionHeader">
    
    def
    __or__(self, other):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Union is the maximum of value in either of the input counters.

&gt;&gt;&gt; Counter('abbb') | Counter('bcc')
Counter({'b': 3, 'c': 2, 'a': 1})</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.collections.Counter.__and__">
    
  </a>
  <a name="__and__">
    
  </a>
  <div class="functionHeader">
    
    def
    __and__(self, other):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Intersection is the minimum of corresponding counts.

&gt;&gt;&gt; Counter('abbb') &amp; Counter('bcc')
Counter({'b': 1})</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.collections.Counter.__pos__">
    
  </a>
  <a name="__pos__">
    
  </a>
  <div class="functionHeader">
    
    def
    __pos__(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Adds an empty counter, effectively stripping negative and zero counts</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.collections.Counter.__neg__">
    
  </a>
  <a name="__neg__">
    
  </a>
  <div class="functionHeader">
    
    def
    __neg__(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Subtracts from an empty counter.  Strips positive and zero counts,
and flips the sign on negative counts.</p></div>
  </div>
</div><div class="basemethod private">
  
  <a name="Lib.collections.Counter._keep_positive">
    
  </a>
  <a name="_keep_positive">
    
  </a>
  <div class="functionHeader">
    
    def
    _keep_positive(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Internal method to strip elements with a negative or zero count</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.collections.Counter.__iadd__">
    
  </a>
  <a name="__iadd__">
    
  </a>
  <div class="functionHeader">
    
    def
    __iadd__(self, other):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Inplace add from another counter, keeping only positive counts.

&gt;&gt;&gt; c = Counter('abbb')
&gt;&gt;&gt; c += Counter('bcc')
&gt;&gt;&gt; c
Counter({'b': 4, 'c': 2, 'a': 1})</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.collections.Counter.__isub__">
    
  </a>
  <a name="__isub__">
    
  </a>
  <div class="functionHeader">
    
    def
    __isub__(self, other):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Inplace subtract counter, but keep only results with positive counts.

&gt;&gt;&gt; c = Counter('abbbc')
&gt;&gt;&gt; c -= Counter('bccd')
&gt;&gt;&gt; c
Counter({'b': 2, 'a': 1})</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.collections.Counter.__ior__">
    
  </a>
  <a name="__ior__">
    
  </a>
  <div class="functionHeader">
    
    def
    __ior__(self, other):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Inplace union is the maximum of value from either counter.

&gt;&gt;&gt; c = Counter('abbb')
&gt;&gt;&gt; c |= Counter('bcc')
&gt;&gt;&gt; c
Counter({'b': 3, 'c': 2, 'a': 1})</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.collections.Counter.__iand__">
    
  </a>
  <a name="__iand__">
    
  </a>
  <div class="functionHeader">
    
    def
    __iand__(self, other):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Inplace intersection is the minimum of corresponding counts.

&gt;&gt;&gt; c = Counter('abbb')
&gt;&gt;&gt; c &amp;= Counter('bcc')
&gt;&gt;&gt; c
Counter({'b': 1})</p></div>
  </div>
</div>

      </div>
      <address>
        <a href="index.html">API Documentation</a> for Python3.8, generated by <a href="https://github.com/twisted/pydoctor/">pydoctor</a> 20.7.1 at 2020-11-24 05:40:36.
      </address>

    </div>

    <script src="pydoctor.js" type="text/javascript"></script>

  </body>
</html>