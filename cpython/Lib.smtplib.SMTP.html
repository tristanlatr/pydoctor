<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
          "DTD/xhtml1-strict.dtd">
<html>
  <head>
    <title>Lib.smtplib.SMTP : API documentation</title>

    <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
    <link rel="stylesheet" type="text/css" href="bootstrap.min.css" />
    <link rel="stylesheet" type="text/css" href="apidocs.css" />
  </head>
  <body>

    <nav class="navbar navbar-default">
      <div class="container">
        <div class="navbar-header">
          <a class="navbar-brand" href="index.html">
            Python3.8 API Documentation
          </a>
        </div>
      </div>
    </nav>

    <div id="showPrivate">
      <button class="btn btn-link" onclick="togglePrivate()">Toggle Private API</button>
    </div>

    <div class="container">

      <div class="page-header">
        <h1 class="class"><code><a href="Lib.html" class="code" data-type="Package">Lib</a>.<a href="Lib.smtplib.html" class="code" data-type="Module">smtplib</a>.<a href="Lib.smtplib.SMTP.html" class="code" data-type="Class">SMTP</a></code></h1>
      </div>

      <div class="categoryHeader">
        class documentation
      </div>

      <div class="extrasDocstring">
        <p><code><span class="py-keyword">class</span> Lib.smtplib.SMTP:</code></p><p>Known subclasses: <a href="Lib.smtplib.LMTP.html" class="code" data-type="Class">Lib.smtplib.LMTP</a>, <a href="Lib.smtplib.SMTP_SSL.html" class="code" data-type="Class">Lib.smtplib.SMTP_SSL</a></p>
        <p><a href="classIndex.html#Lib.smtplib.SMTP">View In Hierarchy</a></p>
      </div>

      <div class="moduleDocstring">
        <div><p class="pre">This class manages a connection to an SMTP or ESMTP server.
SMTP Objects:
    SMTP objects have the following attributes:
        helo_resp
            This is the message given by the server in response to the
            most recent HELO command.

        ehlo_resp
            This is the message given by the server in response to the
            most recent EHLO command. This is usually multiline.

        does_esmtp
            This is a True value _after you do an EHLO command_, if the
            server supports ESMTP.

        esmtp_features
            This is a dictionary, which, if the server supports ESMTP,
            will _after you do an EHLO command_, contain the names of the
            SMTP service extensions this server supports, and their
            parameters (if any).

            Note, all extension names are mapped to lower case in the
            dictionary.

    See each method's docstrings for details.  In general, there is a
    method of the same name to perform each SMTP command.  There is also a
    method called 'sendmail' that will do an entire mail transaction.
    </p></div>
      </div>

      <div id="splitTables">
        <table class="children sortable" id="id3529">
  
  <tr class="instancevariable">
    
    <td>Instance Variable</td>
    <td><a href="Lib.smtplib.SMTP.html#debuglevel" class="code" data-type="Instance Variable">debuglevel</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="instancevariable">
    
    <td>Instance Variable</td>
    <td><a href="Lib.smtplib.SMTP.html#sock" class="code" data-type="Instance Variable">sock</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="instancevariable">
    
    <td>Instance Variable</td>
    <td><a href="Lib.smtplib.SMTP.html#file" class="code" data-type="Instance Variable">file</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="instancevariable">
    
    <td>Instance Variable</td>
    <td><a href="Lib.smtplib.SMTP.html#helo_resp" class="code" data-type="Instance Variable">helo_resp</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="classvariable">
    
    <td>Class Variable</td>
    <td><a href="Lib.smtplib.SMTP.html#ehlo_msg" class="code" data-type="Class Variable">ehlo_msg</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="instancevariable">
    
    <td>Instance Variable</td>
    <td><a href="Lib.smtplib.SMTP.html#ehlo_resp" class="code" data-type="Instance Variable">ehlo_resp</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="instancevariable">
    
    <td>Instance Variable</td>
    <td><a href="Lib.smtplib.SMTP.html#does_esmtp" class="code" data-type="Instance Variable">does_esmtp</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.smtplib.SMTP.html#__init__" class="code" data-type="Method">__init__</a></td>
    <td><span>Initialize a new instance.</span></td>
  </tr><tr class="instancevariable">
    
    <td>Instance Variable</td>
    <td><a href="Lib.smtplib.SMTP.html#timeout" class="code" data-type="Instance Variable">timeout</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="instancevariable">
    
    <td>Instance Variable</td>
    <td><a href="Lib.smtplib.SMTP.html#esmtp_features" class="code" data-type="Instance Variable">esmtp_features</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="instancevariable">
    
    <td>Instance Variable</td>
    <td><a href="Lib.smtplib.SMTP.html#command_encoding" class="code" data-type="Instance Variable">command_encoding</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="instancevariable">
    
    <td>Instance Variable</td>
    <td><a href="Lib.smtplib.SMTP.html#source_address" class="code" data-type="Instance Variable">source_address</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="instancevariable">
    
    <td>Instance Variable</td>
    <td><a href="Lib.smtplib.SMTP.html#local_hostname" class="code" data-type="Instance Variable">local_hostname</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.smtplib.SMTP.html#__enter__" class="code" data-type="Method">__enter__</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.smtplib.SMTP.html#__exit__" class="code" data-type="Method">__exit__</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.smtplib.SMTP.html#set_debuglevel" class="code" data-type="Method">set_debuglevel</a></td>
    <td><span>Set the debug output level.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.smtplib.SMTP.html#connect" class="code" data-type="Method">connect</a></td>
    <td><span>Connect to a host on a given port.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.smtplib.SMTP.html#send" class="code" data-type="Method">send</a></td>
    <td><span>Send `s' to the server.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.smtplib.SMTP.html#putcmd" class="code" data-type="Method">putcmd</a></td>
    <td><span>Send a command to the server.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.smtplib.SMTP.html#getreply" class="code" data-type="Method">getreply</a></td>
    <td><span>Get a reply from the server.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.smtplib.SMTP.html#docmd" class="code" data-type="Method">docmd</a></td>
    <td><span>Send a command, and return its response code.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.smtplib.SMTP.html#helo" class="code" data-type="Method">helo</a></td>
    <td><span>SMTP 'helo' command. Hostname to send for this command defaults to the FQDN of the local host.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.smtplib.SMTP.html#ehlo" class="code" data-type="Method">ehlo</a></td>
    <td><span>SMTP 'ehlo' command. Hostname to send for this command defaults to the FQDN of the local host.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.smtplib.SMTP.html#has_extn" class="code" data-type="Method">has_extn</a></td>
    <td><span>Does the server support a given SMTP service extension?</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.smtplib.SMTP.html#help" class="code" data-type="Method">help</a></td>
    <td><span>SMTP 'help' command. Returns help text from server.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.smtplib.SMTP.html#rset" class="code" data-type="Method">rset</a></td>
    <td><span>SMTP 'rset' command -- resets session.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.smtplib.SMTP.html#noop" class="code" data-type="Method">noop</a></td>
    <td><span>SMTP 'noop' command -- doesn't do anything :&gt;</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.smtplib.SMTP.html#mail" class="code" data-type="Method">mail</a></td>
    <td><span>SMTP 'mail' command -- begins mail xfer session.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.smtplib.SMTP.html#rcpt" class="code" data-type="Method">rcpt</a></td>
    <td><span>SMTP 'rcpt' command -- indicates 1 recipient for this mail.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.smtplib.SMTP.html#data" class="code" data-type="Method">data</a></td>
    <td><span>SMTP 'DATA' command -- sends message data to server.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.smtplib.SMTP.html#verify" class="code" data-type="Method">verify</a></td>
    <td><span>SMTP 'verify' command -- checks for address validity.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.smtplib.SMTP.html#expn" class="code" data-type="Method">expn</a></td>
    <td><span>SMTP 'expn' command -- expands a mailing list.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.smtplib.SMTP.html#ehlo_or_helo_if_needed" class="code" data-type="Method">ehlo_or_helo_if_needed</a></td>
    <td><span>Call self.ehlo() and/or self.helo() if needed.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.smtplib.SMTP.html#auth" class="code" data-type="Method">auth</a></td>
    <td><span>Authentication command - requires response processing.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.smtplib.SMTP.html#auth_cram_md5" class="code" data-type="Method">auth_cram_md5</a></td>
    <td><span>Authobject to use with CRAM-MD5 authentication. Requires self.user and self.password to be set.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.smtplib.SMTP.html#auth_plain" class="code" data-type="Method">auth_plain</a></td>
    <td><span>Authobject to use with PLAIN authentication. Requires self.user and self.password to be set.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.smtplib.SMTP.html#auth_login" class="code" data-type="Method">auth_login</a></td>
    <td><span>Authobject to use with LOGIN authentication. Requires self.user and self.password to be set.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.smtplib.SMTP.html#login" class="code" data-type="Method">login</a></td>
    <td><span>Log in on an SMTP server that requires authentication.</span></td>
  </tr><tr class="instancevariable">
    
    <td>Instance Variable</td>
    <td><a href="Lib.smtplib.SMTP.html#user" class="code" data-type="Instance Variable">user</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="instancevariable">
    
    <td>Instance Variable</td>
    <td><a href="Lib.smtplib.SMTP.html#password" class="code" data-type="Instance Variable">password</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.smtplib.SMTP.html#starttls" class="code" data-type="Method">starttls</a></td>
    <td><span>Puts the connection to the SMTP server into TLS mode.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.smtplib.SMTP.html#sendmail" class="code" data-type="Method">sendmail</a></td>
    <td><span>This command performs an entire mail transaction.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.smtplib.SMTP.html#send_message" class="code" data-type="Method">send_message</a></td>
    <td><span>Converts message to a bytestring and passes it to sendmail.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.smtplib.SMTP.html#close" class="code" data-type="Method">close</a></td>
    <td><span>Close the connection to the SMTP server.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.smtplib.SMTP.html#quit" class="code" data-type="Method">quit</a></td>
    <td><span>Terminate the SMTP session.</span></td>
  </tr><tr class="instancevariable private">
    
    <td>Instance Variable</td>
    <td><a href="Lib.smtplib.SMTP.html#_host" class="code" data-type="Instance Variable">_host</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><a href="Lib.smtplib.SMTP.html#_print_debug" class="code" data-type="Method">_print_debug</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><a href="Lib.smtplib.SMTP.html#_get_socket" class="code" data-type="Method">_get_socket</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><a href="Lib.smtplib.SMTP.html#_rset" class="code" data-type="Method">_rset</a></td>
    <td><span>Internal 'rset' command which ignores any SMTPServerDisconnected error.</span></td>
  </tr>
</table>
        

          
      </div>

      <div id="childList">

        <div class="baseinstancevariable">
  
  <a name="Lib.smtplib.SMTP.debuglevel">
    
  </a>
  <a name="debuglevel">
    
  </a>
  <div class="functionHeader">
    debuglevel =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="baseinstancevariable">
  
  <a name="Lib.smtplib.SMTP.sock">
    
  </a>
  <a name="sock">
    
  </a>
  <div class="functionHeader">
    sock =
    
  </div>
  <div class="functionBody">
    <div class="interfaceinfo">overridden in <a href="Lib.smtplib.LMTP.html" class="code" data-type="Class">Lib.smtplib.LMTP</a></div>
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="baseinstancevariable">
  
  <a name="Lib.smtplib.SMTP.file">
    
  </a>
  <a name="file">
    
  </a>
  <div class="functionHeader">
    file =
    
  </div>
  <div class="functionBody">
    <div class="interfaceinfo">overridden in <a href="Lib.smtplib.LMTP.html" class="code" data-type="Class">Lib.smtplib.LMTP</a></div>
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="baseinstancevariable">
  
  <a name="Lib.smtplib.SMTP.helo_resp">
    
  </a>
  <a name="helo_resp">
    
  </a>
  <div class="functionHeader">
    helo_resp =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="baseclassvariable">
  
  <a name="Lib.smtplib.SMTP.ehlo_msg">
    
  </a>
  <a name="ehlo_msg">
    
  </a>
  <div class="functionHeader">
    ehlo_msg =
    
  </div>
  <div class="functionBody">
    <div class="interfaceinfo">overridden in <a href="Lib.smtplib.LMTP.html" class="code" data-type="Class">Lib.smtplib.LMTP</a></div>
    <div class="undocumented">Undocumented</div> (type: <code>str</code>)
  </div>
</div><div class="baseinstancevariable">
  
  <a name="Lib.smtplib.SMTP.ehlo_resp">
    
  </a>
  <a name="ehlo_resp">
    
  </a>
  <div class="functionHeader">
    ehlo_resp =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="baseinstancevariable">
  
  <a name="Lib.smtplib.SMTP.does_esmtp">
    
  </a>
  <a name="does_esmtp">
    
  </a>
  <div class="functionHeader">
    does_esmtp =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div> (type: <code>bool</code>)
  </div>
</div><div class="basemethod">
  
  <a name="Lib.smtplib.SMTP.__init__">
    
  </a>
  <a name="__init__">
    
  </a>
  <div class="functionHeader">
    
    def
    __init__(self, host="""""", port=0, local_hostname=None, timeout=socket._GLOBAL_DEFAULT_TIMEOUT, source_address=None):
    
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overridden in <a href="Lib.smtplib.LMTP.html" class="code" data-type="Class">Lib.smtplib.LMTP</a>, <a href="Lib.smtplib.SMTP_SSL.html" class="code" data-type="Class">Lib.smtplib.SMTP_SSL</a></div>
    
    <div><p class="pre">Initialize a new instance.

If specified, `host' is the name of the remote host to which to
connect.  If specified, `port' specifies the port to which to connect.
By default, smtplib.SMTP_PORT is used.  If a host is specified the
connect method is called, and if it returns anything other than a
success code an SMTPConnectError is raised.  If specified,
`local_hostname` is used as the FQDN of the local host in the HELO/EHLO
command.  Otherwise, the local hostname is found using
socket.getfqdn(). The `source_address` parameter takes a 2-tuple (host,
port) for the socket to bind to as its source address before
connecting. If the host is '' and port is 0, the OS default behavior
will be used.</p></div>
  </div>
</div><div class="baseinstancevariable private">
  
  <a name="Lib.smtplib.SMTP._host">
    
  </a>
  <a name="_host">
    
  </a>
  <div class="functionHeader">
    _host =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="baseinstancevariable">
  
  <a name="Lib.smtplib.SMTP.timeout">
    
  </a>
  <a name="timeout">
    
  </a>
  <div class="functionHeader">
    timeout =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="baseinstancevariable">
  
  <a name="Lib.smtplib.SMTP.esmtp_features">
    
  </a>
  <a name="esmtp_features">
    
  </a>
  <div class="functionHeader">
    esmtp_features =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div> (type: <code>Dict</code>)
  </div>
</div><div class="baseinstancevariable">
  
  <a name="Lib.smtplib.SMTP.command_encoding">
    
  </a>
  <a name="command_encoding">
    
  </a>
  <div class="functionHeader">
    command_encoding =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div> (type: <code>str</code>)
  </div>
</div><div class="baseinstancevariable">
  
  <a name="Lib.smtplib.SMTP.source_address">
    
  </a>
  <a name="source_address">
    
  </a>
  <div class="functionHeader">
    source_address =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="baseinstancevariable">
  
  <a name="Lib.smtplib.SMTP.local_hostname">
    
  </a>
  <a name="local_hostname">
    
  </a>
  <div class="functionHeader">
    local_hostname =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.smtplib.SMTP.__enter__">
    
  </a>
  <a name="__enter__">
    
  </a>
  <div class="functionHeader">
    
    def
    __enter__(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.smtplib.SMTP.__exit__">
    
  </a>
  <a name="__exit__">
    
  </a>
  <div class="functionHeader">
    
    def
    __exit__(self, *args):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.smtplib.SMTP.set_debuglevel">
    
  </a>
  <a name="set_debuglevel">
    
  </a>
  <div class="functionHeader">
    
    def
    set_debuglevel(self, debuglevel):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Set the debug output level.

A non-false value results in debug messages for connection and for all
messages sent to and received from the server.</p></div>
  </div>
</div><div class="basemethod private">
  
  <a name="Lib.smtplib.SMTP._print_debug">
    
  </a>
  <a name="_print_debug">
    
  </a>
  <div class="functionHeader">
    
    def
    _print_debug(self, *args):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basemethod private">
  
  <a name="Lib.smtplib.SMTP._get_socket">
    
  </a>
  <a name="_get_socket">
    
  </a>
  <div class="functionHeader">
    
    def
    _get_socket(self, host, port, timeout):
    
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overridden in <a href="Lib.smtplib.SMTP_SSL.html" class="code" data-type="Class">Lib.smtplib.SMTP_SSL</a></div>
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.smtplib.SMTP.connect">
    
  </a>
  <a name="connect">
    
  </a>
  <div class="functionHeader">
    
    def
    connect(self, host="""localhost""", port=0, source_address=None):
    
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overridden in <a href="Lib.smtplib.LMTP.html" class="code" data-type="Class">Lib.smtplib.LMTP</a></div>
    
    <div><p class="pre">Connect to a host on a given port.

If the hostname ends with a colon (`:') followed by a number, and
there is no port specified, that suffix will be stripped off and the
number interpreted as the port number to use.

Note: This method is automatically invoked by __init__, if a host is
specified during instantiation.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.smtplib.SMTP.send">
    
  </a>
  <a name="send">
    
  </a>
  <div class="functionHeader">
    
    def
    send(self, s):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Send `s' to the server.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.smtplib.SMTP.putcmd">
    
  </a>
  <a name="putcmd">
    
  </a>
  <div class="functionHeader">
    
    def
    putcmd(self, cmd, args=""""""):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Send a command to the server.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.smtplib.SMTP.getreply">
    
  </a>
  <a name="getreply">
    
  </a>
  <div class="functionHeader">
    
    def
    getreply(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Get a reply from the server.

Returns a tuple consisting of:

  - server response code (e.g. '250', or such, if all goes well)
    Note: returns -1 if it can't read response code.

  - server response string corresponding to response code (multiline
    responses are converted to a single, multiline string).

Raises SMTPServerDisconnected if end-of-file is reached.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.smtplib.SMTP.docmd">
    
  </a>
  <a name="docmd">
    
  </a>
  <div class="functionHeader">
    
    def
    docmd(self, cmd, args=""""""):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Send a command, and return its response code.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.smtplib.SMTP.helo">
    
  </a>
  <a name="helo">
    
  </a>
  <div class="functionHeader">
    
    def
    helo(self, name=""""""):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">SMTP 'helo' command.
Hostname to send for this command defaults to the FQDN of the local
host.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.smtplib.SMTP.ehlo">
    
  </a>
  <a name="ehlo">
    
  </a>
  <div class="functionHeader">
    
    def
    ehlo(self, name=""""""):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">SMTP 'ehlo' command.
Hostname to send for this command defaults to the FQDN of the local
host.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.smtplib.SMTP.has_extn">
    
  </a>
  <a name="has_extn">
    
  </a>
  <div class="functionHeader">
    
    def
    has_extn(self, opt):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Does the server support a given SMTP service extension?</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.smtplib.SMTP.help">
    
  </a>
  <a name="help">
    
  </a>
  <div class="functionHeader">
    
    def
    help(self, args=""""""):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">SMTP 'help' command.
Returns help text from server.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.smtplib.SMTP.rset">
    
  </a>
  <a name="rset">
    
  </a>
  <div class="functionHeader">
    
    def
    rset(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">SMTP 'rset' command -- resets session.</p></div>
  </div>
</div><div class="basemethod private">
  
  <a name="Lib.smtplib.SMTP._rset">
    
  </a>
  <a name="_rset">
    
  </a>
  <div class="functionHeader">
    
    def
    _rset(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Internal 'rset' command which ignores any SMTPServerDisconnected error.

Used internally in the library, since the server disconnected error
should appear to the application when the *next* command is issued, if
we are doing an internal "safety" reset.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.smtplib.SMTP.noop">
    
  </a>
  <a name="noop">
    
  </a>
  <div class="functionHeader">
    
    def
    noop(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">SMTP 'noop' command -- doesn't do anything :&gt;</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.smtplib.SMTP.mail">
    
  </a>
  <a name="mail">
    
  </a>
  <div class="functionHeader">
    
    def
    mail(self, sender, options=()):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">SMTP 'mail' command -- begins mail xfer session.

This method may raise the following exceptions:

 SMTPNotSupportedError  The options parameter includes 'SMTPUTF8'
                        but the SMTPUTF8 extension is not supported by
                        the server.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.smtplib.SMTP.rcpt">
    
  </a>
  <a name="rcpt">
    
  </a>
  <div class="functionHeader">
    
    def
    rcpt(self, recip, options=()):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">SMTP 'rcpt' command -- indicates 1 recipient for this mail.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.smtplib.SMTP.data">
    
  </a>
  <a name="data">
    
  </a>
  <div class="functionHeader">
    
    def
    data(self, msg):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">SMTP 'DATA' command -- sends message data to server.

Automatically quotes lines beginning with a period per rfc821.
Raises SMTPDataError if there is an unexpected reply to the
DATA command; the return value from this method is the final
response code received when the all data is sent.  If msg
is a string, lone '\r' and '\n' characters are converted to
'\r\n' characters.  If msg is bytes, it is transmitted as is.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.smtplib.SMTP.verify">
    
  </a>
  <a name="verify">
    
  </a>
  <div class="functionHeader">
    
    def
    verify(self, address):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">SMTP 'verify' command -- checks for address validity.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.smtplib.SMTP.expn">
    
  </a>
  <a name="expn">
    
  </a>
  <div class="functionHeader">
    
    def
    expn(self, address):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">SMTP 'expn' command -- expands a mailing list.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.smtplib.SMTP.ehlo_or_helo_if_needed">
    
  </a>
  <a name="ehlo_or_helo_if_needed">
    
  </a>
  <div class="functionHeader">
    
    def
    ehlo_or_helo_if_needed(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Call self.ehlo() and/or self.helo() if needed.

If there has been no previous EHLO or HELO command this session, this
method tries ESMTP EHLO first.

This method may raise the following exceptions:

 SMTPHeloError            The server didn't reply properly to
                          the helo greeting.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.smtplib.SMTP.auth">
    
  </a>
  <a name="auth">
    
  </a>
  <div class="functionHeader">
    
    def
    auth(self, mechanism, authobject):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Authentication command - requires response processing.

'mechanism' specifies which authentication mechanism is to
be used - the valid values are those listed in the 'auth'
element of 'esmtp_features'.

'authobject' must be a callable object taking a single argument:

        data = authobject(challenge)

It will be called to process the server's challenge response; the
challenge argument it is passed will be a bytes.  It should return
an ASCII string that will be base64 encoded and sent to the server.

Keyword arguments:
    - initial_response_ok: Allow sending the RFC 4954 initial-response
      to the AUTH command, if the authentication methods supports it.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.smtplib.SMTP.auth_cram_md5">
    
  </a>
  <a name="auth_cram_md5">
    
  </a>
  <div class="functionHeader">
    
    def
    auth_cram_md5(self, challenge=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Authobject to use with CRAM-MD5 authentication. Requires self.user
and self.password to be set.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.smtplib.SMTP.auth_plain">
    
  </a>
  <a name="auth_plain">
    
  </a>
  <div class="functionHeader">
    
    def
    auth_plain(self, challenge=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Authobject to use with PLAIN authentication. Requires self.user and
self.password to be set.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.smtplib.SMTP.auth_login">
    
  </a>
  <a name="auth_login">
    
  </a>
  <div class="functionHeader">
    
    def
    auth_login(self, challenge=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Authobject to use with LOGIN authentication. Requires self.user and
self.password to be set.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.smtplib.SMTP.login">
    
  </a>
  <a name="login">
    
  </a>
  <div class="functionHeader">
    
    def
    login(self, user, password):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Log in on an SMTP server that requires authentication.

The arguments are:
    - user:         The user name to authenticate with.
    - password:     The password for the authentication.

Keyword arguments:
    - initial_response_ok: Allow sending the RFC 4954 initial-response
      to the AUTH command, if the authentication methods supports it.

If there has been no previous EHLO or HELO command this session, this
method tries ESMTP EHLO first.

This method will return normally if the authentication was successful.

This method may raise the following exceptions:

 SMTPHeloError            The server didn't reply properly to
                          the helo greeting.
 SMTPAuthenticationError  The server didn't accept the username/
                          password combination.
 SMTPNotSupportedError    The AUTH command is not supported by the
                          server.
 SMTPException            No suitable authentication method was
                          found.</p></div>
  </div>
</div><div class="baseinstancevariable">
  
  <a name="Lib.smtplib.SMTP.user">
    
  </a>
  <a name="user">
    
  </a>
  <div class="functionHeader">
    user =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="baseinstancevariable">
  
  <a name="Lib.smtplib.SMTP.password">
    
  </a>
  <a name="password">
    
  </a>
  <div class="functionHeader">
    password =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.smtplib.SMTP.starttls">
    
  </a>
  <a name="starttls">
    
  </a>
  <div class="functionHeader">
    
    def
    starttls(self, keyfile=None, certfile=None, context=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Puts the connection to the SMTP server into TLS mode.

If there has been no previous EHLO or HELO command this session, this
method tries ESMTP EHLO first.

If the server supports TLS, this will encrypt the rest of the SMTP
session. If you provide the keyfile and certfile parameters,
the identity of the SMTP server and client can be checked. This,
however, depends on whether the socket module really checks the
certificates.

This method may raise the following exceptions:

 SMTPHeloError            The server didn't reply properly to
                          the helo greeting.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.smtplib.SMTP.sendmail">
    
  </a>
  <a name="sendmail">
    
  </a>
  <div class="functionHeader">
    
    def
    sendmail(self, from_addr, to_addrs, msg, mail_options=(), rcpt_options=()):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">This command performs an entire mail transaction.

The arguments are:
    - from_addr    : The address sending this mail.
    - to_addrs     : A list of addresses to send this mail to.  A bare
                     string will be treated as a list with 1 address.
    - msg          : The message to send.
    - mail_options : List of ESMTP options (such as 8bitmime) for the
                     mail command.
    - rcpt_options : List of ESMTP options (such as DSN commands) for
                     all the rcpt commands.

msg may be a string containing characters in the ASCII range, or a byte
string.  A string is encoded to bytes using the ascii codec, and lone
\r and \n characters are converted to \r\n characters.

If there has been no previous EHLO or HELO command this session, this
method tries ESMTP EHLO first.  If the server does ESMTP, message size
and each of the specified options will be passed to it.  If EHLO
fails, HELO will be tried and ESMTP options suppressed.

This method will return normally if the mail is accepted for at least
one recipient.  It returns a dictionary, with one entry for each
recipient that was refused.  Each entry contains a tuple of the SMTP
error code and the accompanying error message sent by the server.

This method may raise the following exceptions:

 SMTPHeloError          The server didn't reply properly to
                        the helo greeting.
 SMTPRecipientsRefused  The server rejected ALL recipients
                        (no mail was sent).
 SMTPSenderRefused      The server didn't accept the from_addr.
 SMTPDataError          The server replied with an unexpected
                        error code (other than a refusal of
                        a recipient).
 SMTPNotSupportedError  The mail_options parameter includes 'SMTPUTF8'
                        but the SMTPUTF8 extension is not supported by
                        the server.

Note: the connection will be open even after an exception is raised.

Example:

 &gt;&gt;&gt; import smtplib
 &gt;&gt;&gt; s=smtplib.SMTP("localhost")
 &gt;&gt;&gt; tolist=["one@one.org","two@two.org","three@three.org","four@four.org"]
 &gt;&gt;&gt; msg = '''\
 ... From: Me@my.org
 ... Subject: testin'...
 ...
 ... This is a test '''
 &gt;&gt;&gt; s.sendmail("me@my.org",tolist,msg)
 { "three@three.org" : ( 550 ,"User unknown" ) }
 &gt;&gt;&gt; s.quit()

In the above example, the message was accepted for delivery to three
of the four addresses, and one was rejected, with the error code
550.  If all addresses are accepted, then the method will return an
empty dictionary.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.smtplib.SMTP.send_message">
    
  </a>
  <a name="send_message">
    
  </a>
  <div class="functionHeader">
    
    def
    send_message(self, msg, from_addr=None, to_addrs=None, mail_options=(), rcpt_options=()):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Converts message to a bytestring and passes it to sendmail.

The arguments are as for sendmail, except that msg is an
email.message.Message object.  If from_addr is None or to_addrs is
None, these arguments are taken from the headers of the Message as
described in RFC 2822 (a ValueError is raised if there is more than
one set of 'Resent-' headers).  Regardless of the values of from_addr and
to_addr, any Bcc field (or Resent-Bcc field, when the Message is a
resent) of the Message object won't be transmitted.  The Message
object is then serialized using email.generator.BytesGenerator and
sendmail is called to transmit the message.  If the sender or any of
the recipient addresses contain non-ASCII and the server advertises the
SMTPUTF8 capability, the policy is cloned with utf8 set to True for the
serialization, and SMTPUTF8 and BODY=8BITMIME are asserted on the send.
If the server does not support SMTPUTF8, an SMTPNotSupported error is
raised.  Otherwise the generator is called without modifying the
policy.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.smtplib.SMTP.close">
    
  </a>
  <a name="close">
    
  </a>
  <div class="functionHeader">
    
    def
    close(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Close the connection to the SMTP server.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.smtplib.SMTP.quit">
    
  </a>
  <a name="quit">
    
  </a>
  <div class="functionHeader">
    
    def
    quit(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Terminate the SMTP session.</p></div>
  </div>
</div>

      </div>
      <address>
        <a href="index.html">API Documentation</a> for Python3.8, generated by <a href="https://github.com/twisted/pydoctor/">pydoctor</a> 20.7.1 at 2020-11-24 05:11:37.
      </address>

    </div>

    <script src="pydoctor.js" type="text/javascript"></script>

  </body>
</html>