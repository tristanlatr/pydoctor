<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
          "DTD/xhtml1-strict.dtd">
<html>
  <head>
    <title>Lib._pydecimal.Decimal : API documentation</title>

    <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
    <link rel="stylesheet" type="text/css" href="bootstrap.min.css" />
    <link rel="stylesheet" type="text/css" href="apidocs.css" />
  </head>
  <body>

    <nav class="navbar navbar-default">
      <div class="container">
        <div class="navbar-header">
          <a class="navbar-brand" href="index.html">
            Python3.8 API Documentation
          </a>
        </div>
      </div>
    </nav>

    <div id="showPrivate">
      <button class="btn btn-link" onclick="togglePrivate()">Toggle Private API</button>
    </div>

    <div class="container">

      <div class="page-header">
        <h1 class="class"><code><a href="Lib.html" class="code" data-type="Package">Lib</a>.<a href="Lib._pydecimal.html" class="code" data-type="Module">_pydecimal</a>.<a href="Lib._pydecimal.Decimal.html" class="code" data-type="Class">Decimal</a></code></h1>
      </div>

      <div class="categoryHeader">
        class documentation
      </div>

      <div class="extrasDocstring">
        <p><code><span class="py-keyword">class</span> Lib._pydecimal.Decimal(<span title="object">object</span>):</code></p>
        <p><a href="classIndex.html#Lib._pydecimal.Decimal">View In Hierarchy</a></p>
      </div>

      <div class="moduleDocstring">
        <div><p class="pre">Floating point class for decimal arithmetic.</p></div>
      </div>

      <div id="splitTables">
        <table class="children sortable" id="id129">
  
  <tr class="classvariable">
    
    <td>Class Variable</td>
    <td><a href="Lib._pydecimal.Decimal.html#__slots__" class="code" data-type="Class Variable">__slots__</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Decimal.html#__new__" class="code" data-type="Method">__new__</a></td>
    <td><span>Create a decimal point instance.</span></td>
  </tr><tr class="classmethod">
    
    <td>Class Method</td>
    <td><a href="Lib._pydecimal.Decimal.html#from_float" class="code" data-type="Class Method">from_float</a></td>
    <td><span>Converts a float to a decimal number, exactly.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Decimal.html#__bool__" class="code" data-type="Method">__bool__</a></td>
    <td><span>Return True if self is nonzero; otherwise return False.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Decimal.html#__eq__" class="code" data-type="Method">__eq__</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Decimal.html#__lt__" class="code" data-type="Method">__lt__</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Decimal.html#__le__" class="code" data-type="Method">__le__</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Decimal.html#__gt__" class="code" data-type="Method">__gt__</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Decimal.html#__ge__" class="code" data-type="Method">__ge__</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Decimal.html#compare" class="code" data-type="Method">compare</a></td>
    <td><span>Compare self to other.  Return a decimal value:</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Decimal.html#__hash__" class="code" data-type="Method">__hash__</a></td>
    <td><span>x.__hash__() &lt;==&gt; hash(x)</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Decimal.html#as_tuple" class="code" data-type="Method">as_tuple</a></td>
    <td><span>Represents the number as a triple tuple.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Decimal.html#as_integer_ratio" class="code" data-type="Method">as_integer_ratio</a></td>
    <td><span>Express a finite Decimal instance in the form n / d.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Decimal.html#__repr__" class="code" data-type="Method">__repr__</a></td>
    <td><span>Represents the number as an instance of Decimal.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Decimal.html#__str__" class="code" data-type="Method">__str__</a></td>
    <td><span>Return string representation of the number in scientific notation.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Decimal.html#to_eng_string" class="code" data-type="Method">to_eng_string</a></td>
    <td><span>Convert to a string, using engineering notation if an exponent is needed.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Decimal.html#__neg__" class="code" data-type="Method">__neg__</a></td>
    <td><span>Returns a copy with the sign switched.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Decimal.html#__pos__" class="code" data-type="Method">__pos__</a></td>
    <td><span>Returns a copy, unless it is a sNaN.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Decimal.html#__abs__" class="code" data-type="Method">__abs__</a></td>
    <td><span>Returns the absolute value of self.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Decimal.html#__add__" class="code" data-type="Method">__add__</a></td>
    <td><span>Returns self + other.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Decimal.html#__sub__" class="code" data-type="Method">__sub__</a></td>
    <td><span>Return self - other</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Decimal.html#__rsub__" class="code" data-type="Method">__rsub__</a></td>
    <td><span>Return other - self</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Decimal.html#__mul__" class="code" data-type="Method">__mul__</a></td>
    <td><span>Return self * other.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Decimal.html#__truediv__" class="code" data-type="Method">__truediv__</a></td>
    <td><span>Return self / other.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Decimal.html#__rtruediv__" class="code" data-type="Method">__rtruediv__</a></td>
    <td><span>Swaps self/other and returns __truediv__.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Decimal.html#__divmod__" class="code" data-type="Method">__divmod__</a></td>
    <td><span>Return (self // other, self % other)</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Decimal.html#__rdivmod__" class="code" data-type="Method">__rdivmod__</a></td>
    <td><span>Swaps self/other and returns __divmod__.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Decimal.html#__mod__" class="code" data-type="Method">__mod__</a></td>
    <td><span>self % other</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Decimal.html#__rmod__" class="code" data-type="Method">__rmod__</a></td>
    <td><span>Swaps self/other and returns __mod__.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Decimal.html#remainder_near" class="code" data-type="Method">remainder_near</a></td>
    <td><span>Remainder nearest to 0-  abs(remainder-near) &lt;= other/2</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Decimal.html#__floordiv__" class="code" data-type="Method">__floordiv__</a></td>
    <td><span>self // other</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Decimal.html#__rfloordiv__" class="code" data-type="Method">__rfloordiv__</a></td>
    <td><span>Swaps self/other and returns __floordiv__.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Decimal.html#__float__" class="code" data-type="Method">__float__</a></td>
    <td><span>Float representation.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Decimal.html#__int__" class="code" data-type="Method">__int__</a></td>
    <td><span>Converts self to an int, truncating if necessary.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Decimal.html#real" class="code" data-type="Method">real</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Decimal.html#imag" class="code" data-type="Method">imag</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Decimal.html#conjugate" class="code" data-type="Method">conjugate</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Decimal.html#__complex__" class="code" data-type="Method">__complex__</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Decimal.html#__round__" class="code" data-type="Method">__round__</a></td>
    <td><span>Round self to the nearest integer, or to a given precision.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Decimal.html#__floor__" class="code" data-type="Method">__floor__</a></td>
    <td><span>Return the floor of self, as an integer.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Decimal.html#__ceil__" class="code" data-type="Method">__ceil__</a></td>
    <td><span>Return the ceiling of self, as an integer.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Decimal.html#fma" class="code" data-type="Method">fma</a></td>
    <td><span>Fused multiply-add.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Decimal.html#__pow__" class="code" data-type="Method">__pow__</a></td>
    <td><span>Return self ** other [ % modulo].</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Decimal.html#__rpow__" class="code" data-type="Method">__rpow__</a></td>
    <td><span>Swaps self/other and returns __pow__.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Decimal.html#normalize" class="code" data-type="Method">normalize</a></td>
    <td><span>Normalize- strip trailing 0s, change anything equal to 0 to 0e0</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Decimal.html#quantize" class="code" data-type="Method">quantize</a></td>
    <td><span>Quantize self so its exponent is the same as that of exp.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Decimal.html#same_quantum" class="code" data-type="Method">same_quantum</a></td>
    <td><span>Return True if self and other have the same exponent; otherwise return False.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Decimal.html#to_integral_exact" class="code" data-type="Method">to_integral_exact</a></td>
    <td><span>Rounds to a nearby integer.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Decimal.html#to_integral_value" class="code" data-type="Method">to_integral_value</a></td>
    <td><span>Rounds to the nearest integer, without raising inexact, rounded.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Decimal.html#sqrt" class="code" data-type="Method">sqrt</a></td>
    <td><span>Return the square root of self.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Decimal.html#max" class="code" data-type="Method">max</a></td>
    <td><span>Returns the larger value.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Decimal.html#min" class="code" data-type="Method">min</a></td>
    <td><span>Returns the smaller value.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Decimal.html#adjusted" class="code" data-type="Method">adjusted</a></td>
    <td><span>Return the adjusted exponent of self</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Decimal.html#canonical" class="code" data-type="Method">canonical</a></td>
    <td><span>Returns the same Decimal object.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Decimal.html#compare_signal" class="code" data-type="Method">compare_signal</a></td>
    <td><span>Compares self to the other operand numerically.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Decimal.html#compare_total" class="code" data-type="Method">compare_total</a></td>
    <td><span>Compares self to other using the abstract representations.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Decimal.html#compare_total_mag" class="code" data-type="Method">compare_total_mag</a></td>
    <td><span>Compares self to other using abstract repr., ignoring sign.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Decimal.html#copy_abs" class="code" data-type="Method">copy_abs</a></td>
    <td><span>Returns a copy with the sign set to 0.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Decimal.html#copy_negate" class="code" data-type="Method">copy_negate</a></td>
    <td><span>Returns a copy with the sign inverted.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Decimal.html#copy_sign" class="code" data-type="Method">copy_sign</a></td>
    <td><span>Returns self with the sign of other.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Decimal.html#exp" class="code" data-type="Method">exp</a></td>
    <td><span>Returns e ** self.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Decimal.html#is_canonical" class="code" data-type="Method">is_canonical</a></td>
    <td><span>Return True if self is canonical; otherwise return False.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Decimal.html#is_finite" class="code" data-type="Method">is_finite</a></td>
    <td><span>Return True if self is finite; otherwise return False.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Decimal.html#is_infinite" class="code" data-type="Method">is_infinite</a></td>
    <td><span>Return True if self is infinite; otherwise return False.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Decimal.html#is_nan" class="code" data-type="Method">is_nan</a></td>
    <td><span>Return True if self is a qNaN or sNaN; otherwise return False.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Decimal.html#is_normal" class="code" data-type="Method">is_normal</a></td>
    <td><span>Return True if self is a normal number; otherwise return False.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Decimal.html#is_qnan" class="code" data-type="Method">is_qnan</a></td>
    <td><span>Return True if self is a quiet NaN; otherwise return False.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Decimal.html#is_signed" class="code" data-type="Method">is_signed</a></td>
    <td><span>Return True if self is negative; otherwise return False.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Decimal.html#is_snan" class="code" data-type="Method">is_snan</a></td>
    <td><span>Return True if self is a signaling NaN; otherwise return False.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Decimal.html#is_subnormal" class="code" data-type="Method">is_subnormal</a></td>
    <td><span>Return True if self is subnormal; otherwise return False.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Decimal.html#is_zero" class="code" data-type="Method">is_zero</a></td>
    <td><span>Return True if self is a zero; otherwise return False.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Decimal.html#ln" class="code" data-type="Method">ln</a></td>
    <td><span>Returns the natural (base e) logarithm of self.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Decimal.html#log10" class="code" data-type="Method">log10</a></td>
    <td><span>Returns the base 10 logarithm of self.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Decimal.html#logb" class="code" data-type="Method">logb</a></td>
    <td><span>Returns the exponent of the magnitude of self's MSD.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Decimal.html#logical_and" class="code" data-type="Method">logical_and</a></td>
    <td><span>Applies an 'and' operation between self and other's digits.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Decimal.html#logical_invert" class="code" data-type="Method">logical_invert</a></td>
    <td><span>Invert all its digits.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Decimal.html#logical_or" class="code" data-type="Method">logical_or</a></td>
    <td><span>Applies an 'or' operation between self and other's digits.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Decimal.html#logical_xor" class="code" data-type="Method">logical_xor</a></td>
    <td><span>Applies an 'xor' operation between self and other's digits.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Decimal.html#max_mag" class="code" data-type="Method">max_mag</a></td>
    <td><span>Compares the values numerically with their sign ignored.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Decimal.html#min_mag" class="code" data-type="Method">min_mag</a></td>
    <td><span>Compares the values numerically with their sign ignored.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Decimal.html#next_minus" class="code" data-type="Method">next_minus</a></td>
    <td><span>Returns the largest representable number smaller than itself.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Decimal.html#next_plus" class="code" data-type="Method">next_plus</a></td>
    <td><span>Returns the smallest representable number larger than itself.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Decimal.html#next_toward" class="code" data-type="Method">next_toward</a></td>
    <td><span>Returns the number closest to self, in the direction towards other.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Decimal.html#number_class" class="code" data-type="Method">number_class</a></td>
    <td><span>Returns an indication of the class of self.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Decimal.html#radix" class="code" data-type="Method">radix</a></td>
    <td><span>Just returns 10, as this is Decimal, :)</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Decimal.html#rotate" class="code" data-type="Method">rotate</a></td>
    <td><span>Returns a rotated copy of self, value-of-other times.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Decimal.html#scaleb" class="code" data-type="Method">scaleb</a></td>
    <td><span>Returns self operand after adding the second value to its exp.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Decimal.html#shift" class="code" data-type="Method">shift</a></td>
    <td><span>Returns a shifted copy of self, value-of-other times.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Decimal.html#__reduce__" class="code" data-type="Method">__reduce__</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Decimal.html#__copy__" class="code" data-type="Method">__copy__</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Decimal.html#__deepcopy__" class="code" data-type="Method">__deepcopy__</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Decimal.html#__format__" class="code" data-type="Method">__format__</a></td>
    <td><span>Format a Decimal instance according to the given specifier.</span></td>
  </tr><tr class="instancevariable private">
    
    <td>Instance Variable</td>
    <td><a href="Lib._pydecimal.Decimal.html#_sign" class="code" data-type="Instance Variable">_sign</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="instancevariable private">
    
    <td>Instance Variable</td>
    <td><a href="Lib._pydecimal.Decimal.html#_int" class="code" data-type="Instance Variable">_int</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="instancevariable private">
    
    <td>Instance Variable</td>
    <td><a href="Lib._pydecimal.Decimal.html#_exp" class="code" data-type="Instance Variable">_exp</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="instancevariable private">
    
    <td>Instance Variable</td>
    <td><a href="Lib._pydecimal.Decimal.html#_is_special" class="code" data-type="Instance Variable">_is_special</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Decimal.html#_isnan" class="code" data-type="Method">_isnan</a></td>
    <td><span>Returns whether the number is not actually one.</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Decimal.html#_isinfinity" class="code" data-type="Method">_isinfinity</a></td>
    <td><span>Returns whether the number is infinite</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Decimal.html#_check_nans" class="code" data-type="Method">_check_nans</a></td>
    <td><span>Returns whether the number is not actually one.</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Decimal.html#_compare_check_nans" class="code" data-type="Method">_compare_check_nans</a></td>
    <td><span>Version of _check_nans used for the signaling comparisons compare_signal, __le__, __lt__, __ge__, __gt__.</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Decimal.html#_cmp" class="code" data-type="Method">_cmp</a></td>
    <td><span>Compare the two non-NaN decimal instances self and other.</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Decimal.html#_divide" class="code" data-type="Method">_divide</a></td>
    <td><span>Return (self // other, self % other), to context.prec precision.</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Decimal.html#_fix_nan" class="code" data-type="Method">_fix_nan</a></td>
    <td><span>Decapitate the payload of a NaN to fit the context</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Decimal.html#_fix" class="code" data-type="Method">_fix</a></td>
    <td><span>Round if it is necessary to keep self within prec precision.</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Decimal.html#_round_down" class="code" data-type="Method">_round_down</a></td>
    <td><span>Also known as round-towards-0, truncate.</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Decimal.html#_round_up" class="code" data-type="Method">_round_up</a></td>
    <td><span>Rounds away from 0.</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Decimal.html#_round_half_up" class="code" data-type="Method">_round_half_up</a></td>
    <td><span>Rounds 5 up (away from 0)</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Decimal.html#_round_half_down" class="code" data-type="Method">_round_half_down</a></td>
    <td><span>Round 5 down</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Decimal.html#_round_half_even" class="code" data-type="Method">_round_half_even</a></td>
    <td><span>Round 5 to even, rest to nearest.</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Decimal.html#_round_ceiling" class="code" data-type="Method">_round_ceiling</a></td>
    <td><span>Rounds up (not away from 0 if negative.)</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Decimal.html#_round_floor" class="code" data-type="Method">_round_floor</a></td>
    <td><span>Rounds down (not towards 0 if negative)</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Decimal.html#_round_05up" class="code" data-type="Method">_round_05up</a></td>
    <td><span>Round down unless digit prec-1 is 0 or 5.</span></td>
  </tr><tr class="classvariable private">
    
    <td>Class Variable</td>
    <td><a href="Lib._pydecimal.Decimal.html#_pick_rounding_function" class="code" data-type="Class Variable">_pick_rounding_function</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Decimal.html#_power_modulo" class="code" data-type="Method">_power_modulo</a></td>
    <td><span>Three argument version of __pow__</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Decimal.html#_power_exact" class="code" data-type="Method">_power_exact</a></td>
    <td><span>Attempt to compute self**other exactly.</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Decimal.html#_rescale" class="code" data-type="Method">_rescale</a></td>
    <td><span>Rescale self so that the exponent is exp, either by padding with zeros or by truncating digits, using the given rounding mode.</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Decimal.html#_round" class="code" data-type="Method">_round</a></td>
    <td><span>Round a nonzero, nonspecial Decimal to a fixed number of significant figures, using the given rounding mode.</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Decimal.html#_isinteger" class="code" data-type="Method">_isinteger</a></td>
    <td><span>Returns whether self is an integer</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Decimal.html#_iseven" class="code" data-type="Method">_iseven</a></td>
    <td><span>Returns True if self is even.  Assumes self is an integer.</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Decimal.html#_ln_exp_bound" class="code" data-type="Method">_ln_exp_bound</a></td>
    <td><span>Compute a lower bound for the adjusted exponent of self.ln(). In other words, compute r such that self.ln() &gt;= 10**r.  Assumes that self is finite and positive and that self != 1.</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Decimal.html#_log10_exp_bound" class="code" data-type="Method">_log10_exp_bound</a></td>
    <td><span>Compute a lower bound for the adjusted exponent of self.log10(). In other words, find r such that self.log10() &gt;= 10**r. Assumes that self is finite and positive and that self != 1.</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Decimal.html#_islogical" class="code" data-type="Method">_islogical</a></td>
    <td><span>Return True if self is a logical operand.</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Decimal.html#_fill_logical" class="code" data-type="Method">_fill_logical</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr>
</table>
        

          
      </div>

      <div id="childList">

        <div class="baseclassvariable">
  
  <a name="Lib._pydecimal.Decimal.__slots__">
    
  </a>
  <a name="__slots__">
    
  </a>
  <div class="functionHeader">
    __slots__ =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div> (type: <code>Tuple[str, ...]</code>)
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Decimal.__new__">
    
  </a>
  <a name="__new__">
    
  </a>
  <div class="functionHeader">
    
    def
    __new__(cls, value="""0""", context=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Create a decimal point instance.

&gt;&gt;&gt; Decimal('3.14')              # string input
Decimal('3.14')
&gt;&gt;&gt; Decimal((0, (3, 1, 4), -2))  # tuple (sign, digit_tuple, exponent)
Decimal('3.14')
&gt;&gt;&gt; Decimal(314)                 # int
Decimal('314')
&gt;&gt;&gt; Decimal(Decimal(314))        # another decimal instance
Decimal('314')
&gt;&gt;&gt; Decimal('  3.14  \n')        # leading and trailing whitespace okay
Decimal('3.14')</p></div>
  </div>
</div><div class="baseinstancevariable private">
  
  <a name="Lib._pydecimal.Decimal._sign">
    
  </a>
  <a name="_sign">
    
  </a>
  <div class="functionHeader">
    _sign =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="baseinstancevariable private">
  
  <a name="Lib._pydecimal.Decimal._int">
    
  </a>
  <a name="_int">
    
  </a>
  <div class="functionHeader">
    _int =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="baseinstancevariable private">
  
  <a name="Lib._pydecimal.Decimal._exp">
    
  </a>
  <a name="_exp">
    
  </a>
  <div class="functionHeader">
    _exp =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="baseinstancevariable private">
  
  <a name="Lib._pydecimal.Decimal._is_special">
    
  </a>
  <a name="_is_special">
    
  </a>
  <div class="functionHeader">
    _is_special =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="baseclassmethod">
  
  <a name="Lib._pydecimal.Decimal.from_float">
    
  </a>
  <a name="from_float">
    
  </a>
  <div class="functionHeader">
    @classmethod<br />
    def
    from_float(cls, f):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Converts a float to a decimal number, exactly.

Note that Decimal.from_float(0.1) is not the same as Decimal('0.1').
Since 0.1 is not exactly representable in binary floating point, the
value is stored as the nearest representable value which is
0x1.999999999999ap-4.  The exact equivalent of the value in decimal
is 0.1000000000000000055511151231257827021181583404541015625.

&gt;&gt;&gt; Decimal.from_float(0.1)
Decimal('0.1000000000000000055511151231257827021181583404541015625')
&gt;&gt;&gt; Decimal.from_float(float('nan'))
Decimal('NaN')
&gt;&gt;&gt; Decimal.from_float(float('inf'))
Decimal('Infinity')
&gt;&gt;&gt; Decimal.from_float(-float('inf'))
Decimal('-Infinity')
&gt;&gt;&gt; Decimal.from_float(-0.0)
Decimal('-0')</p></div>
  </div>
</div><div class="basemethod private">
  
  <a name="Lib._pydecimal.Decimal._isnan">
    
  </a>
  <a name="_isnan">
    
  </a>
  <div class="functionHeader">
    
    def
    _isnan(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Returns whether the number is not actually one.

0 if a number
1 if NaN
2 if sNaN</p></div>
  </div>
</div><div class="basemethod private">
  
  <a name="Lib._pydecimal.Decimal._isinfinity">
    
  </a>
  <a name="_isinfinity">
    
  </a>
  <div class="functionHeader">
    
    def
    _isinfinity(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Returns whether the number is infinite

0 if finite or not a number
1 if +INF
-1 if -INF</p></div>
  </div>
</div><div class="basemethod private">
  
  <a name="Lib._pydecimal.Decimal._check_nans">
    
  </a>
  <a name="_check_nans">
    
  </a>
  <div class="functionHeader">
    
    def
    _check_nans(self, other=None, context=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Returns whether the number is not actually one.

if self, other are sNaN, signal
if self, other are NaN return nan
return 0

Done before operations.</p></div>
  </div>
</div><div class="basemethod private">
  
  <a name="Lib._pydecimal.Decimal._compare_check_nans">
    
  </a>
  <a name="_compare_check_nans">
    
  </a>
  <div class="functionHeader">
    
    def
    _compare_check_nans(self, other, context):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Version of _check_nans used for the signaling comparisons
compare_signal, __le__, __lt__, __ge__, __gt__.

Signal InvalidOperation if either self or other is a (quiet
or signaling) NaN.  Signaling NaNs take precedence over quiet
NaNs.

Return 0 if neither operand is a NaN.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Decimal.__bool__">
    
  </a>
  <a name="__bool__">
    
  </a>
  <div class="functionHeader">
    
    def
    __bool__(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Return True if self is nonzero; otherwise return False.

NaNs and infinities are considered nonzero.</p></div>
  </div>
</div><div class="basemethod private">
  
  <a name="Lib._pydecimal.Decimal._cmp">
    
  </a>
  <a name="_cmp">
    
  </a>
  <div class="functionHeader">
    
    def
    _cmp(self, other):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Compare the two non-NaN decimal instances self and other.

Returns -1 if self &lt; other, 0 if self == other and 1
if self &gt; other.  This routine is for internal use only.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Decimal.__eq__">
    
  </a>
  <a name="__eq__">
    
  </a>
  <div class="functionHeader">
    
    def
    __eq__(self, other, context=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Decimal.__lt__">
    
  </a>
  <a name="__lt__">
    
  </a>
  <div class="functionHeader">
    
    def
    __lt__(self, other, context=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Decimal.__le__">
    
  </a>
  <a name="__le__">
    
  </a>
  <div class="functionHeader">
    
    def
    __le__(self, other, context=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Decimal.__gt__">
    
  </a>
  <a name="__gt__">
    
  </a>
  <div class="functionHeader">
    
    def
    __gt__(self, other, context=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Decimal.__ge__">
    
  </a>
  <a name="__ge__">
    
  </a>
  <div class="functionHeader">
    
    def
    __ge__(self, other, context=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Decimal.compare">
    
  </a>
  <a name="compare">
    
  </a>
  <div class="functionHeader">
    
    def
    compare(self, other, context=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Compare self to other.  Return a decimal value:

a or b is a NaN ==&gt; Decimal('NaN')
a &lt; b           ==&gt; Decimal('-1')
a == b          ==&gt; Decimal('0')
a &gt; b           ==&gt; Decimal('1')</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Decimal.__hash__">
    
  </a>
  <a name="__hash__">
    
  </a>
  <div class="functionHeader">
    
    def
    __hash__(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">x.__hash__() &lt;==&gt; hash(x)</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Decimal.as_tuple">
    
  </a>
  <a name="as_tuple">
    
  </a>
  <div class="functionHeader">
    
    def
    as_tuple(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Represents the number as a triple tuple.

To show the internals exactly as they are.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Decimal.as_integer_ratio">
    
  </a>
  <a name="as_integer_ratio">
    
  </a>
  <div class="functionHeader">
    
    def
    as_integer_ratio(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Express a finite Decimal instance in the form n / d.

Returns a pair (n, d) of integers.  When called on an infinity
or NaN, raises OverflowError or ValueError respectively.

&gt;&gt;&gt; Decimal('3.14').as_integer_ratio()
(157, 50)
&gt;&gt;&gt; Decimal('-123e5').as_integer_ratio()
(-12300000, 1)
&gt;&gt;&gt; Decimal('0.00').as_integer_ratio()
(0, 1)</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Decimal.__repr__">
    
  </a>
  <a name="__repr__">
    
  </a>
  <div class="functionHeader">
    
    def
    __repr__(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Represents the number as an instance of Decimal.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Decimal.__str__">
    
  </a>
  <a name="__str__">
    
  </a>
  <div class="functionHeader">
    
    def
    __str__(self, eng=(False), context=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Return string representation of the number in scientific notation.

Captures all of the information in the underlying representation.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Decimal.to_eng_string">
    
  </a>
  <a name="to_eng_string">
    
  </a>
  <div class="functionHeader">
    
    def
    to_eng_string(self, context=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Convert to a string, using engineering notation if an exponent is needed.

Engineering notation has an exponent which is a multiple of 3.  This
can leave up to 3 digits to the left of the decimal place and may
require the addition of either one or two trailing zeros.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Decimal.__neg__">
    
  </a>
  <a name="__neg__">
    
  </a>
  <div class="functionHeader">
    
    def
    __neg__(self, context=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Returns a copy with the sign switched.

Rounds, if it has reason.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Decimal.__pos__">
    
  </a>
  <a name="__pos__">
    
  </a>
  <div class="functionHeader">
    
    def
    __pos__(self, context=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Returns a copy, unless it is a sNaN.

Rounds the number (if more than precision digits)</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Decimal.__abs__">
    
  </a>
  <a name="__abs__">
    
  </a>
  <div class="functionHeader">
    
    def
    __abs__(self, round=(True), context=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Returns the absolute value of self.

If the keyword argument 'round' is false, do not round.  The
expression self.__abs__(round=False) is equivalent to
self.copy_abs().</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Decimal.__add__">
    
  </a>
  <a name="__add__">
    
  </a>
  <div class="functionHeader">
    
    def
    __add__(self, other, context=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Returns self + other.

-INF + INF (or the reverse) cause InvalidOperation errors.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Decimal.__sub__">
    
  </a>
  <a name="__sub__">
    
  </a>
  <div class="functionHeader">
    
    def
    __sub__(self, other, context=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Return self - other</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Decimal.__rsub__">
    
  </a>
  <a name="__rsub__">
    
  </a>
  <div class="functionHeader">
    
    def
    __rsub__(self, other, context=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Return other - self</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Decimal.__mul__">
    
  </a>
  <a name="__mul__">
    
  </a>
  <div class="functionHeader">
    
    def
    __mul__(self, other, context=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Return self * other.

(+-) INF * 0 (or its reverse) raise InvalidOperation.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Decimal.__truediv__">
    
  </a>
  <a name="__truediv__">
    
  </a>
  <div class="functionHeader">
    
    def
    __truediv__(self, other, context=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Return self / other.</p></div>
  </div>
</div><div class="basemethod private">
  
  <a name="Lib._pydecimal.Decimal._divide">
    
  </a>
  <a name="_divide">
    
  </a>
  <div class="functionHeader">
    
    def
    _divide(self, other, context):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Return (self // other, self % other), to context.prec precision.

Assumes that neither self nor other is a NaN, that self is not
infinite and that other is nonzero.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Decimal.__rtruediv__">
    
  </a>
  <a name="__rtruediv__">
    
  </a>
  <div class="functionHeader">
    
    def
    __rtruediv__(self, other, context=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Swaps self/other and returns __truediv__.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Decimal.__divmod__">
    
  </a>
  <a name="__divmod__">
    
  </a>
  <div class="functionHeader">
    
    def
    __divmod__(self, other, context=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Return (self // other, self % other)</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Decimal.__rdivmod__">
    
  </a>
  <a name="__rdivmod__">
    
  </a>
  <div class="functionHeader">
    
    def
    __rdivmod__(self, other, context=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Swaps self/other and returns __divmod__.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Decimal.__mod__">
    
  </a>
  <a name="__mod__">
    
  </a>
  <div class="functionHeader">
    
    def
    __mod__(self, other, context=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">self % other</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Decimal.__rmod__">
    
  </a>
  <a name="__rmod__">
    
  </a>
  <div class="functionHeader">
    
    def
    __rmod__(self, other, context=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Swaps self/other and returns __mod__.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Decimal.remainder_near">
    
  </a>
  <a name="remainder_near">
    
  </a>
  <div class="functionHeader">
    
    def
    remainder_near(self, other, context=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Remainder nearest to 0-  abs(remainder-near) &lt;= other/2</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Decimal.__floordiv__">
    
  </a>
  <a name="__floordiv__">
    
  </a>
  <div class="functionHeader">
    
    def
    __floordiv__(self, other, context=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">self // other</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Decimal.__rfloordiv__">
    
  </a>
  <a name="__rfloordiv__">
    
  </a>
  <div class="functionHeader">
    
    def
    __rfloordiv__(self, other, context=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Swaps self/other and returns __floordiv__.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Decimal.__float__">
    
  </a>
  <a name="__float__">
    
  </a>
  <div class="functionHeader">
    
    def
    __float__(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Float representation.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Decimal.__int__">
    
  </a>
  <a name="__int__">
    
  </a>
  <div class="functionHeader">
    
    def
    __int__(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Converts self to an int, truncating if necessary.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Decimal.real">
    
  </a>
  <a name="real">
    
  </a>
  <div class="functionHeader">
    @property<br />
    def
    real(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Decimal.imag">
    
  </a>
  <a name="imag">
    
  </a>
  <div class="functionHeader">
    @property<br />
    def
    imag(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Decimal.conjugate">
    
  </a>
  <a name="conjugate">
    
  </a>
  <div class="functionHeader">
    
    def
    conjugate(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Decimal.__complex__">
    
  </a>
  <a name="__complex__">
    
  </a>
  <div class="functionHeader">
    
    def
    __complex__(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basemethod private">
  
  <a name="Lib._pydecimal.Decimal._fix_nan">
    
  </a>
  <a name="_fix_nan">
    
  </a>
  <div class="functionHeader">
    
    def
    _fix_nan(self, context):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Decapitate the payload of a NaN to fit the context</p></div>
  </div>
</div><div class="basemethod private">
  
  <a name="Lib._pydecimal.Decimal._fix">
    
  </a>
  <a name="_fix">
    
  </a>
  <div class="functionHeader">
    
    def
    _fix(self, context):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Round if it is necessary to keep self within prec precision.

Rounds and fixes the exponent.  Does not raise on a sNaN.

Arguments:
self - Decimal instance
context - context used.</p></div>
  </div>
</div><div class="basemethod private">
  
  <a name="Lib._pydecimal.Decimal._round_down">
    
  </a>
  <a name="_round_down">
    
  </a>
  <div class="functionHeader">
    
    def
    _round_down(self, prec):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Also known as round-towards-0, truncate.</p></div>
  </div>
</div><div class="basemethod private">
  
  <a name="Lib._pydecimal.Decimal._round_up">
    
  </a>
  <a name="_round_up">
    
  </a>
  <div class="functionHeader">
    
    def
    _round_up(self, prec):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Rounds away from 0.</p></div>
  </div>
</div><div class="basemethod private">
  
  <a name="Lib._pydecimal.Decimal._round_half_up">
    
  </a>
  <a name="_round_half_up">
    
  </a>
  <div class="functionHeader">
    
    def
    _round_half_up(self, prec):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Rounds 5 up (away from 0)</p></div>
  </div>
</div><div class="basemethod private">
  
  <a name="Lib._pydecimal.Decimal._round_half_down">
    
  </a>
  <a name="_round_half_down">
    
  </a>
  <div class="functionHeader">
    
    def
    _round_half_down(self, prec):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Round 5 down</p></div>
  </div>
</div><div class="basemethod private">
  
  <a name="Lib._pydecimal.Decimal._round_half_even">
    
  </a>
  <a name="_round_half_even">
    
  </a>
  <div class="functionHeader">
    
    def
    _round_half_even(self, prec):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Round 5 to even, rest to nearest.</p></div>
  </div>
</div><div class="basemethod private">
  
  <a name="Lib._pydecimal.Decimal._round_ceiling">
    
  </a>
  <a name="_round_ceiling">
    
  </a>
  <div class="functionHeader">
    
    def
    _round_ceiling(self, prec):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Rounds up (not away from 0 if negative.)</p></div>
  </div>
</div><div class="basemethod private">
  
  <a name="Lib._pydecimal.Decimal._round_floor">
    
  </a>
  <a name="_round_floor">
    
  </a>
  <div class="functionHeader">
    
    def
    _round_floor(self, prec):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Rounds down (not towards 0 if negative)</p></div>
  </div>
</div><div class="basemethod private">
  
  <a name="Lib._pydecimal.Decimal._round_05up">
    
  </a>
  <a name="_round_05up">
    
  </a>
  <div class="functionHeader">
    
    def
    _round_05up(self, prec):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Round down unless digit prec-1 is 0 or 5.</p></div>
  </div>
</div><div class="baseclassvariable private">
  
  <a name="Lib._pydecimal.Decimal._pick_rounding_function">
    
  </a>
  <a name="_pick_rounding_function">
    
  </a>
  <div class="functionHeader">
    _pick_rounding_function =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Decimal.__round__">
    
  </a>
  <a name="__round__">
    
  </a>
  <div class="functionHeader">
    
    def
    __round__(self, n=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Round self to the nearest integer, or to a given precision.

If only one argument is supplied, round a finite Decimal
instance self to the nearest integer.  If self is infinite or
a NaN then a Python exception is raised.  If self is finite
and lies exactly halfway between two integers then it is
rounded to the integer with even last digit.

&gt;&gt;&gt; round(Decimal('123.456'))
123
&gt;&gt;&gt; round(Decimal('-456.789'))
-457
&gt;&gt;&gt; round(Decimal('-3.0'))
-3
&gt;&gt;&gt; round(Decimal('2.5'))
2
&gt;&gt;&gt; round(Decimal('3.5'))
4
&gt;&gt;&gt; round(Decimal('Inf'))
Traceback (most recent call last):
  ...
OverflowError: cannot round an infinity
&gt;&gt;&gt; round(Decimal('NaN'))
Traceback (most recent call last):
  ...
ValueError: cannot round a NaN

If a second argument n is supplied, self is rounded to n
decimal places using the rounding mode for the current
context.

For an integer n, round(self, -n) is exactly equivalent to
self.quantize(Decimal('1En')).

&gt;&gt;&gt; round(Decimal('123.456'), 0)
Decimal('123')
&gt;&gt;&gt; round(Decimal('123.456'), 2)
Decimal('123.46')
&gt;&gt;&gt; round(Decimal('123.456'), -2)
Decimal('1E+2')
&gt;&gt;&gt; round(Decimal('-Infinity'), 37)
Decimal('NaN')
&gt;&gt;&gt; round(Decimal('sNaN123'), 0)
Decimal('NaN123')</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Decimal.__floor__">
    
  </a>
  <a name="__floor__">
    
  </a>
  <div class="functionHeader">
    
    def
    __floor__(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Return the floor of self, as an integer.

For a finite Decimal instance self, return the greatest
integer n such that n &lt;= self.  If self is infinite or a NaN
then a Python exception is raised.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Decimal.__ceil__">
    
  </a>
  <a name="__ceil__">
    
  </a>
  <div class="functionHeader">
    
    def
    __ceil__(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Return the ceiling of self, as an integer.

For a finite Decimal instance self, return the least integer n
such that n &gt;= self.  If self is infinite or a NaN then a
Python exception is raised.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Decimal.fma">
    
  </a>
  <a name="fma">
    
  </a>
  <div class="functionHeader">
    
    def
    fma(self, other, third, context=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Fused multiply-add.

Returns self*other+third with no rounding of the intermediate
product self*other.

self and other are multiplied together, with no rounding of
the result.  The third operand is then added to the result,
and a single final rounding is performed.</p></div>
  </div>
</div><div class="basemethod private">
  
  <a name="Lib._pydecimal.Decimal._power_modulo">
    
  </a>
  <a name="_power_modulo">
    
  </a>
  <div class="functionHeader">
    
    def
    _power_modulo(self, other, modulo, context=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Three argument version of __pow__</p></div>
  </div>
</div><div class="basemethod private">
  
  <a name="Lib._pydecimal.Decimal._power_exact">
    
  </a>
  <a name="_power_exact">
    
  </a>
  <div class="functionHeader">
    
    def
    _power_exact(self, other, p):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Attempt to compute self**other exactly.

Given Decimals self and other and an integer p, attempt to
compute an exact result for the power self**other, with p
digits of precision.  Return None if self**other is not
exactly representable in p digits.

Assumes that elimination of special cases has already been
performed: self and other must both be nonspecial; self must
be positive and not numerically equal to 1; other must be
nonzero.  For efficiency, other._exp should not be too large,
so that 10**abs(other._exp) is a feasible calculation.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Decimal.__pow__">
    
  </a>
  <a name="__pow__">
    
  </a>
  <div class="functionHeader">
    
    def
    __pow__(self, other, modulo=None, context=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Return self ** other [ % modulo].

With two arguments, compute self**other.

With three arguments, compute (self**other) % modulo.  For the
three argument form, the following restrictions on the
arguments hold:

 - all three arguments must be integral
 - other must be nonnegative
 - either self or other (or both) must be nonzero
 - modulo must be nonzero and must have at most p digits,
   where p is the context precision.

If any of these restrictions is violated the InvalidOperation
flag is raised.

The result of pow(self, other, modulo) is identical to the
result that would be obtained by computing (self**other) %
modulo with unbounded precision, but is computed more
efficiently.  It is always exact.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Decimal.__rpow__">
    
  </a>
  <a name="__rpow__">
    
  </a>
  <div class="functionHeader">
    
    def
    __rpow__(self, other, context=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Swaps self/other and returns __pow__.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Decimal.normalize">
    
  </a>
  <a name="normalize">
    
  </a>
  <div class="functionHeader">
    
    def
    normalize(self, context=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Normalize- strip trailing 0s, change anything equal to 0 to 0e0</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Decimal.quantize">
    
  </a>
  <a name="quantize">
    
  </a>
  <div class="functionHeader">
    
    def
    quantize(self, exp, rounding=None, context=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Quantize self so its exponent is the same as that of exp.

Similar to self._rescale(exp._exp) but with error checking.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Decimal.same_quantum">
    
  </a>
  <a name="same_quantum">
    
  </a>
  <div class="functionHeader">
    
    def
    same_quantum(self, other, context=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Return True if self and other have the same exponent; otherwise
return False.

If either operand is a special value, the following rules are used:
   * return True if both operands are infinities
   * return True if both operands are NaNs
   * otherwise, return False.</p></div>
  </div>
</div><div class="basemethod private">
  
  <a name="Lib._pydecimal.Decimal._rescale">
    
  </a>
  <a name="_rescale">
    
  </a>
  <div class="functionHeader">
    
    def
    _rescale(self, exp, rounding):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Rescale self so that the exponent is exp, either by padding with zeros
or by truncating digits, using the given rounding mode.

Specials are returned without change.  This operation is
quiet: it raises no flags, and uses no information from the
context.

exp = exp to scale to (an integer)
rounding = rounding mode</p></div>
  </div>
</div><div class="basemethod private">
  
  <a name="Lib._pydecimal.Decimal._round">
    
  </a>
  <a name="_round">
    
  </a>
  <div class="functionHeader">
    
    def
    _round(self, places, rounding):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Round a nonzero, nonspecial Decimal to a fixed number of
significant figures, using the given rounding mode.

Infinities, NaNs and zeros are returned unaltered.

This operation is quiet: it raises no flags, and uses no
information from the context.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Decimal.to_integral_exact">
    
  </a>
  <a name="to_integral_exact">
    
  </a>
  <div class="functionHeader">
    
    def
    to_integral_exact(self, rounding=None, context=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Rounds to a nearby integer.

If no rounding mode is specified, take the rounding mode from
the context.  This method raises the Rounded and Inexact flags
when appropriate.

See also: to_integral_value, which does exactly the same as
this method except that it doesn't raise Inexact or Rounded.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Decimal.to_integral_value">
    
  </a>
  <a name="to_integral_value">
    
  </a>
  <div class="functionHeader">
    
    def
    to_integral_value(self, rounding=None, context=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Rounds to the nearest integer, without raising inexact, rounded.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Decimal.sqrt">
    
  </a>
  <a name="sqrt">
    
  </a>
  <div class="functionHeader">
    
    def
    sqrt(self, context=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Return the square root of self.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Decimal.max">
    
  </a>
  <a name="max">
    
  </a>
  <div class="functionHeader">
    
    def
    max(self, other, context=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Returns the larger value.

Like max(self, other) except if one is not a number, returns
NaN (and signals if one is sNaN).  Also rounds.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Decimal.min">
    
  </a>
  <a name="min">
    
  </a>
  <div class="functionHeader">
    
    def
    min(self, other, context=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Returns the smaller value.

Like min(self, other) except if one is not a number, returns
NaN (and signals if one is sNaN).  Also rounds.</p></div>
  </div>
</div><div class="basemethod private">
  
  <a name="Lib._pydecimal.Decimal._isinteger">
    
  </a>
  <a name="_isinteger">
    
  </a>
  <div class="functionHeader">
    
    def
    _isinteger(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Returns whether self is an integer</p></div>
  </div>
</div><div class="basemethod private">
  
  <a name="Lib._pydecimal.Decimal._iseven">
    
  </a>
  <a name="_iseven">
    
  </a>
  <div class="functionHeader">
    
    def
    _iseven(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Returns True if self is even.  Assumes self is an integer.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Decimal.adjusted">
    
  </a>
  <a name="adjusted">
    
  </a>
  <div class="functionHeader">
    
    def
    adjusted(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Return the adjusted exponent of self</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Decimal.canonical">
    
  </a>
  <a name="canonical">
    
  </a>
  <div class="functionHeader">
    
    def
    canonical(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Returns the same Decimal object.

As we do not have different encodings for the same number, the
received object already is in its canonical form.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Decimal.compare_signal">
    
  </a>
  <a name="compare_signal">
    
  </a>
  <div class="functionHeader">
    
    def
    compare_signal(self, other, context=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Compares self to the other operand numerically.

It's pretty much like compare(), but all NaNs signal, with signaling
NaNs taking precedence over quiet NaNs.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Decimal.compare_total">
    
  </a>
  <a name="compare_total">
    
  </a>
  <div class="functionHeader">
    
    def
    compare_total(self, other, context=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Compares self to other using the abstract representations.

This is not like the standard compare, which use their numerical
value. Note that a total ordering is defined for all possible abstract
representations.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Decimal.compare_total_mag">
    
  </a>
  <a name="compare_total_mag">
    
  </a>
  <div class="functionHeader">
    
    def
    compare_total_mag(self, other, context=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Compares self to other using abstract repr., ignoring sign.

Like compare_total, but with operand's sign ignored and assumed to be 0.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Decimal.copy_abs">
    
  </a>
  <a name="copy_abs">
    
  </a>
  <div class="functionHeader">
    
    def
    copy_abs(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Returns a copy with the sign set to 0. </p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Decimal.copy_negate">
    
  </a>
  <a name="copy_negate">
    
  </a>
  <div class="functionHeader">
    
    def
    copy_negate(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Returns a copy with the sign inverted.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Decimal.copy_sign">
    
  </a>
  <a name="copy_sign">
    
  </a>
  <div class="functionHeader">
    
    def
    copy_sign(self, other, context=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Returns self with the sign of other.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Decimal.exp">
    
  </a>
  <a name="exp">
    
  </a>
  <div class="functionHeader">
    
    def
    exp(self, context=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Returns e ** self.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Decimal.is_canonical">
    
  </a>
  <a name="is_canonical">
    
  </a>
  <div class="functionHeader">
    
    def
    is_canonical(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Return True if self is canonical; otherwise return False.

Currently, the encoding of a Decimal instance is always
canonical, so this method returns True for any Decimal.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Decimal.is_finite">
    
  </a>
  <a name="is_finite">
    
  </a>
  <div class="functionHeader">
    
    def
    is_finite(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Return True if self is finite; otherwise return False.

A Decimal instance is considered finite if it is neither
infinite nor a NaN.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Decimal.is_infinite">
    
  </a>
  <a name="is_infinite">
    
  </a>
  <div class="functionHeader">
    
    def
    is_infinite(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Return True if self is infinite; otherwise return False.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Decimal.is_nan">
    
  </a>
  <a name="is_nan">
    
  </a>
  <div class="functionHeader">
    
    def
    is_nan(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Return True if self is a qNaN or sNaN; otherwise return False.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Decimal.is_normal">
    
  </a>
  <a name="is_normal">
    
  </a>
  <div class="functionHeader">
    
    def
    is_normal(self, context=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Return True if self is a normal number; otherwise return False.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Decimal.is_qnan">
    
  </a>
  <a name="is_qnan">
    
  </a>
  <div class="functionHeader">
    
    def
    is_qnan(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Return True if self is a quiet NaN; otherwise return False.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Decimal.is_signed">
    
  </a>
  <a name="is_signed">
    
  </a>
  <div class="functionHeader">
    
    def
    is_signed(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Return True if self is negative; otherwise return False.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Decimal.is_snan">
    
  </a>
  <a name="is_snan">
    
  </a>
  <div class="functionHeader">
    
    def
    is_snan(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Return True if self is a signaling NaN; otherwise return False.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Decimal.is_subnormal">
    
  </a>
  <a name="is_subnormal">
    
  </a>
  <div class="functionHeader">
    
    def
    is_subnormal(self, context=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Return True if self is subnormal; otherwise return False.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Decimal.is_zero">
    
  </a>
  <a name="is_zero">
    
  </a>
  <div class="functionHeader">
    
    def
    is_zero(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Return True if self is a zero; otherwise return False.</p></div>
  </div>
</div><div class="basemethod private">
  
  <a name="Lib._pydecimal.Decimal._ln_exp_bound">
    
  </a>
  <a name="_ln_exp_bound">
    
  </a>
  <div class="functionHeader">
    
    def
    _ln_exp_bound(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Compute a lower bound for the adjusted exponent of self.ln().
In other words, compute r such that self.ln() &gt;= 10**r.  Assumes
that self is finite and positive and that self != 1.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Decimal.ln">
    
  </a>
  <a name="ln">
    
  </a>
  <div class="functionHeader">
    
    def
    ln(self, context=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Returns the natural (base e) logarithm of self.</p></div>
  </div>
</div><div class="basemethod private">
  
  <a name="Lib._pydecimal.Decimal._log10_exp_bound">
    
  </a>
  <a name="_log10_exp_bound">
    
  </a>
  <div class="functionHeader">
    
    def
    _log10_exp_bound(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Compute a lower bound for the adjusted exponent of self.log10().
In other words, find r such that self.log10() &gt;= 10**r.
Assumes that self is finite and positive and that self != 1.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Decimal.log10">
    
  </a>
  <a name="log10">
    
  </a>
  <div class="functionHeader">
    
    def
    log10(self, context=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Returns the base 10 logarithm of self.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Decimal.logb">
    
  </a>
  <a name="logb">
    
  </a>
  <div class="functionHeader">
    
    def
    logb(self, context=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Returns the exponent of the magnitude of self's MSD.

The result is the integer which is the exponent of the magnitude
of the most significant digit of self (as though it were truncated
to a single digit while maintaining the value of that digit and
without limiting the resulting exponent).</p></div>
  </div>
</div><div class="basemethod private">
  
  <a name="Lib._pydecimal.Decimal._islogical">
    
  </a>
  <a name="_islogical">
    
  </a>
  <div class="functionHeader">
    
    def
    _islogical(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Return True if self is a logical operand.

For being logical, it must be a finite number with a sign of 0,
an exponent of 0, and a coefficient whose digits must all be
either 0 or 1.</p></div>
  </div>
</div><div class="basemethod private">
  
  <a name="Lib._pydecimal.Decimal._fill_logical">
    
  </a>
  <a name="_fill_logical">
    
  </a>
  <div class="functionHeader">
    
    def
    _fill_logical(self, context, opa, opb):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Decimal.logical_and">
    
  </a>
  <a name="logical_and">
    
  </a>
  <div class="functionHeader">
    
    def
    logical_and(self, other, context=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Applies an 'and' operation between self and other's digits.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Decimal.logical_invert">
    
  </a>
  <a name="logical_invert">
    
  </a>
  <div class="functionHeader">
    
    def
    logical_invert(self, context=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Invert all its digits.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Decimal.logical_or">
    
  </a>
  <a name="logical_or">
    
  </a>
  <div class="functionHeader">
    
    def
    logical_or(self, other, context=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Applies an 'or' operation between self and other's digits.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Decimal.logical_xor">
    
  </a>
  <a name="logical_xor">
    
  </a>
  <div class="functionHeader">
    
    def
    logical_xor(self, other, context=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Applies an 'xor' operation between self and other's digits.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Decimal.max_mag">
    
  </a>
  <a name="max_mag">
    
  </a>
  <div class="functionHeader">
    
    def
    max_mag(self, other, context=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Compares the values numerically with their sign ignored.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Decimal.min_mag">
    
  </a>
  <a name="min_mag">
    
  </a>
  <div class="functionHeader">
    
    def
    min_mag(self, other, context=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Compares the values numerically with their sign ignored.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Decimal.next_minus">
    
  </a>
  <a name="next_minus">
    
  </a>
  <div class="functionHeader">
    
    def
    next_minus(self, context=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Returns the largest representable number smaller than itself.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Decimal.next_plus">
    
  </a>
  <a name="next_plus">
    
  </a>
  <div class="functionHeader">
    
    def
    next_plus(self, context=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Returns the smallest representable number larger than itself.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Decimal.next_toward">
    
  </a>
  <a name="next_toward">
    
  </a>
  <div class="functionHeader">
    
    def
    next_toward(self, other, context=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Returns the number closest to self, in the direction towards other.

The result is the closest representable number to self
(excluding self) that is in the direction towards other,
unless both have the same value.  If the two operands are
numerically equal, then the result is a copy of self with the
sign set to be the same as the sign of other.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Decimal.number_class">
    
  </a>
  <a name="number_class">
    
  </a>
  <div class="functionHeader">
    
    def
    number_class(self, context=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Returns an indication of the class of self.

The class is one of the following strings:
  sNaN
  NaN
  -Infinity
  -Normal
  -Subnormal
  -Zero
  +Zero
  +Subnormal
  +Normal
  +Infinity</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Decimal.radix">
    
  </a>
  <a name="radix">
    
  </a>
  <div class="functionHeader">
    
    def
    radix(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Just returns 10, as this is Decimal, :)</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Decimal.rotate">
    
  </a>
  <a name="rotate">
    
  </a>
  <div class="functionHeader">
    
    def
    rotate(self, other, context=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Returns a rotated copy of self, value-of-other times.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Decimal.scaleb">
    
  </a>
  <a name="scaleb">
    
  </a>
  <div class="functionHeader">
    
    def
    scaleb(self, other, context=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Returns self operand after adding the second value to its exp.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Decimal.shift">
    
  </a>
  <a name="shift">
    
  </a>
  <div class="functionHeader">
    
    def
    shift(self, other, context=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Returns a shifted copy of self, value-of-other times.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Decimal.__reduce__">
    
  </a>
  <a name="__reduce__">
    
  </a>
  <div class="functionHeader">
    
    def
    __reduce__(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Decimal.__copy__">
    
  </a>
  <a name="__copy__">
    
  </a>
  <div class="functionHeader">
    
    def
    __copy__(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Decimal.__deepcopy__">
    
  </a>
  <a name="__deepcopy__">
    
  </a>
  <div class="functionHeader">
    
    def
    __deepcopy__(self, memo):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Decimal.__format__">
    
  </a>
  <a name="__format__">
    
  </a>
  <div class="functionHeader">
    
    def
    __format__(self, specifier, context=None, _localeconv=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Format a Decimal instance according to the given specifier.

The specifier should be a standard format specifier, with the
form described in PEP 3101.  Formatting types 'e', 'E', 'f',
'F', 'g', 'G', 'n' and '%' are supported.  If the formatting
type is omitted it defaults to 'g' or 'G', depending on the
value of context.capitals.</p></div>
  </div>
</div>

      </div>
      <address>
        <a href="index.html">API Documentation</a> for Python3.8, generated by <a href="https://github.com/twisted/pydoctor/">pydoctor</a> 20.7.1 at 2020-11-24 05:40:36.
      </address>

    </div>

    <script src="pydoctor.js" type="text/javascript"></script>

  </body>
</html>