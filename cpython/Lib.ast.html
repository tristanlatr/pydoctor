<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
          "DTD/xhtml1-strict.dtd">
<html>
  <head>
    <title>Lib.ast : API documentation</title>

    <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
    <link rel="stylesheet" type="text/css" href="bootstrap.min.css" />
    <link rel="stylesheet" type="text/css" href="apidocs.css" />
  </head>
  <body>

    <nav class="navbar navbar-default">
      <div class="container">
        <div class="navbar-header">
          <a class="navbar-brand" href="index.html">
            Python3.8 API Documentation
          </a>
        </div>
      </div>
    </nav>

    <div id="showPrivate">
      <button class="btn btn-link" onclick="togglePrivate()">Toggle Private API</button>
    </div>

    <div class="container">

      <div class="page-header">
        <h1 class="module"><code><a href="Lib.html" class="code" data-type="Package">Lib</a>.<a href="Lib.ast.html" class="code" data-type="Module">ast</a></code></h1>
      </div>

      <div class="categoryHeader">
        module documentation
      </div>

      <div class="extrasDocstring">
        
        <p></p>
      </div>

      <div class="moduleDocstring">
        <div><p class="pre">ast
~~~

The `ast` module helps Python applications to process trees of the Python
abstract syntax grammar.  The abstract syntax itself might change with
each Python release; this module helps to find out programmatically what
the current grammar looks like and allows modifications of it.

An abstract syntax tree can be generated by passing `ast.PyCF_ONLY_AST` as
a flag to the `compile()` builtin function or by using the `parse()`
function from this module.  The result will be a tree of objects whose
classes all inherit from `ast.AST`.

A modified abstract syntax tree can be compiled into a Python code object
using the built-in `compile()` function.

Additionally various helper functions are provided that make working with
the trees simpler.  The main intention of the helper functions and this
module in general is to provide an easy to use interface for libraries
that work tightly with the python syntax (template engines for example).


:copyright: Copyright 2008 by Armin Ronacher.
:license: Python License.</p></div>
      </div>

      <div id="splitTables">
        <table class="children sortable" id="id270">
  
  <tr class="function">
    
    <td>Function</td>
    <td><a href="Lib.ast.html#parse" class="code" data-type="Function">parse</a></td>
    <td><span>Parse the source into an AST node. Equivalent to compile(source, filename, mode, PyCF_ONLY_AST). Pass type_comments=True to get back type comments where the syntax allows.</span></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><a href="Lib.ast.html#literal_eval" class="code" data-type="Function">literal_eval</a></td>
    <td><span class="undocumented">No summary</span></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><a href="Lib.ast.html#dump" class="code" data-type="Function">dump</a></td>
    <td><span class="undocumented">No summary</span></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><a href="Lib.ast.html#copy_location" class="code" data-type="Function">copy_location</a></td>
    <td><span>Copy source location (`lineno`, `col_offset`, `end_lineno`, and `end_col_offset` attributes) from *old_node* to *new_node* if possible, and return *new_node*.</span></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><a href="Lib.ast.html#fix_missing_locations" class="code" data-type="Function">fix_missing_locations</a></td>
    <td><span class="undocumented">No summary</span></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><a href="Lib.ast.html#increment_lineno" class="code" data-type="Function">increment_lineno</a></td>
    <td><span>Increment the line number and end line number of each node in the tree starting at *node* by *n*. This is useful to "move code" to a different location in a file.</span></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><a href="Lib.ast.html#iter_fields" class="code" data-type="Function">iter_fields</a></td>
    <td><span>Yield a tuple of ``(fieldname, value)`` for each field in ``node._fields`` that is present on *node*.</span></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><a href="Lib.ast.html#iter_child_nodes" class="code" data-type="Function">iter_child_nodes</a></td>
    <td><span>Yield all direct child nodes of *node*, that is, all fields that are nodes and all items of fields that are lists of nodes.</span></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><a href="Lib.ast.html#get_docstring" class="code" data-type="Function">get_docstring</a></td>
    <td><span>Return the docstring for the given node or None if no docstring can be found.  If the node provided does not have docstrings a TypeError will be raised.</span></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><a href="Lib.ast.html#get_source_segment" class="code" data-type="Function">get_source_segment</a></td>
    <td><span>Get source code segment of the *source* that generated *node*.</span></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><a href="Lib.ast.html#walk" class="code" data-type="Function">walk</a></td>
    <td><span>Recursively yield all descendant nodes in the tree starting at *node* (including *node* itself), in no specified order.  This is useful if you only want to modify nodes in place and don't care about the context.</span></td>
  </tr><tr class="class">
    
    <td>Class</td>
    <td><a href="Lib.ast.NodeVisitor.html" class="code" data-type="Class">NodeVisitor</a></td>
    <td><span>A node visitor base class that walks the abstract syntax tree and calls a visitor function for every node found.  This function may return a value which is forwarded by the `visit` method.</span></td>
  </tr><tr class="class">
    
    <td>Class</td>
    <td><a href="Lib.ast.NodeTransformer.html" class="code" data-type="Class">NodeTransformer</a></td>
    <td><span>A :class:`NodeVisitor` subclass that walks the abstract syntax tree and allows modification of nodes.</span></td>
  </tr><tr class="class">
    
    <td>Class</td>
    <td><a href="Lib.ast.Num.html" class="code" data-type="Class">Num</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="class">
    
    <td>Class</td>
    <td><a href="Lib.ast.Str.html" class="code" data-type="Class">Str</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="class">
    
    <td>Class</td>
    <td><a href="Lib.ast.Bytes.html" class="code" data-type="Class">Bytes</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="class">
    
    <td>Class</td>
    <td><a href="Lib.ast.NameConstant.html" class="code" data-type="Class">NameConstant</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="class">
    
    <td>Class</td>
    <td><a href="Lib.ast.Ellipsis.html" class="code" data-type="Class">Ellipsis</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="class">
    
    <td>Class</td>
    <td><a href="Lib.ast.slice.html" class="code" data-type="Class">slice</a></td>
    <td><span>Deprecated AST node class.</span></td>
  </tr><tr class="class">
    
    <td>Class</td>
    <td><a href="Lib.ast.Index.html" class="code" data-type="Class">Index</a></td>
    <td><span>Deprecated AST node class. Use the index value directly instead.</span></td>
  </tr><tr class="class">
    
    <td>Class</td>
    <td><a href="Lib.ast.ExtSlice.html" class="code" data-type="Class">ExtSlice</a></td>
    <td><span>Deprecated AST node class. Use ast.Tuple instead.</span></td>
  </tr><tr class="class">
    
    <td>Class</td>
    <td><a href="Lib.ast.Suite.html" class="code" data-type="Class">Suite</a></td>
    <td><span>Deprecated AST node class.  Unused in Python 3.</span></td>
  </tr><tr class="class">
    
    <td>Class</td>
    <td><a href="Lib.ast.AugLoad.html" class="code" data-type="Class">AugLoad</a></td>
    <td><span>Deprecated AST node class.  Unused in Python 3.</span></td>
  </tr><tr class="class">
    
    <td>Class</td>
    <td><a href="Lib.ast.AugStore.html" class="code" data-type="Class">AugStore</a></td>
    <td><span>Deprecated AST node class.  Unused in Python 3.</span></td>
  </tr><tr class="class">
    
    <td>Class</td>
    <td><a href="Lib.ast.Param.html" class="code" data-type="Class">Param</a></td>
    <td><span>Deprecated AST node class.  Unused in Python 3.</span></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><a href="Lib.ast.html#unparse" class="code" data-type="Function">unparse</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><a href="Lib.ast.html#main" class="code" data-type="Function">main</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><a href="Lib.ast.html#_splitlines_no_ff" class="code" data-type="Function">_splitlines_no_ff</a></td>
    <td><span>Split a string into lines ignoring form feed and other chars.</span></td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><a href="Lib.ast.html#_pad_whitespace" class="code" data-type="Function">_pad_whitespace</a></td>
    <td><span>Replace all chars except '\f\t' in a line with spaces.</span></td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><a href="Lib.ast.html#_getter" class="code" data-type="Function">_getter</a></td>
    <td><span>Deprecated. Use value instead.</span></td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><a href="Lib.ast.html#_setter" class="code" data-type="Function">_setter</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="class private">
    
    <td>Class</td>
    <td><a href="Lib.ast._ABC.html" class="code" data-type="Class">_ABC</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><a href="Lib.ast.html#_new" class="code" data-type="Function">_new</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="variable private">
    
    <td>Variable</td>
    <td><a href="Lib.ast.html#_const_types" class="code" data-type="Variable">_const_types</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="variable private">
    
    <td>Variable</td>
    <td><a href="Lib.ast.html#_const_types_not" class="code" data-type="Variable">_const_types_not</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="variable private">
    
    <td>Variable</td>
    <td><a href="Lib.ast.html#_const_node_type_names" class="code" data-type="Variable">_const_node_type_names</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><a href="Lib.ast.html#_dims_getter" class="code" data-type="Function">_dims_getter</a></td>
    <td><span>Deprecated. Use elts instead.</span></td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><a href="Lib.ast.html#_dims_setter" class="code" data-type="Function">_dims_setter</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="variable private">
    
    <td>Variable</td>
    <td><a href="Lib.ast.html#_INFSTR" class="code" data-type="Variable">_INFSTR</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="class private">
    
    <td>Class</td>
    <td><a href="Lib.ast._Precedence.html" class="code" data-type="Class">_Precedence</a></td>
    <td><span>Precedence table that originated from python grammar.</span></td>
  </tr><tr class="variable private">
    
    <td>Variable</td>
    <td><a href="Lib.ast.html#_SINGLE_QUOTES" class="code" data-type="Variable">_SINGLE_QUOTES</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="variable private">
    
    <td>Variable</td>
    <td><a href="Lib.ast.html#_MULTI_QUOTES" class="code" data-type="Variable">_MULTI_QUOTES</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="variable private">
    
    <td>Variable</td>
    <td><a href="Lib.ast.html#_ALL_QUOTES" class="code" data-type="Variable">_ALL_QUOTES</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="class private">
    
    <td>Class</td>
    <td><a href="Lib.ast._Unparser.html" class="code" data-type="Class">_Unparser</a></td>
    <td><span>Methods in this class recursively traverse an AST and output source code for the abstract syntax; original formatting is disregarded.</span></td>
  </tr>
</table>
        

          
      </div>

      <div id="childList">

        <div class="basefunction">
  
  <a name="Lib.ast.parse">
    
  </a>
  <a name="parse">
    
  </a>
  <div class="functionHeader">
    
    def
    parse(source, filename="""&lt;unknown&gt;""", mode="""exec"""):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Parse the source into an AST node.
Equivalent to compile(source, filename, mode, PyCF_ONLY_AST).
Pass type_comments=True to get back type comments where the syntax allows.</p></div>
  </div>
</div><div class="basefunction">
  
  <a name="Lib.ast.literal_eval">
    
  </a>
  <a name="literal_eval">
    
  </a>
  <div class="functionHeader">
    
    def
    literal_eval(node_or_string):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Safely evaluate an expression node or a string containing a Python
expression.  The string or node provided may only consist of the following
Python literal structures: strings, bytes, numbers, tuples, lists, dicts,
sets, booleans, and None.</p></div>
  </div>
</div><div class="basefunction">
  
  <a name="Lib.ast.dump">
    
  </a>
  <a name="dump">
    
  </a>
  <div class="functionHeader">
    
    def
    dump(node, annotate_fields=(True), include_attributes=(False)):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Return a formatted dump of the tree in node.  This is mainly useful for
debugging purposes.  If annotate_fields is true (by default),
the returned string will show the names and the values for fields.
If annotate_fields is false, the result string will be more compact by
omitting unambiguous field names.  Attributes such as line
numbers and column offsets are not dumped by default.  If this is wanted,
include_attributes can be set to true.  If indent is a non-negative
integer or string, then the tree will be pretty-printed with that indent
level. None (the default) selects the single line representation.</p></div>
  </div>
</div><div class="basefunction">
  
  <a name="Lib.ast.copy_location">
    
  </a>
  <a name="copy_location">
    
  </a>
  <div class="functionHeader">
    
    def
    copy_location(new_node, old_node):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Copy source location (`lineno`, `col_offset`, `end_lineno`, and `end_col_offset`
attributes) from *old_node* to *new_node* if possible, and return *new_node*.</p></div>
  </div>
</div><div class="basefunction">
  
  <a name="Lib.ast.fix_missing_locations">
    
  </a>
  <a name="fix_missing_locations">
    
  </a>
  <div class="functionHeader">
    
    def
    fix_missing_locations(node):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">When you compile a node tree with compile(), the compiler expects lineno and
col_offset attributes for every node that supports them.  This is rather
tedious to fill in for generated nodes, so this helper adds these attributes
recursively where not already set, by setting them to the values of the
parent node.  It works recursively starting at *node*.</p></div>
  </div>
</div><div class="basefunction">
  
  <a name="Lib.ast.increment_lineno">
    
  </a>
  <a name="increment_lineno">
    
  </a>
  <div class="functionHeader">
    
    def
    increment_lineno(node, n=1):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Increment the line number and end line number of each node in the tree
starting at *node* by *n*. This is useful to "move code" to a different
location in a file.</p></div>
  </div>
</div><div class="basefunction">
  
  <a name="Lib.ast.iter_fields">
    
  </a>
  <a name="iter_fields">
    
  </a>
  <div class="functionHeader">
    
    def
    iter_fields(node):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Yield a tuple of ``(fieldname, value)`` for each field in ``node._fields``
that is present on *node*.</p></div>
  </div>
</div><div class="basefunction">
  
  <a name="Lib.ast.iter_child_nodes">
    
  </a>
  <a name="iter_child_nodes">
    
  </a>
  <div class="functionHeader">
    
    def
    iter_child_nodes(node):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Yield all direct child nodes of *node*, that is, all fields that are nodes
and all items of fields that are lists of nodes.</p></div>
  </div>
</div><div class="basefunction">
  
  <a name="Lib.ast.get_docstring">
    
  </a>
  <a name="get_docstring">
    
  </a>
  <div class="functionHeader">
    
    def
    get_docstring(node, clean=(True)):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Return the docstring for the given node or None if no docstring can
be found.  If the node provided does not have docstrings a TypeError
will be raised.

If *clean* is `True`, all tabs are expanded to spaces and any whitespace
that can be uniformly removed from the second line onwards is removed.</p></div>
  </div>
</div><div class="basefunction private">
  
  <a name="Lib.ast._splitlines_no_ff">
    
  </a>
  <a name="_splitlines_no_ff">
    
  </a>
  <div class="functionHeader">
    
    def
    _splitlines_no_ff(source):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Split a string into lines ignoring form feed and other chars.

This mimics how the Python parser splits source code.</p></div>
  </div>
</div><div class="basefunction private">
  
  <a name="Lib.ast._pad_whitespace">
    
  </a>
  <a name="_pad_whitespace">
    
  </a>
  <div class="functionHeader">
    
    def
    _pad_whitespace(source):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Replace all chars except '\f\t' in a line with spaces.</p></div>
  </div>
</div><div class="basefunction">
  
  <a name="Lib.ast.get_source_segment">
    
  </a>
  <a name="get_source_segment">
    
  </a>
  <div class="functionHeader">
    
    def
    get_source_segment(source, node):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Get source code segment of the *source* that generated *node*.

If some location information (`lineno`, `end_lineno`, `col_offset`,
or `end_col_offset`) is missing, return None.

If *padded* is `True`, the first line of a multi-line statement will
be padded with spaces to match its original position.</p></div>
  </div>
</div><div class="basefunction">
  
  <a name="Lib.ast.walk">
    
  </a>
  <a name="walk">
    
  </a>
  <div class="functionHeader">
    
    def
    walk(node):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Recursively yield all descendant nodes in the tree starting at *node*
(including *node* itself), in no specified order.  This is useful if you
only want to modify nodes in place and don't care about the context.</p></div>
  </div>
</div><div class="basefunction private">
  
  <a name="Lib.ast._getter">
    
  </a>
  <a name="_getter">
    
  </a>
  <div class="functionHeader">
    
    def
    _getter(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Deprecated. Use value instead.</p></div>
  </div>
</div><div class="basefunction private">
  
  <a name="Lib.ast._setter">
    
  </a>
  <a name="_setter">
    
  </a>
  <div class="functionHeader">
    
    def
    _setter(self, value):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basefunction private">
  
  <a name="Lib.ast._new">
    
  </a>
  <a name="_new">
    
  </a>
  <div class="functionHeader">
    
    def
    _new(cls, *args, **kwargs):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basevariable private">
  
  <a name="Lib.ast._const_types">
    
  </a>
  <a name="_const_types">
    
  </a>
  <div class="functionHeader">
    _const_types =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basevariable private">
  
  <a name="Lib.ast._const_types_not">
    
  </a>
  <a name="_const_types_not">
    
  </a>
  <div class="functionHeader">
    _const_types_not =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basevariable private">
  
  <a name="Lib.ast._const_node_type_names">
    
  </a>
  <a name="_const_node_type_names">
    
  </a>
  <div class="functionHeader">
    _const_node_type_names =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basefunction private">
  
  <a name="Lib.ast._dims_getter">
    
  </a>
  <a name="_dims_getter">
    
  </a>
  <div class="functionHeader">
    
    def
    _dims_getter(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Deprecated. Use elts instead.</p></div>
  </div>
</div><div class="basefunction private">
  
  <a name="Lib.ast._dims_setter">
    
  </a>
  <a name="_dims_setter">
    
  </a>
  <div class="functionHeader">
    
    def
    _dims_setter(self, value):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basevariable private">
  
  <a name="Lib.ast._INFSTR">
    
  </a>
  <a name="_INFSTR">
    
  </a>
  <div class="functionHeader">
    _INFSTR =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basevariable private">
  
  <a name="Lib.ast._SINGLE_QUOTES">
    
  </a>
  <a name="_SINGLE_QUOTES">
    
  </a>
  <div class="functionHeader">
    _SINGLE_QUOTES =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div> (type: <code>Tuple[str, ...]</code>)
  </div>
</div><div class="basevariable private">
  
  <a name="Lib.ast._MULTI_QUOTES">
    
  </a>
  <a name="_MULTI_QUOTES">
    
  </a>
  <div class="functionHeader">
    _MULTI_QUOTES =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div> (type: <code>Tuple[str, ...]</code>)
  </div>
</div><div class="basevariable private">
  
  <a name="Lib.ast._ALL_QUOTES">
    
  </a>
  <a name="_ALL_QUOTES">
    
  </a>
  <div class="functionHeader">
    _ALL_QUOTES =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basefunction">
  
  <a name="Lib.ast.unparse">
    
  </a>
  <a name="unparse">
    
  </a>
  <div class="functionHeader">
    
    def
    unparse(ast_obj):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basefunction">
  
  <a name="Lib.ast.main">
    
  </a>
  <a name="main">
    
  </a>
  <div class="functionHeader">
    
    def
    main():
    
  </div>
  <div class="docstring functionBody">
    
    
    <div class="undocumented">Undocumented</div>
  </div>
</div>

      </div>
      <address>
        <a href="index.html">API Documentation</a> for Python3.8, generated by <a href="https://github.com/twisted/pydoctor/">pydoctor</a> 20.7.1 at 2020-11-24 05:02:55.
      </address>

    </div>

    <script src="pydoctor.js" type="text/javascript"></script>

  </body>
</html>