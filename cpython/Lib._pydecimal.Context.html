<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
          "DTD/xhtml1-strict.dtd">
<html>
  <head>
    <title>Lib._pydecimal.Context : API documentation</title>

    <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
    <link rel="stylesheet" type="text/css" href="bootstrap.min.css" />
    <link rel="stylesheet" type="text/css" href="apidocs.css" />
  </head>
  <body>

    <nav class="navbar navbar-default">
      <div class="container">
        <div class="navbar-header">
          <a class="navbar-brand" href="index.html">
            Python3.8 API Documentation
          </a>
        </div>
      </div>
    </nav>

    <div id="showPrivate">
      <button class="btn btn-link" onclick="togglePrivate()">Toggle Private API</button>
    </div>

    <div class="container">

      <div class="page-header">
        <h1 class="class"><code><a href="Lib.html" class="code" data-type="Package">Lib</a>.<a href="Lib._pydecimal.html" class="code" data-type="Module">_pydecimal</a>.<a href="Lib._pydecimal.Context.html" class="code" data-type="Class">Context</a></code></h1>
      </div>

      <div class="categoryHeader">
        class documentation
      </div>

      <div class="extrasDocstring">
        <p><code><span class="py-keyword">class</span> Lib._pydecimal.Context(<span title="object">object</span>):</code></p>
        <p><a href="classIndex.html#Lib._pydecimal.Context">View In Hierarchy</a></p>
      </div>

      <div class="moduleDocstring">
        <div><p class="pre">Contains the context for a Decimal instance.

Contains:
prec - precision (for use in rounding, division, square roots..)
rounding - rounding type (how you round)
traps - If traps[exception] = 1, then the exception is
                raised when it is caused.  Otherwise, a value is
                substituted in.
flags  - When an exception is caused, flags[exception] is set.
         (Whether or not the trap_enabler is set)
         Should be reset by user of Decimal instance.
Emin -   Minimum exponent
Emax -   Maximum exponent
capitals -      If 1, 1*10^1 is printed as 1E+1.
                If 0, printed as 1e1
clamp -  If 1, change exponents if too high (Default 0)</p></div>
      </div>

      <div id="splitTables">
        <table class="children sortable" id="id131">
  
  <tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Context.html#__init__" class="code" data-type="Method">__init__</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="instancevariable">
    
    <td>Instance Variable</td>
    <td><a href="Lib._pydecimal.Context.html#prec" class="code" data-type="Instance Variable">prec</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="instancevariable">
    
    <td>Instance Variable</td>
    <td><a href="Lib._pydecimal.Context.html#rounding" class="code" data-type="Instance Variable">rounding</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="instancevariable">
    
    <td>Instance Variable</td>
    <td><a href="Lib._pydecimal.Context.html#Emin" class="code" data-type="Instance Variable">Emin</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="instancevariable">
    
    <td>Instance Variable</td>
    <td><a href="Lib._pydecimal.Context.html#Emax" class="code" data-type="Instance Variable">Emax</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="instancevariable">
    
    <td>Instance Variable</td>
    <td><a href="Lib._pydecimal.Context.html#capitals" class="code" data-type="Instance Variable">capitals</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="instancevariable">
    
    <td>Instance Variable</td>
    <td><a href="Lib._pydecimal.Context.html#clamp" class="code" data-type="Instance Variable">clamp</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="instancevariable">
    
    <td>Instance Variable</td>
    <td><a href="Lib._pydecimal.Context.html#traps" class="code" data-type="Instance Variable">traps</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="instancevariable">
    
    <td>Instance Variable</td>
    <td><a href="Lib._pydecimal.Context.html#flags" class="code" data-type="Instance Variable">flags</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Context.html#__setattr__" class="code" data-type="Method">__setattr__</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Context.html#__delattr__" class="code" data-type="Method">__delattr__</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Context.html#__reduce__" class="code" data-type="Method">__reduce__</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Context.html#__repr__" class="code" data-type="Method">__repr__</a></td>
    <td><span>Show the current context.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Context.html#clear_flags" class="code" data-type="Method">clear_flags</a></td>
    <td><span>Reset all flags to zero</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Context.html#clear_traps" class="code" data-type="Method">clear_traps</a></td>
    <td><span>Reset all traps to zero</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Context.html#copy" class="code" data-type="Method">copy</a></td>
    <td><span>Returns a deep copy from self.</span></td>
  </tr><tr class="classvariable">
    
    <td>Class Variable</td>
    <td><a href="Lib._pydecimal.Context.html#__hash__" class="code" data-type="Class Variable">__hash__</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Context.html#Etiny" class="code" data-type="Method">Etiny</a></td>
    <td><span>Returns Etiny (= Emin - prec + 1)</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Context.html#Etop" class="code" data-type="Method">Etop</a></td>
    <td><span>Returns maximum exponent (= Emax - prec + 1)</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Context.html#create_decimal" class="code" data-type="Method">create_decimal</a></td>
    <td><span>Creates a new Decimal instance but using self as context.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Context.html#create_decimal_from_float" class="code" data-type="Method">create_decimal_from_float</a></td>
    <td><span>Creates a new Decimal instance from a float but rounding using self as the context.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Context.html#abs" class="code" data-type="Method">abs</a></td>
    <td><span>Returns the absolute value of the operand.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Context.html#add" class="code" data-type="Method">add</a></td>
    <td><span>Return the sum of the two operands.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Context.html#canonical" class="code" data-type="Method">canonical</a></td>
    <td><span>Returns the same Decimal object.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Context.html#compare" class="code" data-type="Method">compare</a></td>
    <td><span>Compares values numerically.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Context.html#compare_signal" class="code" data-type="Method">compare_signal</a></td>
    <td><span>Compares the values of the two operands numerically.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Context.html#compare_total" class="code" data-type="Method">compare_total</a></td>
    <td><span>Compares two operands using their abstract representation.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Context.html#compare_total_mag" class="code" data-type="Method">compare_total_mag</a></td>
    <td><span>Compares two operands using their abstract representation ignoring sign.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Context.html#copy_abs" class="code" data-type="Method">copy_abs</a></td>
    <td><span>Returns a copy of the operand with the sign set to 0.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Context.html#copy_decimal" class="code" data-type="Method">copy_decimal</a></td>
    <td><span>Returns a copy of the decimal object.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Context.html#copy_negate" class="code" data-type="Method">copy_negate</a></td>
    <td><span>Returns a copy of the operand with the sign inverted.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Context.html#copy_sign" class="code" data-type="Method">copy_sign</a></td>
    <td><span>Copies the second operand's sign to the first one.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Context.html#divide" class="code" data-type="Method">divide</a></td>
    <td><span>Decimal division in a specified context.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Context.html#divide_int" class="code" data-type="Method">divide_int</a></td>
    <td><span>Divides two numbers and returns the integer part of the result.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Context.html#divmod" class="code" data-type="Method">divmod</a></td>
    <td><span>Return (a // b, a % b).</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Context.html#exp" class="code" data-type="Method">exp</a></td>
    <td><span>Returns e ** a.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Context.html#fma" class="code" data-type="Method">fma</a></td>
    <td><span>Returns a multiplied by b, plus c.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Context.html#is_canonical" class="code" data-type="Method">is_canonical</a></td>
    <td><span>Return True if the operand is canonical; otherwise return False.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Context.html#is_finite" class="code" data-type="Method">is_finite</a></td>
    <td><span>Return True if the operand is finite; otherwise return False.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Context.html#is_infinite" class="code" data-type="Method">is_infinite</a></td>
    <td><span>Return True if the operand is infinite; otherwise return False.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Context.html#is_nan" class="code" data-type="Method">is_nan</a></td>
    <td><span>Return True if the operand is a qNaN or sNaN; otherwise return False.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Context.html#is_normal" class="code" data-type="Method">is_normal</a></td>
    <td><span>Return True if the operand is a normal number; otherwise return False.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Context.html#is_qnan" class="code" data-type="Method">is_qnan</a></td>
    <td><span>Return True if the operand is a quiet NaN; otherwise return False.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Context.html#is_signed" class="code" data-type="Method">is_signed</a></td>
    <td><span>Return True if the operand is negative; otherwise return False.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Context.html#is_snan" class="code" data-type="Method">is_snan</a></td>
    <td><span>Return True if the operand is a signaling NaN; otherwise return False.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Context.html#is_subnormal" class="code" data-type="Method">is_subnormal</a></td>
    <td><span>Return True if the operand is subnormal; otherwise return False.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Context.html#is_zero" class="code" data-type="Method">is_zero</a></td>
    <td><span>Return True if the operand is a zero; otherwise return False.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Context.html#ln" class="code" data-type="Method">ln</a></td>
    <td><span>Returns the natural (base e) logarithm of the operand.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Context.html#log10" class="code" data-type="Method">log10</a></td>
    <td><span>Returns the base 10 logarithm of the operand.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Context.html#logb" class="code" data-type="Method">logb</a></td>
    <td><span>Returns the exponent of the magnitude of the operand's MSD.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Context.html#logical_and" class="code" data-type="Method">logical_and</a></td>
    <td><span>Applies the logical operation 'and' between each operand's digits.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Context.html#logical_invert" class="code" data-type="Method">logical_invert</a></td>
    <td><span>Invert all the digits in the operand.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Context.html#logical_or" class="code" data-type="Method">logical_or</a></td>
    <td><span>Applies the logical operation 'or' between each operand's digits.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Context.html#logical_xor" class="code" data-type="Method">logical_xor</a></td>
    <td><span>Applies the logical operation 'xor' between each operand's digits.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Context.html#max" class="code" data-type="Method">max</a></td>
    <td><span>max compares two values numerically and returns the maximum.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Context.html#max_mag" class="code" data-type="Method">max_mag</a></td>
    <td><span>Compares the values numerically with their sign ignored.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Context.html#min" class="code" data-type="Method">min</a></td>
    <td><span>min compares two values numerically and returns the minimum.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Context.html#min_mag" class="code" data-type="Method">min_mag</a></td>
    <td><span>Compares the values numerically with their sign ignored.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Context.html#minus" class="code" data-type="Method">minus</a></td>
    <td><span>Minus corresponds to unary prefix minus in Python.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Context.html#multiply" class="code" data-type="Method">multiply</a></td>
    <td><span>multiply multiplies two operands.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Context.html#next_minus" class="code" data-type="Method">next_minus</a></td>
    <td><span>Returns the largest representable number smaller than a.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Context.html#next_plus" class="code" data-type="Method">next_plus</a></td>
    <td><span>Returns the smallest representable number larger than a.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Context.html#next_toward" class="code" data-type="Method">next_toward</a></td>
    <td><span>Returns the number closest to a, in direction towards b.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Context.html#normalize" class="code" data-type="Method">normalize</a></td>
    <td><span>normalize reduces an operand to its simplest form.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Context.html#number_class" class="code" data-type="Method">number_class</a></td>
    <td><span>Returns an indication of the class of the operand.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Context.html#plus" class="code" data-type="Method">plus</a></td>
    <td><span>Plus corresponds to unary prefix plus in Python.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Context.html#power" class="code" data-type="Method">power</a></td>
    <td><span>Raises a to the power of b, to modulo if given.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Context.html#quantize" class="code" data-type="Method">quantize</a></td>
    <td><span>Returns a value equal to 'a' (rounded), having the exponent of 'b'.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Context.html#radix" class="code" data-type="Method">radix</a></td>
    <td><span>Just returns 10, as this is Decimal, :)</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Context.html#remainder" class="code" data-type="Method">remainder</a></td>
    <td><span>Returns the remainder from integer division.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Context.html#remainder_near" class="code" data-type="Method">remainder_near</a></td>
    <td><span class="undocumented">No summary</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Context.html#rotate" class="code" data-type="Method">rotate</a></td>
    <td><span>Returns a rotated copy of a, b times.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Context.html#same_quantum" class="code" data-type="Method">same_quantum</a></td>
    <td><span>Returns True if the two operands have the same exponent.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Context.html#scaleb" class="code" data-type="Method">scaleb</a></td>
    <td><span>Returns the first operand after adding the second value its exp.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Context.html#shift" class="code" data-type="Method">shift</a></td>
    <td><span>Returns a shifted copy of a, b times.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Context.html#sqrt" class="code" data-type="Method">sqrt</a></td>
    <td><span>Square root of a non-negative number to context precision.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Context.html#subtract" class="code" data-type="Method">subtract</a></td>
    <td><span>Return the difference between the two operands.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Context.html#to_eng_string" class="code" data-type="Method">to_eng_string</a></td>
    <td><span>Convert to a string, using engineering notation if an exponent is needed.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Context.html#to_sci_string" class="code" data-type="Method">to_sci_string</a></td>
    <td><span>Converts a number to a string, using scientific notation.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Context.html#to_integral_exact" class="code" data-type="Method">to_integral_exact</a></td>
    <td><span>Rounds to an integer.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Context.html#to_integral_value" class="code" data-type="Method">to_integral_value</a></td>
    <td><span>Rounds to an integer.</span></td>
  </tr><tr class="instancevariable private">
    
    <td>Instance Variable</td>
    <td><a href="Lib._pydecimal.Context.html#_ignored_flags" class="code" data-type="Instance Variable">_ignored_flags</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Context.html#_set_integer_check" class="code" data-type="Method">_set_integer_check</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Context.html#_set_signal_dict" class="code" data-type="Method">_set_signal_dict</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Context.html#_shallow_copy" class="code" data-type="Method">_shallow_copy</a></td>
    <td><span>Returns a shallow copy from self.</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Context.html#_raise_error" class="code" data-type="Method">_raise_error</a></td>
    <td><span>Handles an error</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Context.html#_ignore_all_flags" class="code" data-type="Method">_ignore_all_flags</a></td>
    <td><span>Ignore all flags, if they are raised</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Context.html#_ignore_flags" class="code" data-type="Method">_ignore_flags</a></td>
    <td><span>Ignore the flags, if they are raised</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Context.html#_regard_flags" class="code" data-type="Method">_regard_flags</a></td>
    <td><span>Stop ignoring the flags, if they are raised</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Context.html#_set_rounding" class="code" data-type="Method">_set_rounding</a></td>
    <td><span>Sets the rounding type.</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><a href="Lib._pydecimal.Context.html#_apply" class="code" data-type="Method">_apply</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr>
</table>
        

          
      </div>

      <div id="childList">

        <div class="basemethod">
  
  <a name="Lib._pydecimal.Context.__init__">
    
  </a>
  <a name="__init__">
    
  </a>
  <div class="functionHeader">
    
    def
    __init__(self, prec=None, rounding=None, Emin=None, Emax=None, capitals=None, clamp=None, flags=None, traps=None, _ignored_flags=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="baseinstancevariable">
  
  <a name="Lib._pydecimal.Context.prec">
    
  </a>
  <a name="prec">
    
  </a>
  <div class="functionHeader">
    prec =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="baseinstancevariable">
  
  <a name="Lib._pydecimal.Context.rounding">
    
  </a>
  <a name="rounding">
    
  </a>
  <div class="functionHeader">
    rounding =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="baseinstancevariable">
  
  <a name="Lib._pydecimal.Context.Emin">
    
  </a>
  <a name="Emin">
    
  </a>
  <div class="functionHeader">
    Emin =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="baseinstancevariable">
  
  <a name="Lib._pydecimal.Context.Emax">
    
  </a>
  <a name="Emax">
    
  </a>
  <div class="functionHeader">
    Emax =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="baseinstancevariable">
  
  <a name="Lib._pydecimal.Context.capitals">
    
  </a>
  <a name="capitals">
    
  </a>
  <div class="functionHeader">
    capitals =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="baseinstancevariable">
  
  <a name="Lib._pydecimal.Context.clamp">
    
  </a>
  <a name="clamp">
    
  </a>
  <div class="functionHeader">
    clamp =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="baseinstancevariable private">
  
  <a name="Lib._pydecimal.Context._ignored_flags">
    
  </a>
  <a name="_ignored_flags">
    
  </a>
  <div class="functionHeader">
    _ignored_flags =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="baseinstancevariable">
  
  <a name="Lib._pydecimal.Context.traps">
    
  </a>
  <a name="traps">
    
  </a>
  <div class="functionHeader">
    traps =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="baseinstancevariable">
  
  <a name="Lib._pydecimal.Context.flags">
    
  </a>
  <a name="flags">
    
  </a>
  <div class="functionHeader">
    flags =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basemethod private">
  
  <a name="Lib._pydecimal.Context._set_integer_check">
    
  </a>
  <a name="_set_integer_check">
    
  </a>
  <div class="functionHeader">
    
    def
    _set_integer_check(self, name, value, vmin, vmax):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basemethod private">
  
  <a name="Lib._pydecimal.Context._set_signal_dict">
    
  </a>
  <a name="_set_signal_dict">
    
  </a>
  <div class="functionHeader">
    
    def
    _set_signal_dict(self, name, d):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Context.__setattr__">
    
  </a>
  <a name="__setattr__">
    
  </a>
  <div class="functionHeader">
    
    def
    __setattr__(self, name, value):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Context.__delattr__">
    
  </a>
  <a name="__delattr__">
    
  </a>
  <div class="functionHeader">
    
    def
    __delattr__(self, name):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Context.__reduce__">
    
  </a>
  <a name="__reduce__">
    
  </a>
  <div class="functionHeader">
    
    def
    __reduce__(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Context.__repr__">
    
  </a>
  <a name="__repr__">
    
  </a>
  <div class="functionHeader">
    
    def
    __repr__(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Show the current context.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Context.clear_flags">
    
  </a>
  <a name="clear_flags">
    
  </a>
  <div class="functionHeader">
    
    def
    clear_flags(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Reset all flags to zero</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Context.clear_traps">
    
  </a>
  <a name="clear_traps">
    
  </a>
  <div class="functionHeader">
    
    def
    clear_traps(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Reset all traps to zero</p></div>
  </div>
</div><div class="basemethod private">
  
  <a name="Lib._pydecimal.Context._shallow_copy">
    
  </a>
  <a name="_shallow_copy">
    
  </a>
  <div class="functionHeader">
    
    def
    _shallow_copy(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Returns a shallow copy from self.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Context.copy">
    
  </a>
  <a name="copy">
    
  </a>
  <div class="functionHeader">
    
    def
    copy(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Returns a deep copy from self.</p></div>
  </div>
</div><div class="basemethod private">
  
  <a name="Lib._pydecimal.Context._raise_error">
    
  </a>
  <a name="_raise_error">
    
  </a>
  <div class="functionHeader">
    
    def
    _raise_error(self, condition, *args, explanation=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Handles an error

If the flag is in _ignored_flags, returns the default response.
Otherwise, it sets the flag, then, if the corresponding
trap_enabler is set, it reraises the exception.  Otherwise, it returns
the default value after setting the flag.</p></div>
  </div>
</div><div class="basemethod private">
  
  <a name="Lib._pydecimal.Context._ignore_all_flags">
    
  </a>
  <a name="_ignore_all_flags">
    
  </a>
  <div class="functionHeader">
    
    def
    _ignore_all_flags(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Ignore all flags, if they are raised</p></div>
  </div>
</div><div class="basemethod private">
  
  <a name="Lib._pydecimal.Context._ignore_flags">
    
  </a>
  <a name="_ignore_flags">
    
  </a>
  <div class="functionHeader">
    
    def
    _ignore_flags(self, *flags):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Ignore the flags, if they are raised</p></div>
  </div>
</div><div class="basemethod private">
  
  <a name="Lib._pydecimal.Context._regard_flags">
    
  </a>
  <a name="_regard_flags">
    
  </a>
  <div class="functionHeader">
    
    def
    _regard_flags(self, *flags):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Stop ignoring the flags, if they are raised</p></div>
  </div>
</div><div class="baseclassvariable">
  
  <a name="Lib._pydecimal.Context.__hash__">
    
  </a>
  <a name="__hash__">
    
  </a>
  <div class="functionHeader">
    __hash__ =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Context.Etiny">
    
  </a>
  <a name="Etiny">
    
  </a>
  <div class="functionHeader">
    
    def
    Etiny(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Returns Etiny (= Emin - prec + 1)</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Context.Etop">
    
  </a>
  <a name="Etop">
    
  </a>
  <div class="functionHeader">
    
    def
    Etop(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Returns maximum exponent (= Emax - prec + 1)</p></div>
  </div>
</div><div class="basemethod private">
  
  <a name="Lib._pydecimal.Context._set_rounding">
    
  </a>
  <a name="_set_rounding">
    
  </a>
  <div class="functionHeader">
    
    def
    _set_rounding(self, type):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Sets the rounding type.

Sets the rounding type, and returns the current (previous)
rounding type.  Often used like:

context = context.copy()
# so you don't change the calling context
# if an error occurs in the middle.
rounding = context._set_rounding(ROUND_UP)
val = self.__sub__(other, context=context)
context._set_rounding(rounding)

This will make it round up for that operation.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Context.create_decimal">
    
  </a>
  <a name="create_decimal">
    
  </a>
  <div class="functionHeader">
    
    def
    create_decimal(self, num="""0"""):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Creates a new Decimal instance but using self as context.

This method implements the to-number operation of the
IBM Decimal specification.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Context.create_decimal_from_float">
    
  </a>
  <a name="create_decimal_from_float">
    
  </a>
  <div class="functionHeader">
    
    def
    create_decimal_from_float(self, f):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Creates a new Decimal instance from a float but rounding using self
as the context.

&gt;&gt;&gt; context = Context(prec=5, rounding=ROUND_DOWN)
&gt;&gt;&gt; context.create_decimal_from_float(3.1415926535897932)
Decimal('3.1415')
&gt;&gt;&gt; context = Context(prec=5, traps=[Inexact])
&gt;&gt;&gt; context.create_decimal_from_float(3.1415926535897932)
Traceback (most recent call last):
    ...
decimal.Inexact: None</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Context.abs">
    
  </a>
  <a name="abs">
    
  </a>
  <div class="functionHeader">
    
    def
    abs(self, a):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Returns the absolute value of the operand.

If the operand is negative, the result is the same as using the minus
operation on the operand.  Otherwise, the result is the same as using
the plus operation on the operand.

&gt;&gt;&gt; ExtendedContext.abs(Decimal('2.1'))
Decimal('2.1')
&gt;&gt;&gt; ExtendedContext.abs(Decimal('-100'))
Decimal('100')
&gt;&gt;&gt; ExtendedContext.abs(Decimal('101.5'))
Decimal('101.5')
&gt;&gt;&gt; ExtendedContext.abs(Decimal('-101.5'))
Decimal('101.5')
&gt;&gt;&gt; ExtendedContext.abs(-1)
Decimal('1')</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Context.add">
    
  </a>
  <a name="add">
    
  </a>
  <div class="functionHeader">
    
    def
    add(self, a, b):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Return the sum of the two operands.

&gt;&gt;&gt; ExtendedContext.add(Decimal('12'), Decimal('7.00'))
Decimal('19.00')
&gt;&gt;&gt; ExtendedContext.add(Decimal('1E+2'), Decimal('1.01E+4'))
Decimal('1.02E+4')
&gt;&gt;&gt; ExtendedContext.add(1, Decimal(2))
Decimal('3')
&gt;&gt;&gt; ExtendedContext.add(Decimal(8), 5)
Decimal('13')
&gt;&gt;&gt; ExtendedContext.add(5, 5)
Decimal('10')</p></div>
  </div>
</div><div class="basemethod private">
  
  <a name="Lib._pydecimal.Context._apply">
    
  </a>
  <a name="_apply">
    
  </a>
  <div class="functionHeader">
    
    def
    _apply(self, a):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Context.canonical">
    
  </a>
  <a name="canonical">
    
  </a>
  <div class="functionHeader">
    
    def
    canonical(self, a):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Returns the same Decimal object.

As we do not have different encodings for the same number, the
received object already is in its canonical form.

&gt;&gt;&gt; ExtendedContext.canonical(Decimal('2.50'))
Decimal('2.50')</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Context.compare">
    
  </a>
  <a name="compare">
    
  </a>
  <div class="functionHeader">
    
    def
    compare(self, a, b):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Compares values numerically.

If the signs of the operands differ, a value representing each operand
('-1' if the operand is less than zero, '0' if the operand is zero or
negative zero, or '1' if the operand is greater than zero) is used in
place of that operand for the comparison instead of the actual
operand.

The comparison is then effected by subtracting the second operand from
the first and then returning a value according to the result of the
subtraction: '-1' if the result is less than zero, '0' if the result is
zero or negative zero, or '1' if the result is greater than zero.

&gt;&gt;&gt; ExtendedContext.compare(Decimal('2.1'), Decimal('3'))
Decimal('-1')
&gt;&gt;&gt; ExtendedContext.compare(Decimal('2.1'), Decimal('2.1'))
Decimal('0')
&gt;&gt;&gt; ExtendedContext.compare(Decimal('2.1'), Decimal('2.10'))
Decimal('0')
&gt;&gt;&gt; ExtendedContext.compare(Decimal('3'), Decimal('2.1'))
Decimal('1')
&gt;&gt;&gt; ExtendedContext.compare(Decimal('2.1'), Decimal('-3'))
Decimal('1')
&gt;&gt;&gt; ExtendedContext.compare(Decimal('-3'), Decimal('2.1'))
Decimal('-1')
&gt;&gt;&gt; ExtendedContext.compare(1, 2)
Decimal('-1')
&gt;&gt;&gt; ExtendedContext.compare(Decimal(1), 2)
Decimal('-1')
&gt;&gt;&gt; ExtendedContext.compare(1, Decimal(2))
Decimal('-1')</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Context.compare_signal">
    
  </a>
  <a name="compare_signal">
    
  </a>
  <div class="functionHeader">
    
    def
    compare_signal(self, a, b):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Compares the values of the two operands numerically.

It's pretty much like compare(), but all NaNs signal, with signaling
NaNs taking precedence over quiet NaNs.

&gt;&gt;&gt; c = ExtendedContext
&gt;&gt;&gt; c.compare_signal(Decimal('2.1'), Decimal('3'))
Decimal('-1')
&gt;&gt;&gt; c.compare_signal(Decimal('2.1'), Decimal('2.1'))
Decimal('0')
&gt;&gt;&gt; c.flags[InvalidOperation] = 0
&gt;&gt;&gt; print(c.flags[InvalidOperation])
0
&gt;&gt;&gt; c.compare_signal(Decimal('NaN'), Decimal('2.1'))
Decimal('NaN')
&gt;&gt;&gt; print(c.flags[InvalidOperation])
1
&gt;&gt;&gt; c.flags[InvalidOperation] = 0
&gt;&gt;&gt; print(c.flags[InvalidOperation])
0
&gt;&gt;&gt; c.compare_signal(Decimal('sNaN'), Decimal('2.1'))
Decimal('NaN')
&gt;&gt;&gt; print(c.flags[InvalidOperation])
1
&gt;&gt;&gt; c.compare_signal(-1, 2)
Decimal('-1')
&gt;&gt;&gt; c.compare_signal(Decimal(-1), 2)
Decimal('-1')
&gt;&gt;&gt; c.compare_signal(-1, Decimal(2))
Decimal('-1')</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Context.compare_total">
    
  </a>
  <a name="compare_total">
    
  </a>
  <div class="functionHeader">
    
    def
    compare_total(self, a, b):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Compares two operands using their abstract representation.

This is not like the standard compare, which use their numerical
value. Note that a total ordering is defined for all possible abstract
representations.

&gt;&gt;&gt; ExtendedContext.compare_total(Decimal('12.73'), Decimal('127.9'))
Decimal('-1')
&gt;&gt;&gt; ExtendedContext.compare_total(Decimal('-127'),  Decimal('12'))
Decimal('-1')
&gt;&gt;&gt; ExtendedContext.compare_total(Decimal('12.30'), Decimal('12.3'))
Decimal('-1')
&gt;&gt;&gt; ExtendedContext.compare_total(Decimal('12.30'), Decimal('12.30'))
Decimal('0')
&gt;&gt;&gt; ExtendedContext.compare_total(Decimal('12.3'),  Decimal('12.300'))
Decimal('1')
&gt;&gt;&gt; ExtendedContext.compare_total(Decimal('12.3'),  Decimal('NaN'))
Decimal('-1')
&gt;&gt;&gt; ExtendedContext.compare_total(1, 2)
Decimal('-1')
&gt;&gt;&gt; ExtendedContext.compare_total(Decimal(1), 2)
Decimal('-1')
&gt;&gt;&gt; ExtendedContext.compare_total(1, Decimal(2))
Decimal('-1')</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Context.compare_total_mag">
    
  </a>
  <a name="compare_total_mag">
    
  </a>
  <div class="functionHeader">
    
    def
    compare_total_mag(self, a, b):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Compares two operands using their abstract representation ignoring sign.

Like compare_total, but with operand's sign ignored and assumed to be 0.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Context.copy_abs">
    
  </a>
  <a name="copy_abs">
    
  </a>
  <div class="functionHeader">
    
    def
    copy_abs(self, a):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Returns a copy of the operand with the sign set to 0.

&gt;&gt;&gt; ExtendedContext.copy_abs(Decimal('2.1'))
Decimal('2.1')
&gt;&gt;&gt; ExtendedContext.copy_abs(Decimal('-100'))
Decimal('100')
&gt;&gt;&gt; ExtendedContext.copy_abs(-1)
Decimal('1')</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Context.copy_decimal">
    
  </a>
  <a name="copy_decimal">
    
  </a>
  <div class="functionHeader">
    
    def
    copy_decimal(self, a):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Returns a copy of the decimal object.

&gt;&gt;&gt; ExtendedContext.copy_decimal(Decimal('2.1'))
Decimal('2.1')
&gt;&gt;&gt; ExtendedContext.copy_decimal(Decimal('-1.00'))
Decimal('-1.00')
&gt;&gt;&gt; ExtendedContext.copy_decimal(1)
Decimal('1')</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Context.copy_negate">
    
  </a>
  <a name="copy_negate">
    
  </a>
  <div class="functionHeader">
    
    def
    copy_negate(self, a):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Returns a copy of the operand with the sign inverted.

&gt;&gt;&gt; ExtendedContext.copy_negate(Decimal('101.5'))
Decimal('-101.5')
&gt;&gt;&gt; ExtendedContext.copy_negate(Decimal('-101.5'))
Decimal('101.5')
&gt;&gt;&gt; ExtendedContext.copy_negate(1)
Decimal('-1')</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Context.copy_sign">
    
  </a>
  <a name="copy_sign">
    
  </a>
  <div class="functionHeader">
    
    def
    copy_sign(self, a, b):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Copies the second operand's sign to the first one.

In detail, it returns a copy of the first operand with the sign
equal to the sign of the second operand.

&gt;&gt;&gt; ExtendedContext.copy_sign(Decimal( '1.50'), Decimal('7.33'))
Decimal('1.50')
&gt;&gt;&gt; ExtendedContext.copy_sign(Decimal('-1.50'), Decimal('7.33'))
Decimal('1.50')
&gt;&gt;&gt; ExtendedContext.copy_sign(Decimal( '1.50'), Decimal('-7.33'))
Decimal('-1.50')
&gt;&gt;&gt; ExtendedContext.copy_sign(Decimal('-1.50'), Decimal('-7.33'))
Decimal('-1.50')
&gt;&gt;&gt; ExtendedContext.copy_sign(1, -2)
Decimal('-1')
&gt;&gt;&gt; ExtendedContext.copy_sign(Decimal(1), -2)
Decimal('-1')
&gt;&gt;&gt; ExtendedContext.copy_sign(1, Decimal(-2))
Decimal('-1')</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Context.divide">
    
  </a>
  <a name="divide">
    
  </a>
  <div class="functionHeader">
    
    def
    divide(self, a, b):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Decimal division in a specified context.

&gt;&gt;&gt; ExtendedContext.divide(Decimal('1'), Decimal('3'))
Decimal('0.333333333')
&gt;&gt;&gt; ExtendedContext.divide(Decimal('2'), Decimal('3'))
Decimal('0.666666667')
&gt;&gt;&gt; ExtendedContext.divide(Decimal('5'), Decimal('2'))
Decimal('2.5')
&gt;&gt;&gt; ExtendedContext.divide(Decimal('1'), Decimal('10'))
Decimal('0.1')
&gt;&gt;&gt; ExtendedContext.divide(Decimal('12'), Decimal('12'))
Decimal('1')
&gt;&gt;&gt; ExtendedContext.divide(Decimal('8.00'), Decimal('2'))
Decimal('4.00')
&gt;&gt;&gt; ExtendedContext.divide(Decimal('2.400'), Decimal('2.0'))
Decimal('1.20')
&gt;&gt;&gt; ExtendedContext.divide(Decimal('1000'), Decimal('100'))
Decimal('10')
&gt;&gt;&gt; ExtendedContext.divide(Decimal('1000'), Decimal('1'))
Decimal('1000')
&gt;&gt;&gt; ExtendedContext.divide(Decimal('2.40E+6'), Decimal('2'))
Decimal('1.20E+6')
&gt;&gt;&gt; ExtendedContext.divide(5, 5)
Decimal('1')
&gt;&gt;&gt; ExtendedContext.divide(Decimal(5), 5)
Decimal('1')
&gt;&gt;&gt; ExtendedContext.divide(5, Decimal(5))
Decimal('1')</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Context.divide_int">
    
  </a>
  <a name="divide_int">
    
  </a>
  <div class="functionHeader">
    
    def
    divide_int(self, a, b):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Divides two numbers and returns the integer part of the result.

&gt;&gt;&gt; ExtendedContext.divide_int(Decimal('2'), Decimal('3'))
Decimal('0')
&gt;&gt;&gt; ExtendedContext.divide_int(Decimal('10'), Decimal('3'))
Decimal('3')
&gt;&gt;&gt; ExtendedContext.divide_int(Decimal('1'), Decimal('0.3'))
Decimal('3')
&gt;&gt;&gt; ExtendedContext.divide_int(10, 3)
Decimal('3')
&gt;&gt;&gt; ExtendedContext.divide_int(Decimal(10), 3)
Decimal('3')
&gt;&gt;&gt; ExtendedContext.divide_int(10, Decimal(3))
Decimal('3')</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Context.divmod">
    
  </a>
  <a name="divmod">
    
  </a>
  <div class="functionHeader">
    
    def
    divmod(self, a, b):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Return (a // b, a % b).

&gt;&gt;&gt; ExtendedContext.divmod(Decimal(8), Decimal(3))
(Decimal('2'), Decimal('2'))
&gt;&gt;&gt; ExtendedContext.divmod(Decimal(8), Decimal(4))
(Decimal('2'), Decimal('0'))
&gt;&gt;&gt; ExtendedContext.divmod(8, 4)
(Decimal('2'), Decimal('0'))
&gt;&gt;&gt; ExtendedContext.divmod(Decimal(8), 4)
(Decimal('2'), Decimal('0'))
&gt;&gt;&gt; ExtendedContext.divmod(8, Decimal(4))
(Decimal('2'), Decimal('0'))</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Context.exp">
    
  </a>
  <a name="exp">
    
  </a>
  <div class="functionHeader">
    
    def
    exp(self, a):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Returns e ** a.

&gt;&gt;&gt; c = ExtendedContext.copy()
&gt;&gt;&gt; c.Emin = -999
&gt;&gt;&gt; c.Emax = 999
&gt;&gt;&gt; c.exp(Decimal('-Infinity'))
Decimal('0')
&gt;&gt;&gt; c.exp(Decimal('-1'))
Decimal('0.367879441')
&gt;&gt;&gt; c.exp(Decimal('0'))
Decimal('1')
&gt;&gt;&gt; c.exp(Decimal('1'))
Decimal('2.71828183')
&gt;&gt;&gt; c.exp(Decimal('0.693147181'))
Decimal('2.00000000')
&gt;&gt;&gt; c.exp(Decimal('+Infinity'))
Decimal('Infinity')
&gt;&gt;&gt; c.exp(10)
Decimal('22026.4658')</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Context.fma">
    
  </a>
  <a name="fma">
    
  </a>
  <div class="functionHeader">
    
    def
    fma(self, a, b, c):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Returns a multiplied by b, plus c.

The first two operands are multiplied together, using multiply,
the third operand is then added to the result of that
multiplication, using add, all with only one final rounding.

&gt;&gt;&gt; ExtendedContext.fma(Decimal('3'), Decimal('5'), Decimal('7'))
Decimal('22')
&gt;&gt;&gt; ExtendedContext.fma(Decimal('3'), Decimal('-5'), Decimal('7'))
Decimal('-8')
&gt;&gt;&gt; ExtendedContext.fma(Decimal('888565290'), Decimal('1557.96930'), Decimal('-86087.7578'))
Decimal('1.38435736E+12')
&gt;&gt;&gt; ExtendedContext.fma(1, 3, 4)
Decimal('7')
&gt;&gt;&gt; ExtendedContext.fma(1, Decimal(3), 4)
Decimal('7')
&gt;&gt;&gt; ExtendedContext.fma(1, 3, Decimal(4))
Decimal('7')</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Context.is_canonical">
    
  </a>
  <a name="is_canonical">
    
  </a>
  <div class="functionHeader">
    
    def
    is_canonical(self, a):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Return True if the operand is canonical; otherwise return False.

Currently, the encoding of a Decimal instance is always
canonical, so this method returns True for any Decimal.

&gt;&gt;&gt; ExtendedContext.is_canonical(Decimal('2.50'))
True</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Context.is_finite">
    
  </a>
  <a name="is_finite">
    
  </a>
  <div class="functionHeader">
    
    def
    is_finite(self, a):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Return True if the operand is finite; otherwise return False.

A Decimal instance is considered finite if it is neither
infinite nor a NaN.

&gt;&gt;&gt; ExtendedContext.is_finite(Decimal('2.50'))
True
&gt;&gt;&gt; ExtendedContext.is_finite(Decimal('-0.3'))
True
&gt;&gt;&gt; ExtendedContext.is_finite(Decimal('0'))
True
&gt;&gt;&gt; ExtendedContext.is_finite(Decimal('Inf'))
False
&gt;&gt;&gt; ExtendedContext.is_finite(Decimal('NaN'))
False
&gt;&gt;&gt; ExtendedContext.is_finite(1)
True</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Context.is_infinite">
    
  </a>
  <a name="is_infinite">
    
  </a>
  <div class="functionHeader">
    
    def
    is_infinite(self, a):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Return True if the operand is infinite; otherwise return False.

&gt;&gt;&gt; ExtendedContext.is_infinite(Decimal('2.50'))
False
&gt;&gt;&gt; ExtendedContext.is_infinite(Decimal('-Inf'))
True
&gt;&gt;&gt; ExtendedContext.is_infinite(Decimal('NaN'))
False
&gt;&gt;&gt; ExtendedContext.is_infinite(1)
False</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Context.is_nan">
    
  </a>
  <a name="is_nan">
    
  </a>
  <div class="functionHeader">
    
    def
    is_nan(self, a):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Return True if the operand is a qNaN or sNaN;
otherwise return False.

&gt;&gt;&gt; ExtendedContext.is_nan(Decimal('2.50'))
False
&gt;&gt;&gt; ExtendedContext.is_nan(Decimal('NaN'))
True
&gt;&gt;&gt; ExtendedContext.is_nan(Decimal('-sNaN'))
True
&gt;&gt;&gt; ExtendedContext.is_nan(1)
False</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Context.is_normal">
    
  </a>
  <a name="is_normal">
    
  </a>
  <div class="functionHeader">
    
    def
    is_normal(self, a):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Return True if the operand is a normal number;
otherwise return False.

&gt;&gt;&gt; c = ExtendedContext.copy()
&gt;&gt;&gt; c.Emin = -999
&gt;&gt;&gt; c.Emax = 999
&gt;&gt;&gt; c.is_normal(Decimal('2.50'))
True
&gt;&gt;&gt; c.is_normal(Decimal('0.1E-999'))
False
&gt;&gt;&gt; c.is_normal(Decimal('0.00'))
False
&gt;&gt;&gt; c.is_normal(Decimal('-Inf'))
False
&gt;&gt;&gt; c.is_normal(Decimal('NaN'))
False
&gt;&gt;&gt; c.is_normal(1)
True</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Context.is_qnan">
    
  </a>
  <a name="is_qnan">
    
  </a>
  <div class="functionHeader">
    
    def
    is_qnan(self, a):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Return True if the operand is a quiet NaN; otherwise return False.

&gt;&gt;&gt; ExtendedContext.is_qnan(Decimal('2.50'))
False
&gt;&gt;&gt; ExtendedContext.is_qnan(Decimal('NaN'))
True
&gt;&gt;&gt; ExtendedContext.is_qnan(Decimal('sNaN'))
False
&gt;&gt;&gt; ExtendedContext.is_qnan(1)
False</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Context.is_signed">
    
  </a>
  <a name="is_signed">
    
  </a>
  <div class="functionHeader">
    
    def
    is_signed(self, a):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Return True if the operand is negative; otherwise return False.

&gt;&gt;&gt; ExtendedContext.is_signed(Decimal('2.50'))
False
&gt;&gt;&gt; ExtendedContext.is_signed(Decimal('-12'))
True
&gt;&gt;&gt; ExtendedContext.is_signed(Decimal('-0'))
True
&gt;&gt;&gt; ExtendedContext.is_signed(8)
False
&gt;&gt;&gt; ExtendedContext.is_signed(-8)
True</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Context.is_snan">
    
  </a>
  <a name="is_snan">
    
  </a>
  <div class="functionHeader">
    
    def
    is_snan(self, a):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Return True if the operand is a signaling NaN;
otherwise return False.

&gt;&gt;&gt; ExtendedContext.is_snan(Decimal('2.50'))
False
&gt;&gt;&gt; ExtendedContext.is_snan(Decimal('NaN'))
False
&gt;&gt;&gt; ExtendedContext.is_snan(Decimal('sNaN'))
True
&gt;&gt;&gt; ExtendedContext.is_snan(1)
False</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Context.is_subnormal">
    
  </a>
  <a name="is_subnormal">
    
  </a>
  <div class="functionHeader">
    
    def
    is_subnormal(self, a):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Return True if the operand is subnormal; otherwise return False.

&gt;&gt;&gt; c = ExtendedContext.copy()
&gt;&gt;&gt; c.Emin = -999
&gt;&gt;&gt; c.Emax = 999
&gt;&gt;&gt; c.is_subnormal(Decimal('2.50'))
False
&gt;&gt;&gt; c.is_subnormal(Decimal('0.1E-999'))
True
&gt;&gt;&gt; c.is_subnormal(Decimal('0.00'))
False
&gt;&gt;&gt; c.is_subnormal(Decimal('-Inf'))
False
&gt;&gt;&gt; c.is_subnormal(Decimal('NaN'))
False
&gt;&gt;&gt; c.is_subnormal(1)
False</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Context.is_zero">
    
  </a>
  <a name="is_zero">
    
  </a>
  <div class="functionHeader">
    
    def
    is_zero(self, a):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Return True if the operand is a zero; otherwise return False.

&gt;&gt;&gt; ExtendedContext.is_zero(Decimal('0'))
True
&gt;&gt;&gt; ExtendedContext.is_zero(Decimal('2.50'))
False
&gt;&gt;&gt; ExtendedContext.is_zero(Decimal('-0E+2'))
True
&gt;&gt;&gt; ExtendedContext.is_zero(1)
False
&gt;&gt;&gt; ExtendedContext.is_zero(0)
True</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Context.ln">
    
  </a>
  <a name="ln">
    
  </a>
  <div class="functionHeader">
    
    def
    ln(self, a):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Returns the natural (base e) logarithm of the operand.

&gt;&gt;&gt; c = ExtendedContext.copy()
&gt;&gt;&gt; c.Emin = -999
&gt;&gt;&gt; c.Emax = 999
&gt;&gt;&gt; c.ln(Decimal('0'))
Decimal('-Infinity')
&gt;&gt;&gt; c.ln(Decimal('1.000'))
Decimal('0')
&gt;&gt;&gt; c.ln(Decimal('2.71828183'))
Decimal('1.00000000')
&gt;&gt;&gt; c.ln(Decimal('10'))
Decimal('2.30258509')
&gt;&gt;&gt; c.ln(Decimal('+Infinity'))
Decimal('Infinity')
&gt;&gt;&gt; c.ln(1)
Decimal('0')</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Context.log10">
    
  </a>
  <a name="log10">
    
  </a>
  <div class="functionHeader">
    
    def
    log10(self, a):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Returns the base 10 logarithm of the operand.

&gt;&gt;&gt; c = ExtendedContext.copy()
&gt;&gt;&gt; c.Emin = -999
&gt;&gt;&gt; c.Emax = 999
&gt;&gt;&gt; c.log10(Decimal('0'))
Decimal('-Infinity')
&gt;&gt;&gt; c.log10(Decimal('0.001'))
Decimal('-3')
&gt;&gt;&gt; c.log10(Decimal('1.000'))
Decimal('0')
&gt;&gt;&gt; c.log10(Decimal('2'))
Decimal('0.301029996')
&gt;&gt;&gt; c.log10(Decimal('10'))
Decimal('1')
&gt;&gt;&gt; c.log10(Decimal('70'))
Decimal('1.84509804')
&gt;&gt;&gt; c.log10(Decimal('+Infinity'))
Decimal('Infinity')
&gt;&gt;&gt; c.log10(0)
Decimal('-Infinity')
&gt;&gt;&gt; c.log10(1)
Decimal('0')</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Context.logb">
    
  </a>
  <a name="logb">
    
  </a>
  <div class="functionHeader">
    
    def
    logb(self, a):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Returns the exponent of the magnitude of the operand's MSD.

The result is the integer which is the exponent of the magnitude
of the most significant digit of the operand (as though the
operand were truncated to a single digit while maintaining the
value of that digit and without limiting the resulting exponent).

&gt;&gt;&gt; ExtendedContext.logb(Decimal('250'))
Decimal('2')
&gt;&gt;&gt; ExtendedContext.logb(Decimal('2.50'))
Decimal('0')
&gt;&gt;&gt; ExtendedContext.logb(Decimal('0.03'))
Decimal('-2')
&gt;&gt;&gt; ExtendedContext.logb(Decimal('0'))
Decimal('-Infinity')
&gt;&gt;&gt; ExtendedContext.logb(1)
Decimal('0')
&gt;&gt;&gt; ExtendedContext.logb(10)
Decimal('1')
&gt;&gt;&gt; ExtendedContext.logb(100)
Decimal('2')</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Context.logical_and">
    
  </a>
  <a name="logical_and">
    
  </a>
  <div class="functionHeader">
    
    def
    logical_and(self, a, b):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Applies the logical operation 'and' between each operand's digits.

The operands must be both logical numbers.

&gt;&gt;&gt; ExtendedContext.logical_and(Decimal('0'), Decimal('0'))
Decimal('0')
&gt;&gt;&gt; ExtendedContext.logical_and(Decimal('0'), Decimal('1'))
Decimal('0')
&gt;&gt;&gt; ExtendedContext.logical_and(Decimal('1'), Decimal('0'))
Decimal('0')
&gt;&gt;&gt; ExtendedContext.logical_and(Decimal('1'), Decimal('1'))
Decimal('1')
&gt;&gt;&gt; ExtendedContext.logical_and(Decimal('1100'), Decimal('1010'))
Decimal('1000')
&gt;&gt;&gt; ExtendedContext.logical_and(Decimal('1111'), Decimal('10'))
Decimal('10')
&gt;&gt;&gt; ExtendedContext.logical_and(110, 1101)
Decimal('100')
&gt;&gt;&gt; ExtendedContext.logical_and(Decimal(110), 1101)
Decimal('100')
&gt;&gt;&gt; ExtendedContext.logical_and(110, Decimal(1101))
Decimal('100')</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Context.logical_invert">
    
  </a>
  <a name="logical_invert">
    
  </a>
  <div class="functionHeader">
    
    def
    logical_invert(self, a):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Invert all the digits in the operand.

The operand must be a logical number.

&gt;&gt;&gt; ExtendedContext.logical_invert(Decimal('0'))
Decimal('111111111')
&gt;&gt;&gt; ExtendedContext.logical_invert(Decimal('1'))
Decimal('111111110')
&gt;&gt;&gt; ExtendedContext.logical_invert(Decimal('111111111'))
Decimal('0')
&gt;&gt;&gt; ExtendedContext.logical_invert(Decimal('101010101'))
Decimal('10101010')
&gt;&gt;&gt; ExtendedContext.logical_invert(1101)
Decimal('111110010')</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Context.logical_or">
    
  </a>
  <a name="logical_or">
    
  </a>
  <div class="functionHeader">
    
    def
    logical_or(self, a, b):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Applies the logical operation 'or' between each operand's digits.

The operands must be both logical numbers.

&gt;&gt;&gt; ExtendedContext.logical_or(Decimal('0'), Decimal('0'))
Decimal('0')
&gt;&gt;&gt; ExtendedContext.logical_or(Decimal('0'), Decimal('1'))
Decimal('1')
&gt;&gt;&gt; ExtendedContext.logical_or(Decimal('1'), Decimal('0'))
Decimal('1')
&gt;&gt;&gt; ExtendedContext.logical_or(Decimal('1'), Decimal('1'))
Decimal('1')
&gt;&gt;&gt; ExtendedContext.logical_or(Decimal('1100'), Decimal('1010'))
Decimal('1110')
&gt;&gt;&gt; ExtendedContext.logical_or(Decimal('1110'), Decimal('10'))
Decimal('1110')
&gt;&gt;&gt; ExtendedContext.logical_or(110, 1101)
Decimal('1111')
&gt;&gt;&gt; ExtendedContext.logical_or(Decimal(110), 1101)
Decimal('1111')
&gt;&gt;&gt; ExtendedContext.logical_or(110, Decimal(1101))
Decimal('1111')</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Context.logical_xor">
    
  </a>
  <a name="logical_xor">
    
  </a>
  <div class="functionHeader">
    
    def
    logical_xor(self, a, b):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Applies the logical operation 'xor' between each operand's digits.

The operands must be both logical numbers.

&gt;&gt;&gt; ExtendedContext.logical_xor(Decimal('0'), Decimal('0'))
Decimal('0')
&gt;&gt;&gt; ExtendedContext.logical_xor(Decimal('0'), Decimal('1'))
Decimal('1')
&gt;&gt;&gt; ExtendedContext.logical_xor(Decimal('1'), Decimal('0'))
Decimal('1')
&gt;&gt;&gt; ExtendedContext.logical_xor(Decimal('1'), Decimal('1'))
Decimal('0')
&gt;&gt;&gt; ExtendedContext.logical_xor(Decimal('1100'), Decimal('1010'))
Decimal('110')
&gt;&gt;&gt; ExtendedContext.logical_xor(Decimal('1111'), Decimal('10'))
Decimal('1101')
&gt;&gt;&gt; ExtendedContext.logical_xor(110, 1101)
Decimal('1011')
&gt;&gt;&gt; ExtendedContext.logical_xor(Decimal(110), 1101)
Decimal('1011')
&gt;&gt;&gt; ExtendedContext.logical_xor(110, Decimal(1101))
Decimal('1011')</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Context.max">
    
  </a>
  <a name="max">
    
  </a>
  <div class="functionHeader">
    
    def
    max(self, a, b):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">max compares two values numerically and returns the maximum.

If either operand is a NaN then the general rules apply.
Otherwise, the operands are compared as though by the compare
operation.  If they are numerically equal then the left-hand operand
is chosen as the result.  Otherwise the maximum (closer to positive
infinity) of the two operands is chosen as the result.

&gt;&gt;&gt; ExtendedContext.max(Decimal('3'), Decimal('2'))
Decimal('3')
&gt;&gt;&gt; ExtendedContext.max(Decimal('-10'), Decimal('3'))
Decimal('3')
&gt;&gt;&gt; ExtendedContext.max(Decimal('1.0'), Decimal('1'))
Decimal('1')
&gt;&gt;&gt; ExtendedContext.max(Decimal('7'), Decimal('NaN'))
Decimal('7')
&gt;&gt;&gt; ExtendedContext.max(1, 2)
Decimal('2')
&gt;&gt;&gt; ExtendedContext.max(Decimal(1), 2)
Decimal('2')
&gt;&gt;&gt; ExtendedContext.max(1, Decimal(2))
Decimal('2')</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Context.max_mag">
    
  </a>
  <a name="max_mag">
    
  </a>
  <div class="functionHeader">
    
    def
    max_mag(self, a, b):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Compares the values numerically with their sign ignored.

&gt;&gt;&gt; ExtendedContext.max_mag(Decimal('7'), Decimal('NaN'))
Decimal('7')
&gt;&gt;&gt; ExtendedContext.max_mag(Decimal('7'), Decimal('-10'))
Decimal('-10')
&gt;&gt;&gt; ExtendedContext.max_mag(1, -2)
Decimal('-2')
&gt;&gt;&gt; ExtendedContext.max_mag(Decimal(1), -2)
Decimal('-2')
&gt;&gt;&gt; ExtendedContext.max_mag(1, Decimal(-2))
Decimal('-2')</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Context.min">
    
  </a>
  <a name="min">
    
  </a>
  <div class="functionHeader">
    
    def
    min(self, a, b):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">min compares two values numerically and returns the minimum.

If either operand is a NaN then the general rules apply.
Otherwise, the operands are compared as though by the compare
operation.  If they are numerically equal then the left-hand operand
is chosen as the result.  Otherwise the minimum (closer to negative
infinity) of the two operands is chosen as the result.

&gt;&gt;&gt; ExtendedContext.min(Decimal('3'), Decimal('2'))
Decimal('2')
&gt;&gt;&gt; ExtendedContext.min(Decimal('-10'), Decimal('3'))
Decimal('-10')
&gt;&gt;&gt; ExtendedContext.min(Decimal('1.0'), Decimal('1'))
Decimal('1.0')
&gt;&gt;&gt; ExtendedContext.min(Decimal('7'), Decimal('NaN'))
Decimal('7')
&gt;&gt;&gt; ExtendedContext.min(1, 2)
Decimal('1')
&gt;&gt;&gt; ExtendedContext.min(Decimal(1), 2)
Decimal('1')
&gt;&gt;&gt; ExtendedContext.min(1, Decimal(29))
Decimal('1')</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Context.min_mag">
    
  </a>
  <a name="min_mag">
    
  </a>
  <div class="functionHeader">
    
    def
    min_mag(self, a, b):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Compares the values numerically with their sign ignored.

&gt;&gt;&gt; ExtendedContext.min_mag(Decimal('3'), Decimal('-2'))
Decimal('-2')
&gt;&gt;&gt; ExtendedContext.min_mag(Decimal('-3'), Decimal('NaN'))
Decimal('-3')
&gt;&gt;&gt; ExtendedContext.min_mag(1, -2)
Decimal('1')
&gt;&gt;&gt; ExtendedContext.min_mag(Decimal(1), -2)
Decimal('1')
&gt;&gt;&gt; ExtendedContext.min_mag(1, Decimal(-2))
Decimal('1')</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Context.minus">
    
  </a>
  <a name="minus">
    
  </a>
  <div class="functionHeader">
    
    def
    minus(self, a):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Minus corresponds to unary prefix minus in Python.

The operation is evaluated using the same rules as subtract; the
operation minus(a) is calculated as subtract('0', a) where the '0'
has the same exponent as the operand.

&gt;&gt;&gt; ExtendedContext.minus(Decimal('1.3'))
Decimal('-1.3')
&gt;&gt;&gt; ExtendedContext.minus(Decimal('-1.3'))
Decimal('1.3')
&gt;&gt;&gt; ExtendedContext.minus(1)
Decimal('-1')</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Context.multiply">
    
  </a>
  <a name="multiply">
    
  </a>
  <div class="functionHeader">
    
    def
    multiply(self, a, b):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">multiply multiplies two operands.

If either operand is a special value then the general rules apply.
Otherwise, the operands are multiplied together
('long multiplication'), resulting in a number which may be as long as
the sum of the lengths of the two operands.

&gt;&gt;&gt; ExtendedContext.multiply(Decimal('1.20'), Decimal('3'))
Decimal('3.60')
&gt;&gt;&gt; ExtendedContext.multiply(Decimal('7'), Decimal('3'))
Decimal('21')
&gt;&gt;&gt; ExtendedContext.multiply(Decimal('0.9'), Decimal('0.8'))
Decimal('0.72')
&gt;&gt;&gt; ExtendedContext.multiply(Decimal('0.9'), Decimal('-0'))
Decimal('-0.0')
&gt;&gt;&gt; ExtendedContext.multiply(Decimal('654321'), Decimal('654321'))
Decimal('4.28135971E+11')
&gt;&gt;&gt; ExtendedContext.multiply(7, 7)
Decimal('49')
&gt;&gt;&gt; ExtendedContext.multiply(Decimal(7), 7)
Decimal('49')
&gt;&gt;&gt; ExtendedContext.multiply(7, Decimal(7))
Decimal('49')</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Context.next_minus">
    
  </a>
  <a name="next_minus">
    
  </a>
  <div class="functionHeader">
    
    def
    next_minus(self, a):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Returns the largest representable number smaller than a.

&gt;&gt;&gt; c = ExtendedContext.copy()
&gt;&gt;&gt; c.Emin = -999
&gt;&gt;&gt; c.Emax = 999
&gt;&gt;&gt; ExtendedContext.next_minus(Decimal('1'))
Decimal('0.999999999')
&gt;&gt;&gt; c.next_minus(Decimal('1E-1007'))
Decimal('0E-1007')
&gt;&gt;&gt; ExtendedContext.next_minus(Decimal('-1.00000003'))
Decimal('-1.00000004')
&gt;&gt;&gt; c.next_minus(Decimal('Infinity'))
Decimal('9.99999999E+999')
&gt;&gt;&gt; c.next_minus(1)
Decimal('0.999999999')</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Context.next_plus">
    
  </a>
  <a name="next_plus">
    
  </a>
  <div class="functionHeader">
    
    def
    next_plus(self, a):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Returns the smallest representable number larger than a.

&gt;&gt;&gt; c = ExtendedContext.copy()
&gt;&gt;&gt; c.Emin = -999
&gt;&gt;&gt; c.Emax = 999
&gt;&gt;&gt; ExtendedContext.next_plus(Decimal('1'))
Decimal('1.00000001')
&gt;&gt;&gt; c.next_plus(Decimal('-1E-1007'))
Decimal('-0E-1007')
&gt;&gt;&gt; ExtendedContext.next_plus(Decimal('-1.00000003'))
Decimal('-1.00000002')
&gt;&gt;&gt; c.next_plus(Decimal('-Infinity'))
Decimal('-9.99999999E+999')
&gt;&gt;&gt; c.next_plus(1)
Decimal('1.00000001')</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Context.next_toward">
    
  </a>
  <a name="next_toward">
    
  </a>
  <div class="functionHeader">
    
    def
    next_toward(self, a, b):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Returns the number closest to a, in direction towards b.

The result is the closest representable number from the first
operand (but not the first operand) that is in the direction
towards the second operand, unless the operands have the same
value.

&gt;&gt;&gt; c = ExtendedContext.copy()
&gt;&gt;&gt; c.Emin = -999
&gt;&gt;&gt; c.Emax = 999
&gt;&gt;&gt; c.next_toward(Decimal('1'), Decimal('2'))
Decimal('1.00000001')
&gt;&gt;&gt; c.next_toward(Decimal('-1E-1007'), Decimal('1'))
Decimal('-0E-1007')
&gt;&gt;&gt; c.next_toward(Decimal('-1.00000003'), Decimal('0'))
Decimal('-1.00000002')
&gt;&gt;&gt; c.next_toward(Decimal('1'), Decimal('0'))
Decimal('0.999999999')
&gt;&gt;&gt; c.next_toward(Decimal('1E-1007'), Decimal('-100'))
Decimal('0E-1007')
&gt;&gt;&gt; c.next_toward(Decimal('-1.00000003'), Decimal('-10'))
Decimal('-1.00000004')
&gt;&gt;&gt; c.next_toward(Decimal('0.00'), Decimal('-0.0000'))
Decimal('-0.00')
&gt;&gt;&gt; c.next_toward(0, 1)
Decimal('1E-1007')
&gt;&gt;&gt; c.next_toward(Decimal(0), 1)
Decimal('1E-1007')
&gt;&gt;&gt; c.next_toward(0, Decimal(1))
Decimal('1E-1007')</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Context.normalize">
    
  </a>
  <a name="normalize">
    
  </a>
  <div class="functionHeader">
    
    def
    normalize(self, a):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">normalize reduces an operand to its simplest form.

Essentially a plus operation with all trailing zeros removed from the
result.

&gt;&gt;&gt; ExtendedContext.normalize(Decimal('2.1'))
Decimal('2.1')
&gt;&gt;&gt; ExtendedContext.normalize(Decimal('-2.0'))
Decimal('-2')
&gt;&gt;&gt; ExtendedContext.normalize(Decimal('1.200'))
Decimal('1.2')
&gt;&gt;&gt; ExtendedContext.normalize(Decimal('-120'))
Decimal('-1.2E+2')
&gt;&gt;&gt; ExtendedContext.normalize(Decimal('120.00'))
Decimal('1.2E+2')
&gt;&gt;&gt; ExtendedContext.normalize(Decimal('0.00'))
Decimal('0')
&gt;&gt;&gt; ExtendedContext.normalize(6)
Decimal('6')</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Context.number_class">
    
  </a>
  <a name="number_class">
    
  </a>
  <div class="functionHeader">
    
    def
    number_class(self, a):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Returns an indication of the class of the operand.

The class is one of the following strings:
  -sNaN
  -NaN
  -Infinity
  -Normal
  -Subnormal
  -Zero
  +Zero
  +Subnormal
  +Normal
  +Infinity

&gt;&gt;&gt; c = ExtendedContext.copy()
&gt;&gt;&gt; c.Emin = -999
&gt;&gt;&gt; c.Emax = 999
&gt;&gt;&gt; c.number_class(Decimal('Infinity'))
'+Infinity'
&gt;&gt;&gt; c.number_class(Decimal('1E-10'))
'+Normal'
&gt;&gt;&gt; c.number_class(Decimal('2.50'))
'+Normal'
&gt;&gt;&gt; c.number_class(Decimal('0.1E-999'))
'+Subnormal'
&gt;&gt;&gt; c.number_class(Decimal('0'))
'+Zero'
&gt;&gt;&gt; c.number_class(Decimal('-0'))
'-Zero'
&gt;&gt;&gt; c.number_class(Decimal('-0.1E-999'))
'-Subnormal'
&gt;&gt;&gt; c.number_class(Decimal('-1E-10'))
'-Normal'
&gt;&gt;&gt; c.number_class(Decimal('-2.50'))
'-Normal'
&gt;&gt;&gt; c.number_class(Decimal('-Infinity'))
'-Infinity'
&gt;&gt;&gt; c.number_class(Decimal('NaN'))
'NaN'
&gt;&gt;&gt; c.number_class(Decimal('-NaN'))
'NaN'
&gt;&gt;&gt; c.number_class(Decimal('sNaN'))
'sNaN'
&gt;&gt;&gt; c.number_class(123)
'+Normal'</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Context.plus">
    
  </a>
  <a name="plus">
    
  </a>
  <div class="functionHeader">
    
    def
    plus(self, a):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Plus corresponds to unary prefix plus in Python.

The operation is evaluated using the same rules as add; the
operation plus(a) is calculated as add('0', a) where the '0'
has the same exponent as the operand.

&gt;&gt;&gt; ExtendedContext.plus(Decimal('1.3'))
Decimal('1.3')
&gt;&gt;&gt; ExtendedContext.plus(Decimal('-1.3'))
Decimal('-1.3')
&gt;&gt;&gt; ExtendedContext.plus(-1)
Decimal('-1')</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Context.power">
    
  </a>
  <a name="power">
    
  </a>
  <div class="functionHeader">
    
    def
    power(self, a, b, modulo=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Raises a to the power of b, to modulo if given.

With two arguments, compute a**b.  If a is negative then b
must be integral.  The result will be inexact unless b is
integral and the result is finite and can be expressed exactly
in 'precision' digits.

With three arguments, compute (a**b) % modulo.  For the
three argument form, the following restrictions on the
arguments hold:

 - all three arguments must be integral
 - b must be nonnegative
 - at least one of a or b must be nonzero
 - modulo must be nonzero and have at most 'precision' digits

The result of pow(a, b, modulo) is identical to the result
that would be obtained by computing (a**b) % modulo with
unbounded precision, but is computed more efficiently.  It is
always exact.

&gt;&gt;&gt; c = ExtendedContext.copy()
&gt;&gt;&gt; c.Emin = -999
&gt;&gt;&gt; c.Emax = 999
&gt;&gt;&gt; c.power(Decimal('2'), Decimal('3'))
Decimal('8')
&gt;&gt;&gt; c.power(Decimal('-2'), Decimal('3'))
Decimal('-8')
&gt;&gt;&gt; c.power(Decimal('2'), Decimal('-3'))
Decimal('0.125')
&gt;&gt;&gt; c.power(Decimal('1.7'), Decimal('8'))
Decimal('69.7575744')
&gt;&gt;&gt; c.power(Decimal('10'), Decimal('0.301029996'))
Decimal('2.00000000')
&gt;&gt;&gt; c.power(Decimal('Infinity'), Decimal('-1'))
Decimal('0')
&gt;&gt;&gt; c.power(Decimal('Infinity'), Decimal('0'))
Decimal('1')
&gt;&gt;&gt; c.power(Decimal('Infinity'), Decimal('1'))
Decimal('Infinity')
&gt;&gt;&gt; c.power(Decimal('-Infinity'), Decimal('-1'))
Decimal('-0')
&gt;&gt;&gt; c.power(Decimal('-Infinity'), Decimal('0'))
Decimal('1')
&gt;&gt;&gt; c.power(Decimal('-Infinity'), Decimal('1'))
Decimal('-Infinity')
&gt;&gt;&gt; c.power(Decimal('-Infinity'), Decimal('2'))
Decimal('Infinity')
&gt;&gt;&gt; c.power(Decimal('0'), Decimal('0'))
Decimal('NaN')

&gt;&gt;&gt; c.power(Decimal('3'), Decimal('7'), Decimal('16'))
Decimal('11')
&gt;&gt;&gt; c.power(Decimal('-3'), Decimal('7'), Decimal('16'))
Decimal('-11')
&gt;&gt;&gt; c.power(Decimal('-3'), Decimal('8'), Decimal('16'))
Decimal('1')
&gt;&gt;&gt; c.power(Decimal('3'), Decimal('7'), Decimal('-16'))
Decimal('11')
&gt;&gt;&gt; c.power(Decimal('23E12345'), Decimal('67E189'), Decimal('123456789'))
Decimal('11729830')
&gt;&gt;&gt; c.power(Decimal('-0'), Decimal('17'), Decimal('1729'))
Decimal('-0')
&gt;&gt;&gt; c.power(Decimal('-23'), Decimal('0'), Decimal('65537'))
Decimal('1')
&gt;&gt;&gt; ExtendedContext.power(7, 7)
Decimal('823543')
&gt;&gt;&gt; ExtendedContext.power(Decimal(7), 7)
Decimal('823543')
&gt;&gt;&gt; ExtendedContext.power(7, Decimal(7), 2)
Decimal('1')</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Context.quantize">
    
  </a>
  <a name="quantize">
    
  </a>
  <div class="functionHeader">
    
    def
    quantize(self, a, b):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Returns a value equal to 'a' (rounded), having the exponent of 'b'.

The coefficient of the result is derived from that of the left-hand
operand.  It may be rounded using the current rounding setting (if the
exponent is being increased), multiplied by a positive power of ten (if
the exponent is being decreased), or is unchanged (if the exponent is
already equal to that of the right-hand operand).

Unlike other operations, if the length of the coefficient after the
quantize operation would be greater than precision then an Invalid
operation condition is raised.  This guarantees that, unless there is
an error condition, the exponent of the result of a quantize is always
equal to that of the right-hand operand.

Also unlike other operations, quantize will never raise Underflow, even
if the result is subnormal and inexact.

&gt;&gt;&gt; ExtendedContext.quantize(Decimal('2.17'), Decimal('0.001'))
Decimal('2.170')
&gt;&gt;&gt; ExtendedContext.quantize(Decimal('2.17'), Decimal('0.01'))
Decimal('2.17')
&gt;&gt;&gt; ExtendedContext.quantize(Decimal('2.17'), Decimal('0.1'))
Decimal('2.2')
&gt;&gt;&gt; ExtendedContext.quantize(Decimal('2.17'), Decimal('1e+0'))
Decimal('2')
&gt;&gt;&gt; ExtendedContext.quantize(Decimal('2.17'), Decimal('1e+1'))
Decimal('0E+1')
&gt;&gt;&gt; ExtendedContext.quantize(Decimal('-Inf'), Decimal('Infinity'))
Decimal('-Infinity')
&gt;&gt;&gt; ExtendedContext.quantize(Decimal('2'), Decimal('Infinity'))
Decimal('NaN')
&gt;&gt;&gt; ExtendedContext.quantize(Decimal('-0.1'), Decimal('1'))
Decimal('-0')
&gt;&gt;&gt; ExtendedContext.quantize(Decimal('-0'), Decimal('1e+5'))
Decimal('-0E+5')
&gt;&gt;&gt; ExtendedContext.quantize(Decimal('+35236450.6'), Decimal('1e-2'))
Decimal('NaN')
&gt;&gt;&gt; ExtendedContext.quantize(Decimal('-35236450.6'), Decimal('1e-2'))
Decimal('NaN')
&gt;&gt;&gt; ExtendedContext.quantize(Decimal('217'), Decimal('1e-1'))
Decimal('217.0')
&gt;&gt;&gt; ExtendedContext.quantize(Decimal('217'), Decimal('1e-0'))
Decimal('217')
&gt;&gt;&gt; ExtendedContext.quantize(Decimal('217'), Decimal('1e+1'))
Decimal('2.2E+2')
&gt;&gt;&gt; ExtendedContext.quantize(Decimal('217'), Decimal('1e+2'))
Decimal('2E+2')
&gt;&gt;&gt; ExtendedContext.quantize(1, 2)
Decimal('1')
&gt;&gt;&gt; ExtendedContext.quantize(Decimal(1), 2)
Decimal('1')
&gt;&gt;&gt; ExtendedContext.quantize(1, Decimal(2))
Decimal('1')</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Context.radix">
    
  </a>
  <a name="radix">
    
  </a>
  <div class="functionHeader">
    
    def
    radix(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Just returns 10, as this is Decimal, :)

&gt;&gt;&gt; ExtendedContext.radix()
Decimal('10')</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Context.remainder">
    
  </a>
  <a name="remainder">
    
  </a>
  <div class="functionHeader">
    
    def
    remainder(self, a, b):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Returns the remainder from integer division.

The result is the residue of the dividend after the operation of
calculating integer division as described for divide-integer, rounded
to precision digits if necessary.  The sign of the result, if
non-zero, is the same as that of the original dividend.

This operation will fail under the same conditions as integer division
(that is, if integer division on the same two operands would fail, the
remainder cannot be calculated).

&gt;&gt;&gt; ExtendedContext.remainder(Decimal('2.1'), Decimal('3'))
Decimal('2.1')
&gt;&gt;&gt; ExtendedContext.remainder(Decimal('10'), Decimal('3'))
Decimal('1')
&gt;&gt;&gt; ExtendedContext.remainder(Decimal('-10'), Decimal('3'))
Decimal('-1')
&gt;&gt;&gt; ExtendedContext.remainder(Decimal('10.2'), Decimal('1'))
Decimal('0.2')
&gt;&gt;&gt; ExtendedContext.remainder(Decimal('10'), Decimal('0.3'))
Decimal('0.1')
&gt;&gt;&gt; ExtendedContext.remainder(Decimal('3.6'), Decimal('1.3'))
Decimal('1.0')
&gt;&gt;&gt; ExtendedContext.remainder(22, 6)
Decimal('4')
&gt;&gt;&gt; ExtendedContext.remainder(Decimal(22), 6)
Decimal('4')
&gt;&gt;&gt; ExtendedContext.remainder(22, Decimal(6))
Decimal('4')</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Context.remainder_near">
    
  </a>
  <a name="remainder_near">
    
  </a>
  <div class="functionHeader">
    
    def
    remainder_near(self, a, b):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Returns to be "a - b * n", where n is the integer nearest the exact
value of "x / b" (if two integers are equally near then the even one
is chosen).  If the result is equal to 0 then its sign will be the
sign of a.

This operation will fail under the same conditions as integer division
(that is, if integer division on the same two operands would fail, the
remainder cannot be calculated).

&gt;&gt;&gt; ExtendedContext.remainder_near(Decimal('2.1'), Decimal('3'))
Decimal('-0.9')
&gt;&gt;&gt; ExtendedContext.remainder_near(Decimal('10'), Decimal('6'))
Decimal('-2')
&gt;&gt;&gt; ExtendedContext.remainder_near(Decimal('10'), Decimal('3'))
Decimal('1')
&gt;&gt;&gt; ExtendedContext.remainder_near(Decimal('-10'), Decimal('3'))
Decimal('-1')
&gt;&gt;&gt; ExtendedContext.remainder_near(Decimal('10.2'), Decimal('1'))
Decimal('0.2')
&gt;&gt;&gt; ExtendedContext.remainder_near(Decimal('10'), Decimal('0.3'))
Decimal('0.1')
&gt;&gt;&gt; ExtendedContext.remainder_near(Decimal('3.6'), Decimal('1.3'))
Decimal('-0.3')
&gt;&gt;&gt; ExtendedContext.remainder_near(3, 11)
Decimal('3')
&gt;&gt;&gt; ExtendedContext.remainder_near(Decimal(3), 11)
Decimal('3')
&gt;&gt;&gt; ExtendedContext.remainder_near(3, Decimal(11))
Decimal('3')</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Context.rotate">
    
  </a>
  <a name="rotate">
    
  </a>
  <div class="functionHeader">
    
    def
    rotate(self, a, b):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Returns a rotated copy of a, b times.

The coefficient of the result is a rotated copy of the digits in
the coefficient of the first operand.  The number of places of
rotation is taken from the absolute value of the second operand,
with the rotation being to the left if the second operand is
positive or to the right otherwise.

&gt;&gt;&gt; ExtendedContext.rotate(Decimal('34'), Decimal('8'))
Decimal('400000003')
&gt;&gt;&gt; ExtendedContext.rotate(Decimal('12'), Decimal('9'))
Decimal('12')
&gt;&gt;&gt; ExtendedContext.rotate(Decimal('123456789'), Decimal('-2'))
Decimal('891234567')
&gt;&gt;&gt; ExtendedContext.rotate(Decimal('123456789'), Decimal('0'))
Decimal('123456789')
&gt;&gt;&gt; ExtendedContext.rotate(Decimal('123456789'), Decimal('+2'))
Decimal('345678912')
&gt;&gt;&gt; ExtendedContext.rotate(1333333, 1)
Decimal('13333330')
&gt;&gt;&gt; ExtendedContext.rotate(Decimal(1333333), 1)
Decimal('13333330')
&gt;&gt;&gt; ExtendedContext.rotate(1333333, Decimal(1))
Decimal('13333330')</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Context.same_quantum">
    
  </a>
  <a name="same_quantum">
    
  </a>
  <div class="functionHeader">
    
    def
    same_quantum(self, a, b):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Returns True if the two operands have the same exponent.

The result is never affected by either the sign or the coefficient of
either operand.

&gt;&gt;&gt; ExtendedContext.same_quantum(Decimal('2.17'), Decimal('0.001'))
False
&gt;&gt;&gt; ExtendedContext.same_quantum(Decimal('2.17'), Decimal('0.01'))
True
&gt;&gt;&gt; ExtendedContext.same_quantum(Decimal('2.17'), Decimal('1'))
False
&gt;&gt;&gt; ExtendedContext.same_quantum(Decimal('Inf'), Decimal('-Inf'))
True
&gt;&gt;&gt; ExtendedContext.same_quantum(10000, -1)
True
&gt;&gt;&gt; ExtendedContext.same_quantum(Decimal(10000), -1)
True
&gt;&gt;&gt; ExtendedContext.same_quantum(10000, Decimal(-1))
True</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Context.scaleb">
    
  </a>
  <a name="scaleb">
    
  </a>
  <div class="functionHeader">
    
    def
    scaleb(self, a, b):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Returns the first operand after adding the second value its exp.

&gt;&gt;&gt; ExtendedContext.scaleb(Decimal('7.50'), Decimal('-2'))
Decimal('0.0750')
&gt;&gt;&gt; ExtendedContext.scaleb(Decimal('7.50'), Decimal('0'))
Decimal('7.50')
&gt;&gt;&gt; ExtendedContext.scaleb(Decimal('7.50'), Decimal('3'))
Decimal('7.50E+3')
&gt;&gt;&gt; ExtendedContext.scaleb(1, 4)
Decimal('1E+4')
&gt;&gt;&gt; ExtendedContext.scaleb(Decimal(1), 4)
Decimal('1E+4')
&gt;&gt;&gt; ExtendedContext.scaleb(1, Decimal(4))
Decimal('1E+4')</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Context.shift">
    
  </a>
  <a name="shift">
    
  </a>
  <div class="functionHeader">
    
    def
    shift(self, a, b):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Returns a shifted copy of a, b times.

The coefficient of the result is a shifted copy of the digits
in the coefficient of the first operand.  The number of places
to shift is taken from the absolute value of the second operand,
with the shift being to the left if the second operand is
positive or to the right otherwise.  Digits shifted into the
coefficient are zeros.

&gt;&gt;&gt; ExtendedContext.shift(Decimal('34'), Decimal('8'))
Decimal('400000000')
&gt;&gt;&gt; ExtendedContext.shift(Decimal('12'), Decimal('9'))
Decimal('0')
&gt;&gt;&gt; ExtendedContext.shift(Decimal('123456789'), Decimal('-2'))
Decimal('1234567')
&gt;&gt;&gt; ExtendedContext.shift(Decimal('123456789'), Decimal('0'))
Decimal('123456789')
&gt;&gt;&gt; ExtendedContext.shift(Decimal('123456789'), Decimal('+2'))
Decimal('345678900')
&gt;&gt;&gt; ExtendedContext.shift(88888888, 2)
Decimal('888888800')
&gt;&gt;&gt; ExtendedContext.shift(Decimal(88888888), 2)
Decimal('888888800')
&gt;&gt;&gt; ExtendedContext.shift(88888888, Decimal(2))
Decimal('888888800')</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Context.sqrt">
    
  </a>
  <a name="sqrt">
    
  </a>
  <div class="functionHeader">
    
    def
    sqrt(self, a):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Square root of a non-negative number to context precision.

If the result must be inexact, it is rounded using the round-half-even
algorithm.

&gt;&gt;&gt; ExtendedContext.sqrt(Decimal('0'))
Decimal('0')
&gt;&gt;&gt; ExtendedContext.sqrt(Decimal('-0'))
Decimal('-0')
&gt;&gt;&gt; ExtendedContext.sqrt(Decimal('0.39'))
Decimal('0.624499800')
&gt;&gt;&gt; ExtendedContext.sqrt(Decimal('100'))
Decimal('10')
&gt;&gt;&gt; ExtendedContext.sqrt(Decimal('1'))
Decimal('1')
&gt;&gt;&gt; ExtendedContext.sqrt(Decimal('1.0'))
Decimal('1.0')
&gt;&gt;&gt; ExtendedContext.sqrt(Decimal('1.00'))
Decimal('1.0')
&gt;&gt;&gt; ExtendedContext.sqrt(Decimal('7'))
Decimal('2.64575131')
&gt;&gt;&gt; ExtendedContext.sqrt(Decimal('10'))
Decimal('3.16227766')
&gt;&gt;&gt; ExtendedContext.sqrt(2)
Decimal('1.41421356')
&gt;&gt;&gt; ExtendedContext.prec
9</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Context.subtract">
    
  </a>
  <a name="subtract">
    
  </a>
  <div class="functionHeader">
    
    def
    subtract(self, a, b):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Return the difference between the two operands.

&gt;&gt;&gt; ExtendedContext.subtract(Decimal('1.3'), Decimal('1.07'))
Decimal('0.23')
&gt;&gt;&gt; ExtendedContext.subtract(Decimal('1.3'), Decimal('1.30'))
Decimal('0.00')
&gt;&gt;&gt; ExtendedContext.subtract(Decimal('1.3'), Decimal('2.07'))
Decimal('-0.77')
&gt;&gt;&gt; ExtendedContext.subtract(8, 5)
Decimal('3')
&gt;&gt;&gt; ExtendedContext.subtract(Decimal(8), 5)
Decimal('3')
&gt;&gt;&gt; ExtendedContext.subtract(8, Decimal(5))
Decimal('3')</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Context.to_eng_string">
    
  </a>
  <a name="to_eng_string">
    
  </a>
  <div class="functionHeader">
    
    def
    to_eng_string(self, a):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Convert to a string, using engineering notation if an exponent is needed.

Engineering notation has an exponent which is a multiple of 3.  This
can leave up to 3 digits to the left of the decimal place and may
require the addition of either one or two trailing zeros.

The operation is not affected by the context.

&gt;&gt;&gt; ExtendedContext.to_eng_string(Decimal('123E+1'))
'1.23E+3'
&gt;&gt;&gt; ExtendedContext.to_eng_string(Decimal('123E+3'))
'123E+3'
&gt;&gt;&gt; ExtendedContext.to_eng_string(Decimal('123E-10'))
'12.3E-9'
&gt;&gt;&gt; ExtendedContext.to_eng_string(Decimal('-123E-12'))
'-123E-12'
&gt;&gt;&gt; ExtendedContext.to_eng_string(Decimal('7E-7'))
'700E-9'
&gt;&gt;&gt; ExtendedContext.to_eng_string(Decimal('7E+1'))
'70'
&gt;&gt;&gt; ExtendedContext.to_eng_string(Decimal('0E+1'))
'0.00E+3'</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Context.to_sci_string">
    
  </a>
  <a name="to_sci_string">
    
  </a>
  <div class="functionHeader">
    
    def
    to_sci_string(self, a):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Converts a number to a string, using scientific notation.

The operation is not affected by the context.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Context.to_integral_exact">
    
  </a>
  <a name="to_integral_exact">
    
  </a>
  <div class="functionHeader">
    
    def
    to_integral_exact(self, a):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Rounds to an integer.

When the operand has a negative exponent, the result is the same
as using the quantize() operation using the given operand as the
left-hand-operand, 1E+0 as the right-hand-operand, and the precision
of the operand as the precision setting; Inexact and Rounded flags
are allowed in this operation.  The rounding mode is taken from the
context.

&gt;&gt;&gt; ExtendedContext.to_integral_exact(Decimal('2.1'))
Decimal('2')
&gt;&gt;&gt; ExtendedContext.to_integral_exact(Decimal('100'))
Decimal('100')
&gt;&gt;&gt; ExtendedContext.to_integral_exact(Decimal('100.0'))
Decimal('100')
&gt;&gt;&gt; ExtendedContext.to_integral_exact(Decimal('101.5'))
Decimal('102')
&gt;&gt;&gt; ExtendedContext.to_integral_exact(Decimal('-101.5'))
Decimal('-102')
&gt;&gt;&gt; ExtendedContext.to_integral_exact(Decimal('10E+5'))
Decimal('1.0E+6')
&gt;&gt;&gt; ExtendedContext.to_integral_exact(Decimal('7.89E+77'))
Decimal('7.89E+77')
&gt;&gt;&gt; ExtendedContext.to_integral_exact(Decimal('-Inf'))
Decimal('-Infinity')</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pydecimal.Context.to_integral_value">
    
  </a>
  <a name="to_integral_value">
    
  </a>
  <div class="functionHeader">
    
    def
    to_integral_value(self, a):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Rounds to an integer.

When the operand has a negative exponent, the result is the same
as using the quantize() operation using the given operand as the
left-hand-operand, 1E+0 as the right-hand-operand, and the precision
of the operand as the precision setting, except that no flags will
be set.  The rounding mode is taken from the context.

&gt;&gt;&gt; ExtendedContext.to_integral_value(Decimal('2.1'))
Decimal('2')
&gt;&gt;&gt; ExtendedContext.to_integral_value(Decimal('100'))
Decimal('100')
&gt;&gt;&gt; ExtendedContext.to_integral_value(Decimal('100.0'))
Decimal('100')
&gt;&gt;&gt; ExtendedContext.to_integral_value(Decimal('101.5'))
Decimal('102')
&gt;&gt;&gt; ExtendedContext.to_integral_value(Decimal('-101.5'))
Decimal('-102')
&gt;&gt;&gt; ExtendedContext.to_integral_value(Decimal('10E+5'))
Decimal('1.0E+6')
&gt;&gt;&gt; ExtendedContext.to_integral_value(Decimal('7.89E+77'))
Decimal('7.89E+77')
&gt;&gt;&gt; ExtendedContext.to_integral_value(Decimal('-Inf'))
Decimal('-Infinity')</p></div>
  </div>
</div>

      </div>
      <address>
        <a href="index.html">API Documentation</a> for Python3.8, generated by <a href="https://github.com/twisted/pydoctor/">pydoctor</a> 20.7.1 at 2020-11-24 05:11:37.
      </address>

    </div>

    <script src="pydoctor.js" type="text/javascript"></script>

  </body>
</html>