<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
          "DTD/xhtml1-strict.dtd">
<html>
  <head>
    <title>Lib.logging.handlers.QueueHandler : API documentation</title>

    <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
    <link rel="stylesheet" type="text/css" href="bootstrap.min.css" />
    <link rel="stylesheet" type="text/css" href="apidocs.css" />
  </head>
  <body>

    <nav class="navbar navbar-default">
      <div class="container">
        <div class="navbar-header">
          <a class="navbar-brand" href="index.html">
            Python3.8 API Documentation
          </a>
        </div>
      </div>
    </nav>

    <div id="showPrivate">
      <button class="btn btn-link" onclick="togglePrivate()">Toggle Private API</button>
    </div>

    <div class="container">

      <div class="page-header">
        <h1 class="class"><code><a href="Lib.html" class="code" data-type="Package">Lib</a>.<a href="Lib.logging.html" class="code" data-type="Package">logging</a>.<a href="Lib.logging.handlers.html" class="code" data-type="Module">handlers</a>.<a href="Lib.logging.handlers.QueueHandler.html" class="code" data-type="Class">QueueHandler</a></code></h1>
      </div>

      <div class="categoryHeader">
        class documentation
      </div>

      <div class="extrasDocstring">
        <p><code><span class="py-keyword">class</span> Lib.logging.handlers.QueueHandler(<span title="logging.Handler">logging.Handler</span>):</code></p>
        <p><a href="classIndex.html#Lib.logging.handlers.QueueHandler">View In Hierarchy</a></p>
      </div>

      <div class="moduleDocstring">
        <div><p class="pre">This handler sends events to a queue. Typically, it would be used together
with a multiprocessing Queue to centralise logging to file in one process
(in a multi-process application), so as to avoid file write contention
between processes.

This code is new in Python 3.2, but this class can be copy pasted into
user code for use with earlier Python versions.</p></div>
      </div>

      <div id="splitTables">
        <table class="children sortable" id="id3061">
  
  <tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.logging.handlers.QueueHandler.html#__init__" class="code" data-type="Method">__init__</a></td>
    <td><span>Initialise an instance, using the passed queue.</span></td>
  </tr><tr class="instancevariable">
    
    <td>Instance Variable</td>
    <td><a href="Lib.logging.handlers.QueueHandler.html#queue" class="code" data-type="Instance Variable">queue</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.logging.handlers.QueueHandler.html#enqueue" class="code" data-type="Method">enqueue</a></td>
    <td><span>Enqueue a record.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.logging.handlers.QueueHandler.html#prepare" class="code" data-type="Method">prepare</a></td>
    <td><span>Prepares a record for queuing. The object returned by this method is enqueued.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.logging.handlers.QueueHandler.html#emit" class="code" data-type="Method">emit</a></td>
    <td><span>Emit a record.</span></td>
  </tr>
</table>
        

          
      </div>

      <div id="childList">

        <div class="basemethod">
  
  <a name="Lib.logging.handlers.QueueHandler.__init__">
    
  </a>
  <a name="__init__">
    
  </a>
  <div class="functionHeader">
    
    def
    __init__(self, queue):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Initialise an instance, using the passed queue.</p></div>
  </div>
</div><div class="baseinstancevariable">
  
  <a name="Lib.logging.handlers.QueueHandler.queue">
    
  </a>
  <a name="queue">
    
  </a>
  <div class="functionHeader">
    queue =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.logging.handlers.QueueHandler.enqueue">
    
  </a>
  <a name="enqueue">
    
  </a>
  <div class="functionHeader">
    
    def
    enqueue(self, record):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Enqueue a record.

The base implementation uses put_nowait. You may want to override
this method if you want to use blocking, timeouts or custom queue
implementations.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.logging.handlers.QueueHandler.prepare">
    
  </a>
  <a name="prepare">
    
  </a>
  <div class="functionHeader">
    
    def
    prepare(self, record):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Prepares a record for queuing. The object returned by this method is
enqueued.

The base implementation formats the record to merge the message
and arguments, and removes unpickleable items from the record
in-place.

You might want to override this method if you want to convert
the record to a dict or JSON string, or send a modified copy
of the record while leaving the original intact.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.logging.handlers.QueueHandler.emit">
    
  </a>
  <a name="emit">
    
  </a>
  <div class="functionHeader">
    
    def
    emit(self, record):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Emit a record.

Writes the LogRecord to the queue, preparing it for pickling first.</p></div>
  </div>
</div>

      </div>
      <address>
        <a href="index.html">API Documentation</a> for Python3.8, generated by <a href="https://github.com/twisted/pydoctor/">pydoctor</a> 20.7.1 at 2020-11-24 05:40:36.
      </address>

    </div>

    <script src="pydoctor.js" type="text/javascript"></script>

  </body>
</html>