<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
          "DTD/xhtml1-strict.dtd">
<html>
  <head>
    <title>Lib.test.support.socket_helper : API documentation</title>

    <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
    <link rel="stylesheet" type="text/css" href="bootstrap.min.css" />
    <link rel="stylesheet" type="text/css" href="apidocs.css" />
  </head>
  <body>

    <nav class="navbar navbar-default">
      <div class="container">
        <div class="navbar-header">
          <a class="navbar-brand" href="index.html">
            Python3.8 API Documentation
          </a>
        </div>
      </div>
    </nav>

    <div id="showPrivate">
      <button class="btn btn-link" onclick="togglePrivate()">Toggle Private API</button>
    </div>

    <div class="container">

      <div class="page-header">
        <h1 class="module"><code><a href="Lib.html" class="code" data-type="Package">Lib</a>.<a href="Lib.test.html" class="code" data-type="Package">test</a>.<a href="Lib.test.support.html" class="code" data-type="Package">support</a>.<a href="Lib.test.support.socket_helper.html" class="code" data-type="Module">socket_helper</a></code></h1>
      </div>

      <div class="categoryHeader">
        module documentation
      </div>

      <div class="extrasDocstring">
        
        <p></p>
      </div>

      <div class="moduleDocstring">
        <div class="undocumented">Undocumented</div>
      </div>

      <div id="splitTables">
        <table class="children sortable" id="id4178">
  
  <tr class="variable">
    
    <td>Variable</td>
    <td><a href="Lib.test.support.socket_helper.html#HOST" class="code" data-type="Variable">HOST</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="variable">
    
    <td>Variable</td>
    <td><a href="Lib.test.support.socket_helper.html#HOSTv4" class="code" data-type="Variable">HOSTv4</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="variable">
    
    <td>Variable</td>
    <td><a href="Lib.test.support.socket_helper.html#HOSTv6" class="code" data-type="Variable">HOSTv6</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><a href="Lib.test.support.socket_helper.html#find_unused_port" class="code" data-type="Function">find_unused_port</a></td>
    <td><span class="undocumented">No summary</span></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><a href="Lib.test.support.socket_helper.html#bind_port" class="code" data-type="Function">bind_port</a></td>
    <td><span class="undocumented">No summary</span></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><a href="Lib.test.support.socket_helper.html#bind_unix_socket" class="code" data-type="Function">bind_unix_socket</a></td>
    <td><span>Bind a unix socket, raising SkipTest if PermissionError is raised.</span></td>
  </tr><tr class="variable">
    
    <td>Variable</td>
    <td><a href="Lib.test.support.socket_helper.html#IPV6_ENABLED" class="code" data-type="Variable">IPV6_ENABLED</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><a href="Lib.test.support.socket_helper.html#skip_unless_bind_unix_socket" class="code" data-type="Function">skip_unless_bind_unix_socket</a></td>
    <td><span>Decorator for tests requiring a functional bind() for unix sockets.</span></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><a href="Lib.test.support.socket_helper.html#get_socket_conn_refused_errs" class="code" data-type="Function">get_socket_conn_refused_errs</a></td>
    <td><span>Get the different socket error numbers ('errno') which can be received when a connection is refused.</span></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><a href="Lib.test.support.socket_helper.html#transient_internet" class="code" data-type="Function">transient_internet</a></td>
    <td><span>Return a context manager that raises ResourceDenied when various issues with the Internet connection manifest themselves as exceptions.</span></td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><a href="Lib.test.support.socket_helper.html#_is_ipv6_enabled" class="code" data-type="Function">_is_ipv6_enabled</a></td>
    <td><span>Check whether IPv6 is enabled on this host.</span></td>
  </tr><tr class="variable private">
    
    <td>Variable</td>
    <td><a href="Lib.test.support.socket_helper.html#_bind_nix_socket_error" class="code" data-type="Variable">_bind_nix_socket_error</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="variable private">
    
    <td>Variable</td>
    <td><a href="Lib.test.support.socket_helper.html#_NOT_SET" class="code" data-type="Variable">_NOT_SET</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr>
</table>
        

          
      </div>

      <div id="childList">

        <div class="basevariable">
  
  <a name="Lib.test.support.socket_helper.HOST">
    
  </a>
  <a name="HOST">
    
  </a>
  <div class="functionHeader">
    HOST =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div> (type: <code>str</code>)
  </div>
</div><div class="basevariable">
  
  <a name="Lib.test.support.socket_helper.HOSTv4">
    
  </a>
  <a name="HOSTv4">
    
  </a>
  <div class="functionHeader">
    HOSTv4 =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div> (type: <code>str</code>)
  </div>
</div><div class="basevariable">
  
  <a name="Lib.test.support.socket_helper.HOSTv6">
    
  </a>
  <a name="HOSTv6">
    
  </a>
  <div class="functionHeader">
    HOSTv6 =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div> (type: <code>str</code>)
  </div>
</div><div class="basefunction">
  
  <a name="Lib.test.support.socket_helper.find_unused_port">
    
  </a>
  <a name="find_unused_port">
    
  </a>
  <div class="functionHeader">
    
    def
    find_unused_port(family=socket.AF_INET, socktype=socket.SOCK_STREAM):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Returns an unused port that should be suitable for binding.  This is
achieved by creating a temporary socket with the same family and type as
the 'sock' parameter (default is AF_INET, SOCK_STREAM), and binding it to
the specified host address (defaults to 0.0.0.0) with the port set to 0,
eliciting an unused ephemeral port from the OS.  The temporary socket is
then closed and deleted, and the ephemeral port is returned.

Either this method or bind_port() should be used for any tests where a
server socket needs to be bound to a particular port for the duration of
the test.  Which one to use depends on whether the calling code is creating
a python socket, or if an unused port needs to be provided in a constructor
or passed to an external program (i.e. the -accept argument to openssl's
s_server mode).  Always prefer bind_port() over find_unused_port() where
possible.  Hard coded ports should *NEVER* be used.  As soon as a server
socket is bound to a hard coded port, the ability to run multiple instances
of the test simultaneously on the same host is compromised, which makes the
test a ticking time bomb in a buildbot environment. On Unix buildbots, this
may simply manifest as a failed test, which can be recovered from without
intervention in most cases, but on Windows, the entire python process can
completely and utterly wedge, requiring someone to log in to the buildbot
and manually kill the affected process.

(This is easy to reproduce on Windows, unfortunately, and can be traced to
the SO_REUSEADDR socket option having different semantics on Windows versus
Unix/Linux.  On Unix, you can't have two AF_INET SOCK_STREAM sockets bind,
listen and then accept connections on identical host/ports.  An EADDRINUSE
OSError will be raised at some point (depending on the platform and
the order bind and listen were called on each socket).

However, on Windows, if SO_REUSEADDR is set on the sockets, no EADDRINUSE
will ever be raised when attempting to bind two identical host/ports. When
accept() is called on each socket, the second caller's process will steal
the port from the first caller, leaving them both in an awkwardly wedged
state where they'll no longer respond to any signals or graceful kills, and
must be forcibly killed via OpenProcess()/TerminateProcess().

The solution on Windows is to use the SO_EXCLUSIVEADDRUSE socket option
instead of SO_REUSEADDR, which effectively affords the same semantics as
SO_REUSEADDR on Unix.  Given the propensity of Unix developers in the Open
Source world compared to Windows ones, this is a common mistake.  A quick
look over OpenSSL's 0.9.8g source shows that they use SO_REUSEADDR when
openssl.exe is called with the 's_server' option, for example. See
http://bugs.python.org/issue2550 for more info.  The following site also
has a very thorough description about the implications of both REUSEADDR
and EXCLUSIVEADDRUSE on Windows:
http://msdn2.microsoft.com/en-us/library/ms740621(VS.85).aspx)

XXX: although this approach is a vast improvement on previous attempts to
elicit unused ports, it rests heavily on the assumption that the ephemeral
port returned to us by the OS won't immediately be dished back out to some
other process when we close and delete our temporary socket but before our
calling code has a chance to bind the returned port.  We can deal with this
issue if/when we come across it.</p></div>
  </div>
</div><div class="basefunction">
  
  <a name="Lib.test.support.socket_helper.bind_port">
    
  </a>
  <a name="bind_port">
    
  </a>
  <div class="functionHeader">
    
    def
    bind_port(sock, host=HOST):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Bind the socket to a free port and return the port number.  Relies on
ephemeral ports in order to ensure we are using an unbound port.  This is
important as many tests may be running simultaneously, especially in a
buildbot environment.  This method raises an exception if the sock.family
is AF_INET and sock.type is SOCK_STREAM, *and* the socket has SO_REUSEADDR
or SO_REUSEPORT set on it.  Tests should *never* set these socket options
for TCP/IP sockets.  The only case for setting these options is testing
multicasting via multiple UDP sockets.

Additionally, if the SO_EXCLUSIVEADDRUSE socket option is available (i.e.
on Windows), it will be set on the socket.  This will prevent anyone else
from bind()'ing to our host/port for the duration of the test.</p></div>
  </div>
</div><div class="basefunction">
  
  <a name="Lib.test.support.socket_helper.bind_unix_socket">
    
  </a>
  <a name="bind_unix_socket">
    
  </a>
  <div class="functionHeader">
    
    def
    bind_unix_socket(sock, addr):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Bind a unix socket, raising SkipTest if PermissionError is raised.</p></div>
  </div>
</div><div class="basefunction private">
  
  <a name="Lib.test.support.socket_helper._is_ipv6_enabled">
    
  </a>
  <a name="_is_ipv6_enabled">
    
  </a>
  <div class="functionHeader">
    
    def
    _is_ipv6_enabled():
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Check whether IPv6 is enabled on this host.</p></div>
  </div>
</div><div class="basevariable">
  
  <a name="Lib.test.support.socket_helper.IPV6_ENABLED">
    
  </a>
  <a name="IPV6_ENABLED">
    
  </a>
  <div class="functionHeader">
    IPV6_ENABLED =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basevariable private">
  
  <a name="Lib.test.support.socket_helper._bind_nix_socket_error">
    
  </a>
  <a name="_bind_nix_socket_error">
    
  </a>
  <div class="functionHeader">
    _bind_nix_socket_error =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basefunction">
  
  <a name="Lib.test.support.socket_helper.skip_unless_bind_unix_socket">
    
  </a>
  <a name="skip_unless_bind_unix_socket">
    
  </a>
  <div class="functionHeader">
    
    def
    skip_unless_bind_unix_socket(test):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Decorator for tests requiring a functional bind() for unix sockets.</p></div>
  </div>
</div><div class="basefunction">
  
  <a name="Lib.test.support.socket_helper.get_socket_conn_refused_errs">
    
  </a>
  <a name="get_socket_conn_refused_errs">
    
  </a>
  <div class="functionHeader">
    
    def
    get_socket_conn_refused_errs():
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Get the different socket error numbers ('errno') which can be received
when a connection is refused.</p></div>
  </div>
</div><div class="basevariable private">
  
  <a name="Lib.test.support.socket_helper._NOT_SET">
    
  </a>
  <a name="_NOT_SET">
    
  </a>
  <div class="functionHeader">
    _NOT_SET =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basefunction">
  
  <a name="Lib.test.support.socket_helper.transient_internet">
    
  </a>
  <a name="transient_internet">
    
  </a>
  <div class="functionHeader">
    @contextlib.contextmanager<br />
    def
    transient_internet(resource_name):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Return a context manager that raises ResourceDenied when various issues
with the Internet connection manifest themselves as exceptions.</p></div>
  </div>
</div>

      </div>
      <address>
        <a href="index.html">API Documentation</a> for Python3.8, generated by <a href="https://github.com/twisted/pydoctor/">pydoctor</a> 20.7.1 at 2020-11-24 05:02:55.
      </address>

    </div>

    <script src="pydoctor.js" type="text/javascript"></script>

  </body>
</html>