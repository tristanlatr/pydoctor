<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
          "DTD/xhtml1-strict.dtd">
<html>
  <head>
    <title>Lib.logging.handlers.SocketHandler : API documentation</title>

    <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
    <link rel="stylesheet" type="text/css" href="bootstrap.min.css" />
    <link rel="stylesheet" type="text/css" href="apidocs.css" />
  </head>
  <body>

    <nav class="navbar navbar-default">
      <div class="container">
        <div class="navbar-header">
          <a class="navbar-brand" href="index.html">
            Python3.8 API Documentation
          </a>
        </div>
      </div>
    </nav>

    <div id="showPrivate">
      <button class="btn btn-link" onclick="togglePrivate()">Toggle Private API</button>
    </div>

    <div class="container">

      <div class="page-header">
        <h1 class="class"><code><a href="Lib.html" class="code" data-type="Package">Lib</a>.<a href="Lib.logging.html" class="code" data-type="Package">logging</a>.<a href="Lib.logging.handlers.html" class="code" data-type="Module">handlers</a>.<a href="Lib.logging.handlers.SocketHandler.html" class="code" data-type="Class">SocketHandler</a></code></h1>
      </div>

      <div class="categoryHeader">
        class documentation
      </div>

      <div class="extrasDocstring">
        <p><code><span class="py-keyword">class</span> Lib.logging.handlers.SocketHandler(<span title="logging.Handler">logging.Handler</span>):</code></p><p>Known subclasses: <a href="Lib.logging.handlers.DatagramHandler.html" class="code" data-type="Class">Lib.logging.handlers.DatagramHandler</a></p>
        <p><a href="classIndex.html#Lib.logging.handlers.SocketHandler">View In Hierarchy</a></p>
      </div>

      <div class="moduleDocstring">
        <div><p class="pre">A handler class which writes logging records, in pickle format, to
a streaming socket. The socket is kept open across logging calls.
If the peer resets it, an attempt is made to reconnect on the next call.
The pickle which is sent is that of the LogRecord's attribute dictionary
(__dict__), so that the receiver does not need to have the logging module
installed in order to process the logging event.

To unpickle the record at the receiving end into a LogRecord, use the
makeLogRecord function.</p></div>
      </div>

      <div id="splitTables">
        <table class="children sortable" id="id3051">
  
  <tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.logging.handlers.SocketHandler.html#__init__" class="code" data-type="Method">__init__</a></td>
    <td><span>Initializes the handler with a specific host address and port.</span></td>
  </tr><tr class="instancevariable">
    
    <td>Instance Variable</td>
    <td><a href="Lib.logging.handlers.SocketHandler.html#host" class="code" data-type="Instance Variable">host</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="instancevariable">
    
    <td>Instance Variable</td>
    <td><a href="Lib.logging.handlers.SocketHandler.html#port" class="code" data-type="Instance Variable">port</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="instancevariable">
    
    <td>Instance Variable</td>
    <td><a href="Lib.logging.handlers.SocketHandler.html#address" class="code" data-type="Instance Variable">address</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="instancevariable">
    
    <td>Instance Variable</td>
    <td><a href="Lib.logging.handlers.SocketHandler.html#sock" class="code" data-type="Instance Variable">sock</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="instancevariable">
    
    <td>Instance Variable</td>
    <td><a href="Lib.logging.handlers.SocketHandler.html#closeOnError" class="code" data-type="Instance Variable">closeOnError</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="instancevariable">
    
    <td>Instance Variable</td>
    <td><a href="Lib.logging.handlers.SocketHandler.html#retryTime" class="code" data-type="Instance Variable">retryTime</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="instancevariable">
    
    <td>Instance Variable</td>
    <td><a href="Lib.logging.handlers.SocketHandler.html#retryStart" class="code" data-type="Instance Variable">retryStart</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="instancevariable">
    
    <td>Instance Variable</td>
    <td><a href="Lib.logging.handlers.SocketHandler.html#retryMax" class="code" data-type="Instance Variable">retryMax</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="instancevariable">
    
    <td>Instance Variable</td>
    <td><a href="Lib.logging.handlers.SocketHandler.html#retryFactor" class="code" data-type="Instance Variable">retryFactor</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.logging.handlers.SocketHandler.html#makeSocket" class="code" data-type="Method">makeSocket</a></td>
    <td><span>A factory method which allows subclasses to define the precise type of socket they want.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.logging.handlers.SocketHandler.html#createSocket" class="code" data-type="Method">createSocket</a></td>
    <td><span>Try to create a socket, using an exponential backoff with a max retry time. Thanks to Robert Olson for the original patch (SF #815911) which has been slightly refactored.</span></td>
  </tr><tr class="instancevariable">
    
    <td>Instance Variable</td>
    <td><a href="Lib.logging.handlers.SocketHandler.html#retryPeriod" class="code" data-type="Instance Variable">retryPeriod</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.logging.handlers.SocketHandler.html#send" class="code" data-type="Method">send</a></td>
    <td><span>Send a pickled string to the socket.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.logging.handlers.SocketHandler.html#makePickle" class="code" data-type="Method">makePickle</a></td>
    <td><span>Pickles the record in binary format with a length prefix, and returns it ready for transmission across the socket.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.logging.handlers.SocketHandler.html#handleError" class="code" data-type="Method">handleError</a></td>
    <td><span>Handle an error during logging.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.logging.handlers.SocketHandler.html#emit" class="code" data-type="Method">emit</a></td>
    <td><span>Emit a record.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.logging.handlers.SocketHandler.html#close" class="code" data-type="Method">close</a></td>
    <td><span>Closes the socket.</span></td>
  </tr>
</table>
        

          
      </div>

      <div id="childList">

        <div class="basemethod">
  
  <a name="Lib.logging.handlers.SocketHandler.__init__">
    
  </a>
  <a name="__init__">
    
  </a>
  <div class="functionHeader">
    
    def
    __init__(self, host, port):
    
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overridden in <a href="Lib.logging.handlers.DatagramHandler.html" class="code" data-type="Class">Lib.logging.handlers.DatagramHandler</a></div>
    
    <div><p class="pre">Initializes the handler with a specific host address and port.

When the attribute *closeOnError* is set to True - if a socket error
occurs, the socket is silently closed and then reopened on the next
logging call.</p></div>
  </div>
</div><div class="baseinstancevariable">
  
  <a name="Lib.logging.handlers.SocketHandler.host">
    
  </a>
  <a name="host">
    
  </a>
  <div class="functionHeader">
    host =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="baseinstancevariable">
  
  <a name="Lib.logging.handlers.SocketHandler.port">
    
  </a>
  <a name="port">
    
  </a>
  <div class="functionHeader">
    port =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="baseinstancevariable">
  
  <a name="Lib.logging.handlers.SocketHandler.address">
    
  </a>
  <a name="address">
    
  </a>
  <div class="functionHeader">
    address =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="baseinstancevariable">
  
  <a name="Lib.logging.handlers.SocketHandler.sock">
    
  </a>
  <a name="sock">
    
  </a>
  <div class="functionHeader">
    sock =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="baseinstancevariable">
  
  <a name="Lib.logging.handlers.SocketHandler.closeOnError">
    
  </a>
  <a name="closeOnError">
    
  </a>
  <div class="functionHeader">
    closeOnError =
    
  </div>
  <div class="functionBody">
    <div class="interfaceinfo">overridden in <a href="Lib.logging.handlers.DatagramHandler.html" class="code" data-type="Class">Lib.logging.handlers.DatagramHandler</a></div>
    <div class="undocumented">Undocumented</div> (type: <code>bool</code>)
  </div>
</div><div class="baseinstancevariable">
  
  <a name="Lib.logging.handlers.SocketHandler.retryTime">
    
  </a>
  <a name="retryTime">
    
  </a>
  <div class="functionHeader">
    retryTime =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="baseinstancevariable">
  
  <a name="Lib.logging.handlers.SocketHandler.retryStart">
    
  </a>
  <a name="retryStart">
    
  </a>
  <div class="functionHeader">
    retryStart =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div> (type: <code>float</code>)
  </div>
</div><div class="baseinstancevariable">
  
  <a name="Lib.logging.handlers.SocketHandler.retryMax">
    
  </a>
  <a name="retryMax">
    
  </a>
  <div class="functionHeader">
    retryMax =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div> (type: <code>float</code>)
  </div>
</div><div class="baseinstancevariable">
  
  <a name="Lib.logging.handlers.SocketHandler.retryFactor">
    
  </a>
  <a name="retryFactor">
    
  </a>
  <div class="functionHeader">
    retryFactor =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div> (type: <code>float</code>)
  </div>
</div><div class="basemethod">
  
  <a name="Lib.logging.handlers.SocketHandler.makeSocket">
    
  </a>
  <a name="makeSocket">
    
  </a>
  <div class="functionHeader">
    
    def
    makeSocket(self, timeout=1):
    
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overridden in <a href="Lib.logging.handlers.DatagramHandler.html" class="code" data-type="Class">Lib.logging.handlers.DatagramHandler</a></div>
    
    <div><p class="pre">A factory method which allows subclasses to define the precise
type of socket they want.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.logging.handlers.SocketHandler.createSocket">
    
  </a>
  <a name="createSocket">
    
  </a>
  <div class="functionHeader">
    
    def
    createSocket(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Try to create a socket, using an exponential backoff with
a max retry time. Thanks to Robert Olson for the original patch
(SF #815911) which has been slightly refactored.</p></div>
  </div>
</div><div class="baseinstancevariable">
  
  <a name="Lib.logging.handlers.SocketHandler.retryPeriod">
    
  </a>
  <a name="retryPeriod">
    
  </a>
  <div class="functionHeader">
    retryPeriod =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.logging.handlers.SocketHandler.send">
    
  </a>
  <a name="send">
    
  </a>
  <div class="functionHeader">
    
    def
    send(self, s):
    
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overridden in <a href="Lib.logging.handlers.DatagramHandler.html" class="code" data-type="Class">Lib.logging.handlers.DatagramHandler</a></div>
    
    <div><p class="pre">Send a pickled string to the socket.

This function allows for partial sends which can happen when the
network is busy.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.logging.handlers.SocketHandler.makePickle">
    
  </a>
  <a name="makePickle">
    
  </a>
  <div class="functionHeader">
    
    def
    makePickle(self, record):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Pickles the record in binary format with a length prefix, and
returns it ready for transmission across the socket.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.logging.handlers.SocketHandler.handleError">
    
  </a>
  <a name="handleError">
    
  </a>
  <div class="functionHeader">
    
    def
    handleError(self, record):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Handle an error during logging.

An error has occurred during logging. Most likely cause -
connection lost. Close the socket so that we can retry on the
next event.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.logging.handlers.SocketHandler.emit">
    
  </a>
  <a name="emit">
    
  </a>
  <div class="functionHeader">
    
    def
    emit(self, record):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Emit a record.

Pickles the record and writes it to the socket in binary format.
If there is an error with the socket, silently drop the packet.
If there was a problem with the socket, re-establishes the
socket.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.logging.handlers.SocketHandler.close">
    
  </a>
  <a name="close">
    
  </a>
  <div class="functionHeader">
    
    def
    close(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Closes the socket.</p></div>
  </div>
</div>

      </div>
      <address>
        <a href="index.html">API Documentation</a> for Python3.8, generated by <a href="https://github.com/twisted/pydoctor/">pydoctor</a> 20.7.1 at 2020-11-24 05:11:37.
      </address>

    </div>

    <script src="pydoctor.js" type="text/javascript"></script>

  </body>
</html>