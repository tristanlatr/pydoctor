<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
          "DTD/xhtml1-strict.dtd">
<html>
  <head>
    <title>Lib.zipimport.zipimporter : API documentation</title>

    <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
    <link rel="stylesheet" type="text/css" href="bootstrap.min.css" />
    <link rel="stylesheet" type="text/css" href="apidocs.css" />
  </head>
  <body>

    <nav class="navbar navbar-default">
      <div class="container">
        <div class="navbar-header">
          <a class="navbar-brand" href="index.html">
            Python3.8 API Documentation
          </a>
        </div>
      </div>
    </nav>

    <div id="showPrivate">
      <button class="btn btn-link" onclick="togglePrivate()">Toggle Private API</button>
    </div>

    <div class="container">

      <div class="page-header">
        <h1 class="class"><code><a href="Lib.html" class="code" data-type="Package">Lib</a>.<a href="Lib.zipimport.html" class="code" data-type="Module">zipimport</a>.<a href="Lib.zipimport.zipimporter.html" class="code" data-type="Class">zipimporter</a></code></h1>
      </div>

      <div class="categoryHeader">
        class documentation
      </div>

      <div class="extrasDocstring">
        <p><code><span class="py-keyword">class</span> Lib.zipimport.zipimporter(<span title="_frozen_importlib_external._LoaderBasics">_bootstrap_external._LoaderBasics</span>):</code></p>
        <p><a href="classIndex.html#Lib.zipimport.zipimporter">View In Hierarchy</a></p>
      </div>

      <div class="moduleDocstring">
        <div><p class="pre">zipimporter(archivepath) -&gt; zipimporter object

Create a new zipimporter instance. 'archivepath' must be a path to
a zipfile, or to a specific path inside a zipfile. For example, it can be
'/tmp/myimport.zip', or '/tmp/myimport.zip/mydirectory', if mydirectory is a
valid directory inside the archive.

'ZipImportError is raised if 'archivepath' doesn't point to a valid Zip
archive.

The 'archive' attribute of zipimporter objects contains the name of the
zipfile targeted.</p></div>
      </div>

      <div id="splitTables">
        <table class="children sortable" id="id12234">
  
  <tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.zipimport.zipimporter.html#__init__" class="code" data-type="Method">__init__</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="instancevariable">
    
    <td>Instance Variable</td>
    <td><a href="Lib.zipimport.zipimporter.html#archive" class="code" data-type="Instance Variable">archive</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="instancevariable">
    
    <td>Instance Variable</td>
    <td><a href="Lib.zipimport.zipimporter.html#prefix" class="code" data-type="Instance Variable">prefix</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.zipimport.zipimporter.html#find_loader" class="code" data-type="Method">find_loader</a></td>
    <td><span>find_loader(fullname, path=None) -&gt; self, str or None.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.zipimport.zipimporter.html#find_module" class="code" data-type="Method">find_module</a></td>
    <td><span>find_module(fullname, path=None) -&gt; self or None.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.zipimport.zipimporter.html#find_spec" class="code" data-type="Method">find_spec</a></td>
    <td><span>Create a ModuleSpec for the specified module.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.zipimport.zipimporter.html#get_code" class="code" data-type="Method">get_code</a></td>
    <td><span>get_code(fullname) -&gt; code object.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.zipimport.zipimporter.html#get_data" class="code" data-type="Method">get_data</a></td>
    <td><span>get_data(pathname) -&gt; string with file data.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.zipimport.zipimporter.html#get_filename" class="code" data-type="Method">get_filename</a></td>
    <td><span>get_filename(fullname) -&gt; filename string.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.zipimport.zipimporter.html#get_source" class="code" data-type="Method">get_source</a></td>
    <td><span>get_source(fullname) -&gt; source string.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.zipimport.zipimporter.html#is_package" class="code" data-type="Method">is_package</a></td>
    <td><span>is_package(fullname) -&gt; bool.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.zipimport.zipimporter.html#load_module" class="code" data-type="Method">load_module</a></td>
    <td><span>load_module(fullname) -&gt; module.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.zipimport.zipimporter.html#get_resource_reader" class="code" data-type="Method">get_resource_reader</a></td>
    <td><span>Return the ResourceReader for a package in a zip file.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.zipimport.zipimporter.html#__repr__" class="code" data-type="Method">__repr__</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="instancevariable private">
    
    <td>Instance Variable</td>
    <td><a href="Lib.zipimport.zipimporter.html#_files" class="code" data-type="Instance Variable">_files</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr>
</table>
        

          
      </div>

      <div id="childList">

        <div class="basemethod">
  
  <a name="Lib.zipimport.zipimporter.__init__">
    
  </a>
  <a name="__init__">
    
  </a>
  <div class="functionHeader">
    
    def
    __init__(self, path):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="baseinstancevariable private">
  
  <a name="Lib.zipimport.zipimporter._files">
    
  </a>
  <a name="_files">
    
  </a>
  <div class="functionHeader">
    _files =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="baseinstancevariable">
  
  <a name="Lib.zipimport.zipimporter.archive">
    
  </a>
  <a name="archive">
    
  </a>
  <div class="functionHeader">
    archive =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="baseinstancevariable">
  
  <a name="Lib.zipimport.zipimporter.prefix">
    
  </a>
  <a name="prefix">
    
  </a>
  <div class="functionHeader">
    prefix =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.zipimport.zipimporter.find_loader">
    
  </a>
  <a name="find_loader">
    
  </a>
  <div class="functionHeader">
    
    def
    find_loader(self, fullname, path=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">find_loader(fullname, path=None) -&gt; self, str or None.

Search for a module specified by 'fullname'. 'fullname' must be the
fully qualified (dotted) module name. It returns the zipimporter
instance itself if the module was found, a string containing the
full path name if it's possibly a portion of a namespace package,
or None otherwise. The optional 'path' argument is ignored -- it's
there for compatibility with the importer protocol.

Deprecated since Python 3.10. Use find_spec() instead.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.zipimport.zipimporter.find_module">
    
  </a>
  <a name="find_module">
    
  </a>
  <div class="functionHeader">
    
    def
    find_module(self, fullname, path=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">find_module(fullname, path=None) -&gt; self or None.

Search for a module specified by 'fullname'. 'fullname' must be the
fully qualified (dotted) module name. It returns the zipimporter
instance itself if the module was found, or None if it wasn't.
The optional 'path' argument is ignored -- it's there for compatibility
with the importer protocol.

Deprecated since Python 3.10. Use find_spec() instead.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.zipimport.zipimporter.find_spec">
    
  </a>
  <a name="find_spec">
    
  </a>
  <div class="functionHeader">
    
    def
    find_spec(self, fullname, target=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Create a ModuleSpec for the specified module.

Returns None if the module cannot be found.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.zipimport.zipimporter.get_code">
    
  </a>
  <a name="get_code">
    
  </a>
  <div class="functionHeader">
    
    def
    get_code(self, fullname):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">get_code(fullname) -&gt; code object.

Return the code object for the specified module. Raise ZipImportError
if the module couldn't be found.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.zipimport.zipimporter.get_data">
    
  </a>
  <a name="get_data">
    
  </a>
  <div class="functionHeader">
    
    def
    get_data(self, pathname):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">get_data(pathname) -&gt; string with file data.

Return the data associated with 'pathname'. Raise OSError if
the file wasn't found.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.zipimport.zipimporter.get_filename">
    
  </a>
  <a name="get_filename">
    
  </a>
  <div class="functionHeader">
    
    def
    get_filename(self, fullname):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">get_filename(fullname) -&gt; filename string.

Return the filename for the specified module.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.zipimport.zipimporter.get_source">
    
  </a>
  <a name="get_source">
    
  </a>
  <div class="functionHeader">
    
    def
    get_source(self, fullname):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">get_source(fullname) -&gt; source string.

Return the source code for the specified module. Raise ZipImportError
if the module couldn't be found, return None if the archive does
contain the module, but has no source for it.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.zipimport.zipimporter.is_package">
    
  </a>
  <a name="is_package">
    
  </a>
  <div class="functionHeader">
    
    def
    is_package(self, fullname):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">is_package(fullname) -&gt; bool.

Return True if the module specified by fullname is a package.
Raise ZipImportError if the module couldn't be found.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.zipimport.zipimporter.load_module">
    
  </a>
  <a name="load_module">
    
  </a>
  <div class="functionHeader">
    
    def
    load_module(self, fullname):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">load_module(fullname) -&gt; module.

Load the module specified by 'fullname'. 'fullname' must be the
fully qualified (dotted) module name. It returns the imported
module, or raises ZipImportError if it wasn't found.

Deprecated since Python 3.10. use exec_module() instead.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.zipimport.zipimporter.get_resource_reader">
    
  </a>
  <a name="get_resource_reader">
    
  </a>
  <div class="functionHeader">
    
    def
    get_resource_reader(self, fullname):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Return the ResourceReader for a package in a zip file.

If 'fullname' is a package within the zip file, return the
'ResourceReader' object for the package.  Otherwise return None.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.zipimport.zipimporter.__repr__">
    
  </a>
  <a name="__repr__">
    
  </a>
  <div class="functionHeader">
    
    def
    __repr__(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div class="undocumented">Undocumented</div>
  </div>
</div>

      </div>
      <address>
        <a href="index.html">API Documentation</a> for Python3.8, generated by <a href="https://github.com/twisted/pydoctor/">pydoctor</a> 20.7.1 at 2020-11-24 05:11:37.
      </address>

    </div>

    <script src="pydoctor.js" type="text/javascript"></script>

  </body>
</html>