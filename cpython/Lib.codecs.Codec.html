<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
          "DTD/xhtml1-strict.dtd">
<html>
  <head>
    <title>Lib.codecs.Codec : API documentation</title>

    <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
    <link rel="stylesheet" type="text/css" href="bootstrap.min.css" />
    <link rel="stylesheet" type="text/css" href="apidocs.css" />
  </head>
  <body>

    <nav class="navbar navbar-default">
      <div class="container">
        <div class="navbar-header">
          <a class="navbar-brand" href="index.html">
            Python3.8 API Documentation
          </a>
        </div>
      </div>
    </nav>

    <div id="showPrivate">
      <button class="btn btn-link" onclick="togglePrivate()">Toggle Private API</button>
    </div>

    <div class="container">

      <div class="page-header">
        <h1 class="class"><code><a href="Lib.html" class="code" data-type="Package">Lib</a>.<a href="Lib.codecs.html" class="code" data-type="Module">codecs</a>.<a href="Lib.codecs.Codec.html" class="code" data-type="Class">Codec</a></code></h1>
      </div>

      <div class="categoryHeader">
        class documentation
      </div>

      <div class="extrasDocstring">
        <p><code><span class="py-keyword">class</span> Lib.codecs.Codec:</code></p><p>Known subclasses: <a href="Lib.codecs.StreamReader.html" class="code" data-type="Class">Lib.codecs.StreamReader</a>, <a href="Lib.codecs.StreamWriter.html" class="code" data-type="Class">Lib.codecs.StreamWriter</a></p>
        <p><a href="classIndex.html#Lib.codecs.Codec">View In Hierarchy</a></p>
      </div>

      <div class="moduleDocstring">
        <div><p class="pre">Defines the interface for stateless encoders/decoders.

The .encode()/.decode() methods may use different error
handling schemes by providing the errors argument. These
string values are predefined:

 'strict' - raise a ValueError error (or a subclass)
 'ignore' - ignore the character and continue with the next
 'replace' - replace with a suitable replacement character;
            Python will use the official U+FFFD REPLACEMENT
            CHARACTER for the builtin Unicode codecs on
            decoding and '?' on encoding.
 'surrogateescape' - replace with private code points U+DCnn.
 'xmlcharrefreplace' - Replace with the appropriate XML
                       character reference (only for encoding).
 'backslashreplace'  - Replace with backslashed escape sequences.
 'namereplace'       - Replace with \N{...} escape sequences
                       (only for encoding).

The set of allowed values can be extended via register_error.</p></div>
      </div>

      <div id="splitTables">
        <table class="children sortable" id="id506">
  
  <tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.codecs.Codec.html#encode" class="code" data-type="Method">encode</a></td>
    <td><span>Encodes the object input and returns a tuple (output object, length consumed).</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.codecs.Codec.html#decode" class="code" data-type="Method">decode</a></td>
    <td><span>Decodes the object input and returns a tuple (output object, length consumed).</span></td>
  </tr>
</table>
        

          
      </div>

      <div id="childList">

        <div class="basemethod">
  
  <a name="Lib.codecs.Codec.encode">
    
  </a>
  <a name="encode">
    
  </a>
  <div class="functionHeader">
    
    def
    encode(self, input, errors="""strict"""):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Encodes the object input and returns a tuple (output
object, length consumed).

errors defines the error handling to apply. It defaults to
'strict' handling.

The method may not store state in the Codec instance. Use
StreamWriter for codecs which have to keep state in order to
make encoding efficient.

The encoder must be able to handle zero length input and
return an empty object of the output object type in this
situation.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.codecs.Codec.decode">
    
  </a>
  <a name="decode">
    
  </a>
  <div class="functionHeader">
    
    def
    decode(self, input, errors="""strict"""):
    
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overridden in <a href="Lib.codecs.StreamReader.html" class="code" data-type="Class">Lib.codecs.StreamReader</a></div>
    
    <div><p class="pre">Decodes the object input and returns a tuple (output
object, length consumed).

input must be an object which provides the bf_getreadbuf
buffer slot. Python strings, buffer objects and memory
mapped files are examples of objects providing this slot.

errors defines the error handling to apply. It defaults to
'strict' handling.

The method may not store state in the Codec instance. Use
StreamReader for codecs which have to keep state in order to
make decoding efficient.

The decoder must be able to handle zero length input and
return an empty object of the output object type in this
situation.</p></div>
  </div>
</div>

      </div>
      <address>
        <a href="index.html">API Documentation</a> for Python3.8, generated by <a href="https://github.com/twisted/pydoctor/">pydoctor</a> 20.7.1 at 2020-11-24 05:40:36.
      </address>

    </div>

    <script src="pydoctor.js" type="text/javascript"></script>

  </body>
</html>