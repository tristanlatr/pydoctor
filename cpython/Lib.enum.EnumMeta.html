<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
          "DTD/xhtml1-strict.dtd">
<html>
  <head>
    <title>Lib.enum.EnumMeta : API documentation</title>

    <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
    <link rel="stylesheet" type="text/css" href="bootstrap.min.css" />
    <link rel="stylesheet" type="text/css" href="apidocs.css" />
  </head>
  <body>

    <nav class="navbar navbar-default">
      <div class="container">
        <div class="navbar-header">
          <a class="navbar-brand" href="index.html">
            Python3.8 API Documentation
          </a>
        </div>
      </div>
    </nav>

    <div id="showPrivate">
      <button class="btn btn-link" onclick="togglePrivate()">Toggle Private API</button>
    </div>

    <div class="container">

      <div class="page-header">
        <h1 class="class"><code><a href="Lib.html" class="code" data-type="Package">Lib</a>.<a href="Lib.enum.html" class="code" data-type="Module">enum</a>.<a href="Lib.enum.EnumMeta.html" class="code" data-type="Class">EnumMeta</a></code></h1>
      </div>

      <div class="categoryHeader">
        class documentation
      </div>

      <div class="extrasDocstring">
        <p><code><span class="py-keyword">class</span> Lib.enum.EnumMeta(<span title="type">type</span>):</code></p>
        <p><a href="classIndex.html#Lib.enum.EnumMeta">View In Hierarchy</a></p>
      </div>

      <div class="moduleDocstring">
        <div><p class="pre">Metaclass for Enum</p></div>
      </div>

      <div id="splitTables">
        <table class="children sortable" id="id1930">
  
  <tr class="classmethod">
    
    <td>Class Method</td>
    <td><a href="Lib.enum.EnumMeta.html#__prepare__" class="code" data-type="Class Method">__prepare__</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.enum.EnumMeta.html#__new__" class="code" data-type="Method">__new__</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.enum.EnumMeta.html#__bool__" class="code" data-type="Method">__bool__</a></td>
    <td><span>classes/types should always be True.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.enum.EnumMeta.html#__call__" class="code" data-type="Method">__call__</a></td>
    <td><span>Either returns an existing member, or creates a new enum class.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.enum.EnumMeta.html#__contains__" class="code" data-type="Method">__contains__</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.enum.EnumMeta.html#__delattr__" class="code" data-type="Method">__delattr__</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.enum.EnumMeta.html#__dir__" class="code" data-type="Method">__dir__</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.enum.EnumMeta.html#__getattr__" class="code" data-type="Method">__getattr__</a></td>
    <td><span>Return the enum member matching `name`</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.enum.EnumMeta.html#__getitem__" class="code" data-type="Method">__getitem__</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.enum.EnumMeta.html#__iter__" class="code" data-type="Method">__iter__</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.enum.EnumMeta.html#__len__" class="code" data-type="Method">__len__</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.enum.EnumMeta.html#__members__" class="code" data-type="Method">__members__</a></td>
    <td><span>Returns a mapping of member name-&gt;value.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.enum.EnumMeta.html#__repr__" class="code" data-type="Method">__repr__</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.enum.EnumMeta.html#__reversed__" class="code" data-type="Method">__reversed__</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.enum.EnumMeta.html#__setattr__" class="code" data-type="Method">__setattr__</a></td>
    <td><span>Block attempts to reassign Enum members.</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><a href="Lib.enum.EnumMeta.html#_create_" class="code" data-type="Method">_create_</a></td>
    <td><span>Convenience method to create a new Enum class.</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><a href="Lib.enum.EnumMeta.html#_convert_" class="code" data-type="Method">_convert_</a></td>
    <td><span>Create a new Enum subclass that replaces a collection of global constants</span></td>
  </tr><tr class="staticmethod private">
    
    <td>Static Method</td>
    <td><a href="Lib.enum.EnumMeta.html#_check_for_existing_members" class="code" data-type="Static Method">_check_for_existing_members</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="staticmethod private">
    
    <td>Static Method</td>
    <td><a href="Lib.enum.EnumMeta.html#_get_mixins_" class="code" data-type="Static Method">_get_mixins_</a></td>
    <td><span>Returns the type for creating enum members, and the first inherited enum class.</span></td>
  </tr><tr class="staticmethod private">
    
    <td>Static Method</td>
    <td><a href="Lib.enum.EnumMeta.html#_find_new_" class="code" data-type="Static Method">_find_new_</a></td>
    <td><span>Returns the __new__ to be used for creating the enum members.</span></td>
  </tr>
</table>
        

          
      </div>

      <div id="childList">

        <div class="baseclassmethod">
  
  <a name="Lib.enum.EnumMeta.__prepare__">
    
  </a>
  <a name="__prepare__">
    
  </a>
  <div class="functionHeader">
    @classmethod<br />
    def
    __prepare__(metacls, cls, bases):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.enum.EnumMeta.__new__">
    
  </a>
  <a name="__new__">
    
  </a>
  <div class="functionHeader">
    
    def
    __new__(metacls, cls, bases, classdict):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.enum.EnumMeta.__bool__">
    
  </a>
  <a name="__bool__">
    
  </a>
  <div class="functionHeader">
    
    def
    __bool__(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">classes/types should always be True.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.enum.EnumMeta.__call__">
    
  </a>
  <a name="__call__">
    
  </a>
  <div class="functionHeader">
    
    def
    __call__(cls, value, names=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Either returns an existing member, or creates a new enum class.

This method is used both when an enum class is given a value to match
to an enumeration member (i.e. Color(3)) and for the functional API
(i.e. Color = Enum('Color', names='RED GREEN BLUE')).

When used for the functional API:

`value` will be the name of the new class.

`names` should be either a string of white-space/comma delimited names
(values will start at `start`), or an iterator/mapping of name, value pairs.

`module` should be set to the module this class is being created in;
if it is not set, an attempt to find that module will be made, but if
it fails the class will not be picklable.

`qualname` should be set to the actual location this class can be found
at in its module; by default it is set to the global scope.  If this is
not correct, unpickling will fail in some circumstances.

`type`, if set, will be mixed in as the first base class.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.enum.EnumMeta.__contains__">
    
  </a>
  <a name="__contains__">
    
  </a>
  <div class="functionHeader">
    
    def
    __contains__(cls, member):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.enum.EnumMeta.__delattr__">
    
  </a>
  <a name="__delattr__">
    
  </a>
  <div class="functionHeader">
    
    def
    __delattr__(cls, attr):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.enum.EnumMeta.__dir__">
    
  </a>
  <a name="__dir__">
    
  </a>
  <div class="functionHeader">
    
    def
    __dir__(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.enum.EnumMeta.__getattr__">
    
  </a>
  <a name="__getattr__">
    
  </a>
  <div class="functionHeader">
    
    def
    __getattr__(cls, name):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Return the enum member matching `name`

We use __getattr__ instead of descriptors or inserting into the enum
class' __dict__ in order to support `name` and `value` being both
properties for enum members (which live in the class' __dict__) and
enum members themselves.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.enum.EnumMeta.__getitem__">
    
  </a>
  <a name="__getitem__">
    
  </a>
  <div class="functionHeader">
    
    def
    __getitem__(cls, name):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.enum.EnumMeta.__iter__">
    
  </a>
  <a name="__iter__">
    
  </a>
  <div class="functionHeader">
    
    def
    __iter__(cls):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.enum.EnumMeta.__len__">
    
  </a>
  <a name="__len__">
    
  </a>
  <div class="functionHeader">
    
    def
    __len__(cls):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.enum.EnumMeta.__members__">
    
  </a>
  <a name="__members__">
    
  </a>
  <div class="functionHeader">
    @property<br />
    def
    __members__(cls):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Returns a mapping of member name-&gt;value.

This mapping lists all enum members, including aliases. Note that this
is a read-only view of the internal mapping.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.enum.EnumMeta.__repr__">
    
  </a>
  <a name="__repr__">
    
  </a>
  <div class="functionHeader">
    
    def
    __repr__(cls):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.enum.EnumMeta.__reversed__">
    
  </a>
  <a name="__reversed__">
    
  </a>
  <div class="functionHeader">
    
    def
    __reversed__(cls):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.enum.EnumMeta.__setattr__">
    
  </a>
  <a name="__setattr__">
    
  </a>
  <div class="functionHeader">
    
    def
    __setattr__(cls, name, value):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Block attempts to reassign Enum members.

A simple assignment to the class namespace only changes one of the
several possible ways to get an Enum member from the Enum class,
resulting in an inconsistent Enumeration.</p></div>
  </div>
</div><div class="basemethod private">
  
  <a name="Lib.enum.EnumMeta._create_">
    
  </a>
  <a name="_create_">
    
  </a>
  <div class="functionHeader">
    
    def
    _create_(cls, class_name, names):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Convenience method to create a new Enum class.

`names` can be:

* A string containing member names, separated either with spaces or
  commas.  Values are incremented by 1 from `start`.
* An iterable of member names.  Values are incremented by 1 from `start`.
* An iterable of (member name, value) pairs.
* A mapping of member name -&gt; value pairs.</p></div>
  </div>
</div><div class="basemethod private">
  
  <a name="Lib.enum.EnumMeta._convert_">
    
  </a>
  <a name="_convert_">
    
  </a>
  <div class="functionHeader">
    
    def
    _convert_(cls, name, module, filter, source=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Create a new Enum subclass that replaces a collection of global constants</p></div>
  </div>
</div><div class="basestaticmethod private">
  
  <a name="Lib.enum.EnumMeta._check_for_existing_members">
    
  </a>
  <a name="_check_for_existing_members">
    
  </a>
  <div class="functionHeader">
    @staticmethod<br />
    def
    _check_for_existing_members(class_name, bases):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basestaticmethod private">
  
  <a name="Lib.enum.EnumMeta._get_mixins_">
    
  </a>
  <a name="_get_mixins_">
    
  </a>
  <div class="functionHeader">
    @staticmethod<br />
    def
    _get_mixins_(class_name, bases):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Returns the type for creating enum members, and the first inherited
enum class.

bases: the tuple of bases that was given to __new__</p></div>
  </div>
</div><div class="basestaticmethod private">
  
  <a name="Lib.enum.EnumMeta._find_new_">
    
  </a>
  <a name="_find_new_">
    
  </a>
  <div class="functionHeader">
    @staticmethod<br />
    def
    _find_new_(classdict, member_type, first_enum):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Returns the __new__ to be used for creating the enum members.

classdict: the class dictionary given to __new__
member_type: the data type whose __new__ will be used by default
first_enum: enumeration to check for an overriding __new__</p></div>
  </div>
</div>

      </div>
      <address>
        <a href="index.html">API Documentation</a> for Python3.8, generated by <a href="https://github.com/twisted/pydoctor/">pydoctor</a> 20.7.1 at 2020-11-24 05:11:37.
      </address>

    </div>

    <script src="pydoctor.js" type="text/javascript"></script>

  </body>
</html>