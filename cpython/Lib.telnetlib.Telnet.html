<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
          "DTD/xhtml1-strict.dtd">
<html>
  <head>
    <title>Lib.telnetlib.Telnet : API documentation</title>

    <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
    <link rel="stylesheet" type="text/css" href="bootstrap.min.css" />
    <link rel="stylesheet" type="text/css" href="apidocs.css" />
  </head>
  <body>

    <nav class="navbar navbar-default">
      <div class="container">
        <div class="navbar-header">
          <a class="navbar-brand" href="index.html">
            Python3.8 API Documentation
          </a>
        </div>
      </div>
    </nav>

    <div id="showPrivate">
      <button class="btn btn-link" onclick="togglePrivate()">Toggle Private API</button>
    </div>

    <div class="container">

      <div class="page-header">
        <h1 class="class"><code><a href="Lib.html" class="code" data-type="Package">Lib</a>.<a href="Lib.telnetlib.html" class="code" data-type="Module">telnetlib</a>.<a href="Lib.telnetlib.Telnet.html" class="code" data-type="Class">Telnet</a></code></h1>
      </div>

      <div class="categoryHeader">
        class documentation
      </div>

      <div class="extrasDocstring">
        <p><code><span class="py-keyword">class</span> Lib.telnetlib.Telnet:</code></p>
        <p><a href="classIndex.html#Lib.telnetlib.Telnet">View In Hierarchy</a></p>
      </div>

      <div class="moduleDocstring">
        <div><p class="pre">Telnet interface class.

An instance of this class represents a connection to a telnet
server.  The instance is initially not connected; the open()
method must be used to establish a connection.  Alternatively, the
host name and optional port number can be passed to the
constructor, too.

Don't try to reopen an already connected instance.

This class has many read_*() methods.  Note that some of them
raise EOFError when the end of the connection is read, because
they can return an empty string for other reasons.  See the
individual doc strings.

read_until(expected, [timeout])
    Read until the expected string has been seen, or a timeout is
    hit (default is no timeout); may block.

read_all()
    Read all data until EOF; may block.

read_some()
    Read at least one byte or EOF; may block.

read_very_eager()
    Read all data available already queued or on the socket,
    without blocking.

read_eager()
    Read either data already queued or some data available on the
    socket, without blocking.

read_lazy()
    Read all data in the raw queue (processing it first), without
    doing any socket I/O.

read_very_lazy()
    Reads all data in the cooked queue, without doing any socket
    I/O.

read_sb_data()
    Reads available data between SB ... SE sequence. Don't block.

set_option_negotiation_callback(callback)
    Each time a telnet option is read on the input flow, this callback
    (if set) is called with the following parameters :
    callback(telnet socket, command, option)
        option will be chr(0) when there is no option.
    No other action is done afterwards by telnetlib.</p></div>
      </div>

      <div id="splitTables">
        <table class="children sortable" id="id3701">
  
  <tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.telnetlib.Telnet.html#__init__" class="code" data-type="Method">__init__</a></td>
    <td><span>Constructor.</span></td>
  </tr><tr class="instancevariable">
    
    <td>Instance Variable</td>
    <td><a href="Lib.telnetlib.Telnet.html#debuglevel" class="code" data-type="Instance Variable">debuglevel</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="instancevariable">
    
    <td>Instance Variable</td>
    <td><a href="Lib.telnetlib.Telnet.html#host" class="code" data-type="Instance Variable">host</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="instancevariable">
    
    <td>Instance Variable</td>
    <td><a href="Lib.telnetlib.Telnet.html#port" class="code" data-type="Instance Variable">port</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="instancevariable">
    
    <td>Instance Variable</td>
    <td><a href="Lib.telnetlib.Telnet.html#timeout" class="code" data-type="Instance Variable">timeout</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="instancevariable">
    
    <td>Instance Variable</td>
    <td><a href="Lib.telnetlib.Telnet.html#sock" class="code" data-type="Instance Variable">sock</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="instancevariable">
    
    <td>Instance Variable</td>
    <td><a href="Lib.telnetlib.Telnet.html#rawq" class="code" data-type="Instance Variable">rawq</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="instancevariable">
    
    <td>Instance Variable</td>
    <td><a href="Lib.telnetlib.Telnet.html#irawq" class="code" data-type="Instance Variable">irawq</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="instancevariable">
    
    <td>Instance Variable</td>
    <td><a href="Lib.telnetlib.Telnet.html#cookedq" class="code" data-type="Instance Variable">cookedq</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="instancevariable">
    
    <td>Instance Variable</td>
    <td><a href="Lib.telnetlib.Telnet.html#eof" class="code" data-type="Instance Variable">eof</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="instancevariable">
    
    <td>Instance Variable</td>
    <td><a href="Lib.telnetlib.Telnet.html#iacseq" class="code" data-type="Instance Variable">iacseq</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="instancevariable">
    
    <td>Instance Variable</td>
    <td><a href="Lib.telnetlib.Telnet.html#sb" class="code" data-type="Instance Variable">sb</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="instancevariable">
    
    <td>Instance Variable</td>
    <td><a href="Lib.telnetlib.Telnet.html#sbdataq" class="code" data-type="Instance Variable">sbdataq</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="instancevariable">
    
    <td>Instance Variable</td>
    <td><a href="Lib.telnetlib.Telnet.html#option_callback" class="code" data-type="Instance Variable">option_callback</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.telnetlib.Telnet.html#open" class="code" data-type="Method">open</a></td>
    <td><span>Connect to a host.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.telnetlib.Telnet.html#__del__" class="code" data-type="Method">__del__</a></td>
    <td><span>Destructor -- close the connection.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.telnetlib.Telnet.html#msg" class="code" data-type="Method">msg</a></td>
    <td><span>Print a debug message, when the debug level is &gt; 0.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.telnetlib.Telnet.html#set_debuglevel" class="code" data-type="Method">set_debuglevel</a></td>
    <td><span>Set the debug level.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.telnetlib.Telnet.html#close" class="code" data-type="Method">close</a></td>
    <td><span>Close the connection.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.telnetlib.Telnet.html#get_socket" class="code" data-type="Method">get_socket</a></td>
    <td><span>Return the socket object used internally.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.telnetlib.Telnet.html#fileno" class="code" data-type="Method">fileno</a></td>
    <td><span>Return the fileno() of the socket object used internally.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.telnetlib.Telnet.html#write" class="code" data-type="Method">write</a></td>
    <td><span>Write a string to the socket, doubling any IAC characters.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.telnetlib.Telnet.html#read_until" class="code" data-type="Method">read_until</a></td>
    <td><span>Read until a given string is encountered or until timeout.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.telnetlib.Telnet.html#read_all" class="code" data-type="Method">read_all</a></td>
    <td><span>Read all data until EOF; block until connection closed.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.telnetlib.Telnet.html#read_some" class="code" data-type="Method">read_some</a></td>
    <td><span>Read at least one byte of cooked data unless EOF is hit.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.telnetlib.Telnet.html#read_very_eager" class="code" data-type="Method">read_very_eager</a></td>
    <td><span>Read everything that's possible without blocking in I/O (eager).</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.telnetlib.Telnet.html#read_eager" class="code" data-type="Method">read_eager</a></td>
    <td><span>Read readily available data.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.telnetlib.Telnet.html#read_lazy" class="code" data-type="Method">read_lazy</a></td>
    <td><span>Process and return data that's already in the queues (lazy).</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.telnetlib.Telnet.html#read_very_lazy" class="code" data-type="Method">read_very_lazy</a></td>
    <td><span>Return any data available in the cooked queue (very lazy).</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.telnetlib.Telnet.html#read_sb_data" class="code" data-type="Method">read_sb_data</a></td>
    <td><span>Return any data available in the SB ... SE queue.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.telnetlib.Telnet.html#set_option_negotiation_callback" class="code" data-type="Method">set_option_negotiation_callback</a></td>
    <td><span>Provide a callback function called after each receipt of a telnet option.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.telnetlib.Telnet.html#process_rawq" class="code" data-type="Method">process_rawq</a></td>
    <td><span>Transfer from raw queue to cooked queue.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.telnetlib.Telnet.html#rawq_getchar" class="code" data-type="Method">rawq_getchar</a></td>
    <td><span>Get next char from raw queue.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.telnetlib.Telnet.html#fill_rawq" class="code" data-type="Method">fill_rawq</a></td>
    <td><span>Fill raw queue from exactly one recv() system call.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.telnetlib.Telnet.html#sock_avail" class="code" data-type="Method">sock_avail</a></td>
    <td><span>Test whether data is available on the socket.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.telnetlib.Telnet.html#interact" class="code" data-type="Method">interact</a></td>
    <td><span>Interaction function, emulates a very dumb telnet client.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.telnetlib.Telnet.html#mt_interact" class="code" data-type="Method">mt_interact</a></td>
    <td><span>Multithreaded version of interact().</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.telnetlib.Telnet.html#listener" class="code" data-type="Method">listener</a></td>
    <td><span>Helper for mt_interact() -- this executes in the other thread.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.telnetlib.Telnet.html#expect" class="code" data-type="Method">expect</a></td>
    <td><span>Read until one from a list of a regular expressions matches.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.telnetlib.Telnet.html#__enter__" class="code" data-type="Method">__enter__</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.telnetlib.Telnet.html#__exit__" class="code" data-type="Method">__exit__</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr>
</table>
        

          
      </div>

      <div id="childList">

        <div class="basemethod">
  
  <a name="Lib.telnetlib.Telnet.__init__">
    
  </a>
  <a name="__init__">
    
  </a>
  <div class="functionHeader">
    
    def
    __init__(self, host=None, port=0, timeout=socket._GLOBAL_DEFAULT_TIMEOUT):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Constructor.

When called without arguments, create an unconnected instance.
With a hostname argument, it connects the instance; port number
and timeout are optional.</p></div>
  </div>
</div><div class="baseinstancevariable">
  
  <a name="Lib.telnetlib.Telnet.debuglevel">
    
  </a>
  <a name="debuglevel">
    
  </a>
  <div class="functionHeader">
    debuglevel =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="baseinstancevariable">
  
  <a name="Lib.telnetlib.Telnet.host">
    
  </a>
  <a name="host">
    
  </a>
  <div class="functionHeader">
    host =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="baseinstancevariable">
  
  <a name="Lib.telnetlib.Telnet.port">
    
  </a>
  <a name="port">
    
  </a>
  <div class="functionHeader">
    port =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="baseinstancevariable">
  
  <a name="Lib.telnetlib.Telnet.timeout">
    
  </a>
  <a name="timeout">
    
  </a>
  <div class="functionHeader">
    timeout =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="baseinstancevariable">
  
  <a name="Lib.telnetlib.Telnet.sock">
    
  </a>
  <a name="sock">
    
  </a>
  <div class="functionHeader">
    sock =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="baseinstancevariable">
  
  <a name="Lib.telnetlib.Telnet.rawq">
    
  </a>
  <a name="rawq">
    
  </a>
  <div class="functionHeader">
    rawq =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="baseinstancevariable">
  
  <a name="Lib.telnetlib.Telnet.irawq">
    
  </a>
  <a name="irawq">
    
  </a>
  <div class="functionHeader">
    irawq =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div> (type: <code>int</code>)
  </div>
</div><div class="baseinstancevariable">
  
  <a name="Lib.telnetlib.Telnet.cookedq">
    
  </a>
  <a name="cookedq">
    
  </a>
  <div class="functionHeader">
    cookedq =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="baseinstancevariable">
  
  <a name="Lib.telnetlib.Telnet.eof">
    
  </a>
  <a name="eof">
    
  </a>
  <div class="functionHeader">
    eof =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="baseinstancevariable">
  
  <a name="Lib.telnetlib.Telnet.iacseq">
    
  </a>
  <a name="iacseq">
    
  </a>
  <div class="functionHeader">
    iacseq =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div> (type: <code>bytes</code>)
  </div>
</div><div class="baseinstancevariable">
  
  <a name="Lib.telnetlib.Telnet.sb">
    
  </a>
  <a name="sb">
    
  </a>
  <div class="functionHeader">
    sb =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div> (type: <code>int</code>)
  </div>
</div><div class="baseinstancevariable">
  
  <a name="Lib.telnetlib.Telnet.sbdataq">
    
  </a>
  <a name="sbdataq">
    
  </a>
  <div class="functionHeader">
    sbdataq =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="baseinstancevariable">
  
  <a name="Lib.telnetlib.Telnet.option_callback">
    
  </a>
  <a name="option_callback">
    
  </a>
  <div class="functionHeader">
    option_callback =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.telnetlib.Telnet.open">
    
  </a>
  <a name="open">
    
  </a>
  <div class="functionHeader">
    
    def
    open(self, host, port=0, timeout=socket._GLOBAL_DEFAULT_TIMEOUT):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Connect to a host.

The optional second argument is the port number, which
defaults to the standard telnet port (23).

Don't try to reopen an already connected instance.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.telnetlib.Telnet.__del__">
    
  </a>
  <a name="__del__">
    
  </a>
  <div class="functionHeader">
    
    def
    __del__(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Destructor -- close the connection.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.telnetlib.Telnet.msg">
    
  </a>
  <a name="msg">
    
  </a>
  <div class="functionHeader">
    
    def
    msg(self, msg, *args):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Print a debug message, when the debug level is &gt; 0.

If extra arguments are present, they are substituted in the
message using the standard string formatting operator.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.telnetlib.Telnet.set_debuglevel">
    
  </a>
  <a name="set_debuglevel">
    
  </a>
  <div class="functionHeader">
    
    def
    set_debuglevel(self, debuglevel):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Set the debug level.

The higher it is, the more debug output you get (on sys.stdout).</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.telnetlib.Telnet.close">
    
  </a>
  <a name="close">
    
  </a>
  <div class="functionHeader">
    
    def
    close(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Close the connection.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.telnetlib.Telnet.get_socket">
    
  </a>
  <a name="get_socket">
    
  </a>
  <div class="functionHeader">
    
    def
    get_socket(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Return the socket object used internally.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.telnetlib.Telnet.fileno">
    
  </a>
  <a name="fileno">
    
  </a>
  <div class="functionHeader">
    
    def
    fileno(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Return the fileno() of the socket object used internally.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.telnetlib.Telnet.write">
    
  </a>
  <a name="write">
    
  </a>
  <div class="functionHeader">
    
    def
    write(self, buffer):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Write a string to the socket, doubling any IAC characters.

Can block if the connection is blocked.  May raise
OSError if the connection is closed.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.telnetlib.Telnet.read_until">
    
  </a>
  <a name="read_until">
    
  </a>
  <div class="functionHeader">
    
    def
    read_until(self, match, timeout=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Read until a given string is encountered or until timeout.

When no match is found, return whatever is available instead,
possibly the empty string.  Raise EOFError if the connection
is closed and no cooked data is available.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.telnetlib.Telnet.read_all">
    
  </a>
  <a name="read_all">
    
  </a>
  <div class="functionHeader">
    
    def
    read_all(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Read all data until EOF; block until connection closed.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.telnetlib.Telnet.read_some">
    
  </a>
  <a name="read_some">
    
  </a>
  <div class="functionHeader">
    
    def
    read_some(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Read at least one byte of cooked data unless EOF is hit.

Return b'' if EOF is hit.  Block if no data is immediately
available.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.telnetlib.Telnet.read_very_eager">
    
  </a>
  <a name="read_very_eager">
    
  </a>
  <div class="functionHeader">
    
    def
    read_very_eager(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Read everything that's possible without blocking in I/O (eager).

Raise EOFError if connection closed and no cooked data
available.  Return b'' if no cooked data available otherwise.
Don't block unless in the midst of an IAC sequence.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.telnetlib.Telnet.read_eager">
    
  </a>
  <a name="read_eager">
    
  </a>
  <div class="functionHeader">
    
    def
    read_eager(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Read readily available data.

Raise EOFError if connection closed and no cooked data
available.  Return b'' if no cooked data available otherwise.
Don't block unless in the midst of an IAC sequence.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.telnetlib.Telnet.read_lazy">
    
  </a>
  <a name="read_lazy">
    
  </a>
  <div class="functionHeader">
    
    def
    read_lazy(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Process and return data that's already in the queues (lazy).

Raise EOFError if connection closed and no data available.
Return b'' if no cooked data available otherwise.  Don't block
unless in the midst of an IAC sequence.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.telnetlib.Telnet.read_very_lazy">
    
  </a>
  <a name="read_very_lazy">
    
  </a>
  <div class="functionHeader">
    
    def
    read_very_lazy(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Return any data available in the cooked queue (very lazy).

Raise EOFError if connection closed and no data available.
Return b'' if no cooked data available otherwise.  Don't block.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.telnetlib.Telnet.read_sb_data">
    
  </a>
  <a name="read_sb_data">
    
  </a>
  <div class="functionHeader">
    
    def
    read_sb_data(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Return any data available in the SB ... SE queue.

Return b'' if no SB ... SE available. Should only be called
after seeing a SB or SE command. When a new SB command is
found, old unread SB data will be discarded. Don't block.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.telnetlib.Telnet.set_option_negotiation_callback">
    
  </a>
  <a name="set_option_negotiation_callback">
    
  </a>
  <div class="functionHeader">
    
    def
    set_option_negotiation_callback(self, callback):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Provide a callback function called after each receipt of a telnet option.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.telnetlib.Telnet.process_rawq">
    
  </a>
  <a name="process_rawq">
    
  </a>
  <div class="functionHeader">
    
    def
    process_rawq(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Transfer from raw queue to cooked queue.

Set self.eof when connection is closed.  Don't block unless in
the midst of an IAC sequence.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.telnetlib.Telnet.rawq_getchar">
    
  </a>
  <a name="rawq_getchar">
    
  </a>
  <div class="functionHeader">
    
    def
    rawq_getchar(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Get next char from raw queue.

Block if no data is immediately available.  Raise EOFError
when connection is closed.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.telnetlib.Telnet.fill_rawq">
    
  </a>
  <a name="fill_rawq">
    
  </a>
  <div class="functionHeader">
    
    def
    fill_rawq(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Fill raw queue from exactly one recv() system call.

Block if no data is immediately available.  Set self.eof when
connection is closed.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.telnetlib.Telnet.sock_avail">
    
  </a>
  <a name="sock_avail">
    
  </a>
  <div class="functionHeader">
    
    def
    sock_avail(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Test whether data is available on the socket.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.telnetlib.Telnet.interact">
    
  </a>
  <a name="interact">
    
  </a>
  <div class="functionHeader">
    
    def
    interact(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Interaction function, emulates a very dumb telnet client.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.telnetlib.Telnet.mt_interact">
    
  </a>
  <a name="mt_interact">
    
  </a>
  <div class="functionHeader">
    
    def
    mt_interact(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Multithreaded version of interact().</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.telnetlib.Telnet.listener">
    
  </a>
  <a name="listener">
    
  </a>
  <div class="functionHeader">
    
    def
    listener(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Helper for mt_interact() -- this executes in the other thread.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.telnetlib.Telnet.expect">
    
  </a>
  <a name="expect">
    
  </a>
  <div class="functionHeader">
    
    def
    expect(self, list, timeout=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Read until one from a list of a regular expressions matches.

The first argument is a list of regular expressions, either
compiled (re.Pattern instances) or uncompiled (strings).
The optional second argument is a timeout, in seconds; default
is no timeout.

Return a tuple of three items: the index in the list of the
first regular expression that matches; the re.Match object
returned; and the text read up till and including the match.

If EOF is read and no text was read, raise EOFError.
Otherwise, when nothing matches, return (-1, None, text) where
text is the text received so far (may be the empty string if a
timeout happened).

If a regular expression ends with a greedy match (e.g. '.*')
or if more than one expression can match the same input, the
results are undeterministic, and may depend on the I/O timing.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.telnetlib.Telnet.__enter__">
    
  </a>
  <a name="__enter__">
    
  </a>
  <div class="functionHeader">
    
    def
    __enter__(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.telnetlib.Telnet.__exit__">
    
  </a>
  <a name="__exit__">
    
  </a>
  <div class="functionHeader">
    
    def
    __exit__(self, type, value, traceback):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div class="undocumented">Undocumented</div>
  </div>
</div>

      </div>
      <address>
        <a href="index.html">API Documentation</a> for Python3.8, generated by <a href="https://github.com/twisted/pydoctor/">pydoctor</a> 20.7.1 at 2020-11-24 05:11:37.
      </address>

    </div>

    <script src="pydoctor.js" type="text/javascript"></script>

  </body>
</html>