<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
          "DTD/xhtml1-strict.dtd">
<html>
  <head>
    <title>Lib.codecs.StreamReader : API documentation</title>

    <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
    <link rel="stylesheet" type="text/css" href="bootstrap.min.css" />
    <link rel="stylesheet" type="text/css" href="apidocs.css" />
  </head>
  <body>

    <nav class="navbar navbar-default">
      <div class="container">
        <div class="navbar-header">
          <a class="navbar-brand" href="index.html">
            Python3.8 API Documentation
          </a>
        </div>
      </div>
    </nav>

    <div id="showPrivate">
      <button class="btn btn-link" onclick="togglePrivate()">Toggle Private API</button>
    </div>

    <div class="container">

      <div class="page-header">
        <h1 class="class"><code><a href="Lib.html" class="code" data-type="Package">Lib</a>.<a href="Lib.codecs.html" class="code" data-type="Module">codecs</a>.<a href="Lib.codecs.StreamReader.html" class="code" data-type="Class">StreamReader</a></code></h1>
      </div>

      <div class="categoryHeader">
        class documentation
      </div>

      <div class="extrasDocstring">
        <p><code><span class="py-keyword">class</span> Lib.codecs.StreamReader(<a href="Lib.codecs.Codec.html" class="code" data-type="Class">Codec</a>):</code></p>
        <p><a href="classIndex.html#Lib.codecs.StreamReader">View In Hierarchy</a></p>
      </div>

      <div class="moduleDocstring">
        <div class="undocumented">Undocumented</div>
      </div>

      <div id="splitTables">
        <table class="children sortable" id="id515">
  
  <tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.codecs.StreamReader.html#__init__" class="code" data-type="Method">__init__</a></td>
    <td><span>Creates a StreamReader instance.</span></td>
  </tr><tr class="instancevariable">
    
    <td>Instance Variable</td>
    <td><a href="Lib.codecs.StreamReader.html#stream" class="code" data-type="Instance Variable">stream</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="instancevariable">
    
    <td>Instance Variable</td>
    <td><a href="Lib.codecs.StreamReader.html#errors" class="code" data-type="Instance Variable">errors</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="instancevariable">
    
    <td>Instance Variable</td>
    <td><a href="Lib.codecs.StreamReader.html#bytebuffer" class="code" data-type="Instance Variable">bytebuffer</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="instancevariable">
    
    <td>Instance Variable</td>
    <td><a href="Lib.codecs.StreamReader.html#charbuffer" class="code" data-type="Instance Variable">charbuffer</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="instancevariable">
    
    <td>Instance Variable</td>
    <td><a href="Lib.codecs.StreamReader.html#linebuffer" class="code" data-type="Instance Variable">linebuffer</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.codecs.StreamReader.html#decode" class="code" data-type="Method">decode</a></td>
    <td><span>Decodes the object input and returns a tuple (output object, length consumed).</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.codecs.StreamReader.html#read" class="code" data-type="Method">read</a></td>
    <td><span>Decodes data from the stream self.stream and returns the resulting object.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.codecs.StreamReader.html#readline" class="code" data-type="Method">readline</a></td>
    <td><span>Read one line from the input stream and return the decoded data.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.codecs.StreamReader.html#readlines" class="code" data-type="Method">readlines</a></td>
    <td><span>Read all lines available on the input stream and return them as a list.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.codecs.StreamReader.html#reset" class="code" data-type="Method">reset</a></td>
    <td><span>Resets the codec buffers used for keeping state.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.codecs.StreamReader.html#seek" class="code" data-type="Method">seek</a></td>
    <td><span>Set the input stream's current position.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.codecs.StreamReader.html#__next__" class="code" data-type="Method">__next__</a></td>
    <td><span>Return the next decoded line from the input stream.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.codecs.StreamReader.html#__iter__" class="code" data-type="Method">__iter__</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.codecs.StreamReader.html#__getattr__" class="code" data-type="Method">__getattr__</a></td>
    <td><span>Inherit all other methods from the underlying stream.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.codecs.StreamReader.html#__enter__" class="code" data-type="Method">__enter__</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.codecs.StreamReader.html#__exit__" class="code" data-type="Method">__exit__</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="instancevariable private">
    
    <td>Instance Variable</td>
    <td><a href="Lib.codecs.StreamReader.html#_empty_charbuffer" class="code" data-type="Instance Variable">_empty_charbuffer</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr>
</table>
        
          <p class="inheritedFrom">
            Inherited from <a href="Lib.codecs.Codec.html" class="code" data-type="Class">Codec</a>:
          </p>
          <table class="children sortable" id="id516">
  
  <tr class="basemethod">
    
    <td>Method</td>
    <td><a href="Lib.codecs.Codec.html#encode" class="code" data-type="Method">encode</a></td>
    <td><span>Encodes the object input and returns a tuple (output object, length consumed).</span></td>
  </tr>
</table>
          

          
      </div>

      <div id="childList">

        <div class="basemethod">
  
  <a name="Lib.codecs.StreamReader.__init__">
    
  </a>
  <a name="__init__">
    
  </a>
  <div class="functionHeader">
    
    def
    __init__(self, stream, errors="""strict"""):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Creates a StreamReader instance.

stream must be a file-like object open for reading.

The StreamReader may use different error handling
schemes by providing the errors keyword argument. These
parameters are predefined:

 'strict' - raise a ValueError (or a subclass)
 'ignore' - ignore the character and continue with the next
 'replace'- replace with a suitable replacement character
 'backslashreplace' - Replace with backslashed escape sequences;

The set of allowed parameter values can be extended via
register_error.</p></div>
  </div>
</div><div class="baseinstancevariable">
  
  <a name="Lib.codecs.StreamReader.stream">
    
  </a>
  <a name="stream">
    
  </a>
  <div class="functionHeader">
    stream =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="baseinstancevariable">
  
  <a name="Lib.codecs.StreamReader.errors">
    
  </a>
  <a name="errors">
    
  </a>
  <div class="functionHeader">
    errors =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="baseinstancevariable">
  
  <a name="Lib.codecs.StreamReader.bytebuffer">
    
  </a>
  <a name="bytebuffer">
    
  </a>
  <div class="functionHeader">
    bytebuffer =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div> (type: <code>bytes</code>)
  </div>
</div><div class="baseinstancevariable private">
  
  <a name="Lib.codecs.StreamReader._empty_charbuffer">
    
  </a>
  <a name="_empty_charbuffer">
    
  </a>
  <div class="functionHeader">
    _empty_charbuffer =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="baseinstancevariable">
  
  <a name="Lib.codecs.StreamReader.charbuffer">
    
  </a>
  <a name="charbuffer">
    
  </a>
  <div class="functionHeader">
    charbuffer =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="baseinstancevariable">
  
  <a name="Lib.codecs.StreamReader.linebuffer">
    
  </a>
  <a name="linebuffer">
    
  </a>
  <div class="functionHeader">
    linebuffer =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.codecs.StreamReader.decode">
    
  </a>
  <a name="decode">
    
  </a>
  <div class="functionHeader">
    
    def
    decode(self, input, errors="""strict"""):
    
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overrides <a href="Lib.codecs.Codec.html#decode" class="code" data-type="Method">Lib.codecs.Codec.decode</a></div>
    
    <div><p class="pre">Decodes the object input and returns a tuple (output
object, length consumed).

input must be an object which provides the bf_getreadbuf
buffer slot. Python strings, buffer objects and memory
mapped files are examples of objects providing this slot.

errors defines the error handling to apply. It defaults to
'strict' handling.

The method may not store state in the Codec instance. Use
StreamReader for codecs which have to keep state in order to
make decoding efficient.

The decoder must be able to handle zero length input and
return an empty object of the output object type in this
situation.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.codecs.StreamReader.read">
    
  </a>
  <a name="read">
    
  </a>
  <div class="functionHeader">
    
    def
    read(self, size=(-1), chars=(-1), firstline=(False)):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Decodes data from the stream self.stream and returns the
resulting object.

chars indicates the number of decoded code points or bytes to
return. read() will never return more data than requested,
but it might return less, if there is not enough available.

size indicates the approximate maximum number of decoded
bytes or code points to read for decoding. The decoder
can modify this setting as appropriate. The default value
-1 indicates to read and decode as much as possible.  size
is intended to prevent having to decode huge files in one
step.

If firstline is true, and a UnicodeDecodeError happens
after the first line terminator in the input only the first line
will be returned, the rest of the input will be kept until the
next call to read().

The method should use a greedy read strategy, meaning that
it should read as much data as is allowed within the
definition of the encoding and the given size, e.g.  if
optional encoding endings or state markers are available
on the stream, these should be read too.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.codecs.StreamReader.readline">
    
  </a>
  <a name="readline">
    
  </a>
  <div class="functionHeader">
    
    def
    readline(self, size=None, keepends=(True)):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Read one line from the input stream and return the
decoded data.

size, if given, is passed as size argument to the
read() method.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.codecs.StreamReader.readlines">
    
  </a>
  <a name="readlines">
    
  </a>
  <div class="functionHeader">
    
    def
    readlines(self, sizehint=None, keepends=(True)):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Read all lines available on the input stream
and return them as a list.

Line breaks are implemented using the codec's decoder
method and are included in the list entries.

sizehint, if given, is ignored since there is no efficient
way to finding the true end-of-line.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.codecs.StreamReader.reset">
    
  </a>
  <a name="reset">
    
  </a>
  <div class="functionHeader">
    
    def
    reset(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Resets the codec buffers used for keeping state.

Note that no stream repositioning should take place.
This method is primarily intended to be able to recover
from decoding errors.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.codecs.StreamReader.seek">
    
  </a>
  <a name="seek">
    
  </a>
  <div class="functionHeader">
    
    def
    seek(self, offset, whence=0):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Set the input stream's current position.

Resets the codec buffers used for keeping state.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.codecs.StreamReader.__next__">
    
  </a>
  <a name="__next__">
    
  </a>
  <div class="functionHeader">
    
    def
    __next__(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Return the next decoded line from the input stream.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.codecs.StreamReader.__iter__">
    
  </a>
  <a name="__iter__">
    
  </a>
  <div class="functionHeader">
    
    def
    __iter__(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.codecs.StreamReader.__getattr__">
    
  </a>
  <a name="__getattr__">
    
  </a>
  <div class="functionHeader">
    
    def
    __getattr__(self, name, getattr=getattr):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Inherit all other methods from the underlying stream.
        </p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.codecs.StreamReader.__enter__">
    
  </a>
  <a name="__enter__">
    
  </a>
  <div class="functionHeader">
    
    def
    __enter__(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.codecs.StreamReader.__exit__">
    
  </a>
  <a name="__exit__">
    
  </a>
  <div class="functionHeader">
    
    def
    __exit__(self, type, value, tb):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div class="undocumented">Undocumented</div>
  </div>
</div>

      </div>
      <address>
        <a href="index.html">API Documentation</a> for Python3.8, generated by <a href="https://github.com/twisted/pydoctor/">pydoctor</a> 20.7.1 at 2020-11-24 05:11:37.
      </address>

    </div>

    <script src="pydoctor.js" type="text/javascript"></script>

  </body>
</html>