<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
          "DTD/xhtml1-strict.dtd">
<html>
  <head>
    <title>Lib.test.test_pdb : API documentation</title>

    <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
    <link rel="stylesheet" type="text/css" href="bootstrap.min.css" />
    <link rel="stylesheet" type="text/css" href="apidocs.css" />
  </head>
  <body>

    <nav class="navbar navbar-default">
      <div class="container">
        <div class="navbar-header">
          <a class="navbar-brand" href="index.html">
            Python3.8 API Documentation
          </a>
        </div>
      </div>
    </nav>

    <div id="showPrivate">
      <button class="btn btn-link" onclick="togglePrivate()">Toggle Private API</button>
    </div>

    <div class="container">

      <div class="page-header">
        <h1 class="module"><code><a href="Lib.html" class="code" data-type="Package">Lib</a>.<a href="Lib.test.html" class="code" data-type="Package">test</a>.<a href="Lib.test.test_pdb.html" class="code" data-type="Module">test_pdb</a></code></h1>
      </div>

      <div class="categoryHeader">
        module documentation
      </div>

      <div class="extrasDocstring">
        
        <p></p>
      </div>

      <div class="moduleDocstring">
        <div class="undocumented">Undocumented</div>
      </div>

      <div id="splitTables">
        <table class="children sortable" id="id8011">
  
  <tr class="class">
    
    <td>Class</td>
    <td><a href="Lib.test.test_pdb.PdbTestInput.html" class="code" data-type="Class">PdbTestInput</a></td>
    <td><span>Context manager that makes testing Pdb in doctests easier.</span></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><a href="Lib.test.test_pdb.html#test_pdb_displayhook" class="code" data-type="Function">test_pdb_displayhook</a></td>
    <td><span>This tests the custom displayhook for pdb.</span></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><a href="Lib.test.test_pdb.html#test_pdb_basic_commands" class="code" data-type="Function">test_pdb_basic_commands</a></td>
    <td><span>Test the basic commands of pdb.</span></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><a href="Lib.test.test_pdb.html#test_pdb_breakpoint_commands" class="code" data-type="Function">test_pdb_breakpoint_commands</a></td>
    <td><span>Test basic commands related to breakpoints.</span></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><a href="Lib.test.test_pdb.html#do_nothing" class="code" data-type="Function">do_nothing</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><a href="Lib.test.test_pdb.html#do_something" class="code" data-type="Function">do_something</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><a href="Lib.test.test_pdb.html#test_list_commands" class="code" data-type="Function">test_list_commands</a></td>
    <td><span>Test the list and source commands of pdb.</span></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><a href="Lib.test.test_pdb.html#test_pdb_whatis_command" class="code" data-type="Function">test_pdb_whatis_command</a></td>
    <td><span>Test the whatis command</span></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><a href="Lib.test.test_pdb.html#test_post_mortem" class="code" data-type="Function">test_post_mortem</a></td>
    <td><span>Test post mortem traceback debugging.</span></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><a href="Lib.test.test_pdb.html#test_pdb_skip_modules" class="code" data-type="Function">test_pdb_skip_modules</a></td>
    <td><span>This illustrates the simple case of module skipping.</span></td>
  </tr><tr class="variable">
    
    <td>Variable</td>
    <td><a href="Lib.test.test_pdb.html#mod" class="code" data-type="Variable">mod</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><a href="Lib.test.test_pdb.html#test_pdb_skip_modules_with_callback" class="code" data-type="Function">test_pdb_skip_modules_with_callback</a></td>
    <td><span>This illustrates skipping of modules that call into other code.</span></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><a href="Lib.test.test_pdb.html#test_pdb_continue_in_bottomframe" class="code" data-type="Function">test_pdb_continue_in_bottomframe</a></td>
    <td><span>Test that "continue" and "next" work properly in bottom frame (issue #5294).</span></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><a href="Lib.test.test_pdb.html#pdb_invoke" class="code" data-type="Function">pdb_invoke</a></td>
    <td><span>Run pdb.method(arg).</span></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><a href="Lib.test.test_pdb.html#test_pdb_run_with_incorrect_argument" class="code" data-type="Function">test_pdb_run_with_incorrect_argument</a></td>
    <td><span>Testing run and runeval with incorrect first argument.</span></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><a href="Lib.test.test_pdb.html#test_pdb_run_with_code_object" class="code" data-type="Function">test_pdb_run_with_code_object</a></td>
    <td><span>Testing run and runeval with code object as a first argument.</span></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><a href="Lib.test.test_pdb.html#test_next_until_return_at_return_event" class="code" data-type="Function">test_next_until_return_at_return_event</a></td>
    <td><span>Test that pdb stops after a next/until/return issued at a return debug event.</span></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><a href="Lib.test.test_pdb.html#test_pdb_next_command_for_generator" class="code" data-type="Function">test_pdb_next_command_for_generator</a></td>
    <td><span>Testing skip unwindng stack on yield for generators for "next" command</span></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><a href="Lib.test.test_pdb.html#test_pdb_next_command_for_coroutine" class="code" data-type="Function">test_pdb_next_command_for_coroutine</a></td>
    <td><span>Testing skip unwindng stack on yield for coroutines for "next" command</span></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><a href="Lib.test.test_pdb.html#test_pdb_next_command_for_asyncgen" class="code" data-type="Function">test_pdb_next_command_for_asyncgen</a></td>
    <td><span>Testing skip unwindng stack on yield for coroutines for "next" command</span></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><a href="Lib.test.test_pdb.html#test_pdb_return_command_for_generator" class="code" data-type="Function">test_pdb_return_command_for_generator</a></td>
    <td><span>Testing no unwindng stack on yield for generators for "return" command</span></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><a href="Lib.test.test_pdb.html#test_pdb_return_command_for_coroutine" class="code" data-type="Function">test_pdb_return_command_for_coroutine</a></td>
    <td><span>Testing no unwindng stack on yield for coroutines for "return" command</span></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><a href="Lib.test.test_pdb.html#test_pdb_until_command_for_generator" class="code" data-type="Function">test_pdb_until_command_for_generator</a></td>
    <td><span>Testing no unwindng stack on yield for generators for "until" command if target breakpoint is not reached</span></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><a href="Lib.test.test_pdb.html#test_pdb_until_command_for_coroutine" class="code" data-type="Function">test_pdb_until_command_for_coroutine</a></td>
    <td><span>Testing no unwindng stack for coroutines for "until" command if target breakpoint is not reached</span></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><a href="Lib.test.test_pdb.html#test_pdb_next_command_in_generator_for_loop" class="code" data-type="Function">test_pdb_next_command_in_generator_for_loop</a></td>
    <td><span>The next command on returning from a generator controlled by a for loop.</span></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><a href="Lib.test.test_pdb.html#test_pdb_next_command_subiterator" class="code" data-type="Function">test_pdb_next_command_subiterator</a></td>
    <td><span>The next command in a generator with a subiterator.</span></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><a href="Lib.test.test_pdb.html#test_pdb_issue_20766" class="code" data-type="Function">test_pdb_issue_20766</a></td>
    <td><span>Test for reference leaks when the SIGINT handler is set.</span></td>
  </tr><tr class="class">
    
    <td>Class</td>
    <td><a href="Lib.test.test_pdb.PdbTestCase.html" class="code" data-type="Class">PdbTestCase</a></td>
    <td><span class="undocumented">No class0/1 instance variables docstring; , 2/26 methods documented</span></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><a href="Lib.test.test_pdb.html#load_tests" class="code" data-type="Function">load_tests</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr>
</table>
        

          
      </div>

      <div id="childList">

        <div class="basefunction">
  
  <a name="Lib.test.test_pdb.test_pdb_displayhook">
    
  </a>
  <a name="test_pdb_displayhook">
    
  </a>
  <div class="functionHeader">
    
    def
    test_pdb_displayhook():
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">This tests the custom displayhook for pdb.

&gt;&gt;&gt; def test_function(foo, bar):
...     import pdb; pdb.Pdb(nosigint=True, readrc=False).set_trace()
...     pass

&gt;&gt;&gt; with PdbTestInput([
...     'foo',
...     'bar',
...     'for i in range(5): print(i)',
...     'continue',
... ]):
...     test_function(1, None)
&gt; &lt;doctest test.test_pdb.test_pdb_displayhook[0]&gt;(3)test_function()
-&gt; pass
(Pdb) foo
1
(Pdb) bar
(Pdb) for i in range(5): print(i)
0
1
2
3
4
(Pdb) continue</p></div>
  </div>
</div><div class="basefunction">
  
  <a name="Lib.test.test_pdb.test_pdb_basic_commands">
    
  </a>
  <a name="test_pdb_basic_commands">
    
  </a>
  <div class="functionHeader">
    
    def
    test_pdb_basic_commands():
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Test the basic commands of pdb.

&gt;&gt;&gt; def test_function_2(foo, bar='default'):
...     print(foo)
...     for i in range(5):
...         print(i)
...     print(bar)
...     for i in range(10):
...         never_executed
...     print('after for')
...     print('...')
...     return foo.upper()

&gt;&gt;&gt; def test_function3(arg=None, *, kwonly=None):
...     pass

&gt;&gt;&gt; def test_function4(a, b, c, /):
...     pass

&gt;&gt;&gt; def test_function():
...     import pdb; pdb.Pdb(nosigint=True, readrc=False).set_trace()
...     ret = test_function_2('baz')
...     test_function3(kwonly=True)
...     test_function4(1, 2, 3)
...     print(ret)

&gt;&gt;&gt; with PdbTestInput([  # doctest: +ELLIPSIS, +NORMALIZE_WHITESPACE
...     'step',       # entering the function call
...     'args',       # display function args
...     'list',       # list function source
...     'bt',         # display backtrace
...     'up',         # step up to test_function()
...     'down',       # step down to test_function_2() again
...     'next',       # stepping to print(foo)
...     'next',       # stepping to the for loop
...     'step',       # stepping into the for loop
...     'until',      # continuing until out of the for loop
...     'next',       # executing the print(bar)
...     'jump 8',     # jump over second for loop
...     'return',     # return out of function
...     'retval',     # display return value
...     'next',       # step to test_function3()
...     'step',       # stepping into test_function3()
...     'args',       # display function args
...     'return',     # return out of function
...     'next',       # step to test_function4()
...     'step',       # stepping to test_function4()
...     'args',       # display function args
...     'continue',
... ]):
...    test_function()
&gt; &lt;doctest test.test_pdb.test_pdb_basic_commands[3]&gt;(3)test_function()
-&gt; ret = test_function_2('baz')
(Pdb) step
--Call--
&gt; &lt;doctest test.test_pdb.test_pdb_basic_commands[0]&gt;(1)test_function_2()
-&gt; def test_function_2(foo, bar='default'):
(Pdb) args
foo = 'baz'
bar = 'default'
(Pdb) list
  1  -&gt;     def test_function_2(foo, bar='default'):
  2             print(foo)
  3             for i in range(5):
  4                 print(i)
  5             print(bar)
  6             for i in range(10):
  7                 never_executed
  8             print('after for')
  9             print('...')
 10             return foo.upper()
[EOF]
(Pdb) bt
...
  &lt;doctest test.test_pdb.test_pdb_basic_commands[4]&gt;(25)&lt;module&gt;()
-&gt; test_function()
  &lt;doctest test.test_pdb.test_pdb_basic_commands[3]&gt;(3)test_function()
-&gt; ret = test_function_2('baz')
&gt; &lt;doctest test.test_pdb.test_pdb_basic_commands[0]&gt;(1)test_function_2()
-&gt; def test_function_2(foo, bar='default'):
(Pdb) up
&gt; &lt;doctest test.test_pdb.test_pdb_basic_commands[3]&gt;(3)test_function()
-&gt; ret = test_function_2('baz')
(Pdb) down
&gt; &lt;doctest test.test_pdb.test_pdb_basic_commands[0]&gt;(1)test_function_2()
-&gt; def test_function_2(foo, bar='default'):
(Pdb) next
&gt; &lt;doctest test.test_pdb.test_pdb_basic_commands[0]&gt;(2)test_function_2()
-&gt; print(foo)
(Pdb) next
baz
&gt; &lt;doctest test.test_pdb.test_pdb_basic_commands[0]&gt;(3)test_function_2()
-&gt; for i in range(5):
(Pdb) step
&gt; &lt;doctest test.test_pdb.test_pdb_basic_commands[0]&gt;(4)test_function_2()
-&gt; print(i)
(Pdb) until
0
1
2
3
4
&gt; &lt;doctest test.test_pdb.test_pdb_basic_commands[0]&gt;(5)test_function_2()
-&gt; print(bar)
(Pdb) next
default
&gt; &lt;doctest test.test_pdb.test_pdb_basic_commands[0]&gt;(6)test_function_2()
-&gt; for i in range(10):
(Pdb) jump 8
&gt; &lt;doctest test.test_pdb.test_pdb_basic_commands[0]&gt;(8)test_function_2()
-&gt; print('after for')
(Pdb) return
after for
...
--Return--
&gt; &lt;doctest test.test_pdb.test_pdb_basic_commands[0]&gt;(10)test_function_2()-&gt;'BAZ'
-&gt; return foo.upper()
(Pdb) retval
'BAZ'
(Pdb) next
&gt; &lt;doctest test.test_pdb.test_pdb_basic_commands[3]&gt;(4)test_function()
-&gt; test_function3(kwonly=True)
(Pdb) step
--Call--
&gt; &lt;doctest test.test_pdb.test_pdb_basic_commands[1]&gt;(1)test_function3()
-&gt; def test_function3(arg=None, *, kwonly=None):
(Pdb) args
arg = None
kwonly = True
(Pdb) return
--Return--
&gt; &lt;doctest test.test_pdb.test_pdb_basic_commands[1]&gt;(2)test_function3()-&gt;None
-&gt; pass
(Pdb) next
&gt; &lt;doctest test.test_pdb.test_pdb_basic_commands[3]&gt;(5)test_function()
-&gt; test_function4(1, 2, 3)
(Pdb) step
--Call--
&gt; &lt;doctest test.test_pdb.test_pdb_basic_commands[2]&gt;(1)test_function4()
-&gt; def test_function4(a, b, c, /):
(Pdb) args
a = 1
b = 2
c = 3
(Pdb) continue
BAZ</p></div>
  </div>
</div><div class="basefunction">
  
  <a name="Lib.test.test_pdb.test_pdb_breakpoint_commands">
    
  </a>
  <a name="test_pdb_breakpoint_commands">
    
  </a>
  <div class="functionHeader">
    
    def
    test_pdb_breakpoint_commands():
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Test basic commands related to breakpoints.

&gt;&gt;&gt; def test_function():
...     import pdb; pdb.Pdb(nosigint=True, readrc=False).set_trace()
...     print(1)
...     print(2)
...     print(3)
...     print(4)

First, need to clear bdb state that might be left over from previous tests.
Otherwise, the new breakpoints might get assigned different numbers.

&gt;&gt;&gt; from bdb import Breakpoint
&gt;&gt;&gt; Breakpoint.next = 1
&gt;&gt;&gt; Breakpoint.bplist = {}
&gt;&gt;&gt; Breakpoint.bpbynumber = [None]

Now test the breakpoint commands.  NORMALIZE_WHITESPACE is needed because
the breakpoint list outputs a tab for the "stop only" and "ignore next"
lines, which we don't want to put in here.

&gt;&gt;&gt; with PdbTestInput([  # doctest: +NORMALIZE_WHITESPACE
...     'break 3',
...     'disable 1',
...     'ignore 1 10',
...     'condition 1 1 &lt; 2',
...     'break 4',
...     'break 4',
...     'break',
...     'clear 3',
...     'break',
...     'condition 1',
...     'enable 1',
...     'clear 1',
...     'commands 2',
...     'p "42"',
...     'print("42", 7*6)',     # Issue 18764 (not about breakpoints)
...     'end',
...     'continue',  # will stop at breakpoint 2 (line 4)
...     'clear',     # clear all!
...     'y',
...     'tbreak 5',
...     'continue',  # will stop at temporary breakpoint
...     'break',     # make sure breakpoint is gone
...     'continue',
... ]):
...    test_function()
&gt; &lt;doctest test.test_pdb.test_pdb_breakpoint_commands[0]&gt;(3)test_function()
-&gt; print(1)
(Pdb) break 3
Breakpoint 1 at &lt;doctest test.test_pdb.test_pdb_breakpoint_commands[0]&gt;:3
(Pdb) disable 1
Disabled breakpoint 1 at &lt;doctest test.test_pdb.test_pdb_breakpoint_commands[0]&gt;:3
(Pdb) ignore 1 10
Will ignore next 10 crossings of breakpoint 1.
(Pdb) condition 1 1 &lt; 2
New condition set for breakpoint 1.
(Pdb) break 4
Breakpoint 2 at &lt;doctest test.test_pdb.test_pdb_breakpoint_commands[0]&gt;:4
(Pdb) break 4
Breakpoint 3 at &lt;doctest test.test_pdb.test_pdb_breakpoint_commands[0]&gt;:4
(Pdb) break
Num Type         Disp Enb   Where
1   breakpoint   keep no    at &lt;doctest test.test_pdb.test_pdb_breakpoint_commands[0]&gt;:3
        stop only if 1 &lt; 2
        ignore next 10 hits
2   breakpoint   keep yes   at &lt;doctest test.test_pdb.test_pdb_breakpoint_commands[0]&gt;:4
3   breakpoint   keep yes   at &lt;doctest test.test_pdb.test_pdb_breakpoint_commands[0]&gt;:4
(Pdb) clear 3
Deleted breakpoint 3 at &lt;doctest test.test_pdb.test_pdb_breakpoint_commands[0]&gt;:4
(Pdb) break
Num Type         Disp Enb   Where
1   breakpoint   keep no    at &lt;doctest test.test_pdb.test_pdb_breakpoint_commands[0]&gt;:3
        stop only if 1 &lt; 2
        ignore next 10 hits
2   breakpoint   keep yes   at &lt;doctest test.test_pdb.test_pdb_breakpoint_commands[0]&gt;:4
(Pdb) condition 1
Breakpoint 1 is now unconditional.
(Pdb) enable 1
Enabled breakpoint 1 at &lt;doctest test.test_pdb.test_pdb_breakpoint_commands[0]&gt;:3
(Pdb) clear 1
Deleted breakpoint 1 at &lt;doctest test.test_pdb.test_pdb_breakpoint_commands[0]&gt;:3
(Pdb) commands 2
(com) p "42"
(com) print("42", 7*6)
(com) end
(Pdb) continue
1
'42'
42 42
&gt; &lt;doctest test.test_pdb.test_pdb_breakpoint_commands[0]&gt;(4)test_function()
-&gt; print(2)
(Pdb) clear
Clear all breaks? y
Deleted breakpoint 2 at &lt;doctest test.test_pdb.test_pdb_breakpoint_commands[0]&gt;:4
(Pdb) tbreak 5
Breakpoint 4 at &lt;doctest test.test_pdb.test_pdb_breakpoint_commands[0]&gt;:5
(Pdb) continue
2
Deleted breakpoint 4 at &lt;doctest test.test_pdb.test_pdb_breakpoint_commands[0]&gt;:5
&gt; &lt;doctest test.test_pdb.test_pdb_breakpoint_commands[0]&gt;(5)test_function()
-&gt; print(3)
(Pdb) break
(Pdb) continue
3
4</p></div>
  </div>
</div><div class="basefunction">
  
  <a name="Lib.test.test_pdb.do_nothing">
    
  </a>
  <a name="do_nothing">
    
  </a>
  <div class="functionHeader">
    
    def
    do_nothing():
    
  </div>
  <div class="docstring functionBody">
    
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basefunction">
  
  <a name="Lib.test.test_pdb.do_something">
    
  </a>
  <a name="do_something">
    
  </a>
  <div class="functionHeader">
    
    def
    do_something():
    
  </div>
  <div class="docstring functionBody">
    
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basefunction">
  
  <a name="Lib.test.test_pdb.test_list_commands">
    
  </a>
  <a name="test_list_commands">
    
  </a>
  <div class="functionHeader">
    
    def
    test_list_commands():
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Test the list and source commands of pdb.

&gt;&gt;&gt; def test_function_2(foo):
...     import test.test_pdb
...     test.test_pdb.do_nothing()
...     'some...'
...     'more...'
...     'code...'
...     'to...'
...     'make...'
...     'a...'
...     'long...'
...     'listing...'
...     'useful...'
...     '...'
...     '...'
...     return foo

&gt;&gt;&gt; def test_function():
...     import pdb; pdb.Pdb(nosigint=True, readrc=False).set_trace()
...     ret = test_function_2('baz')

&gt;&gt;&gt; with PdbTestInput([  # doctest: +ELLIPSIS, +NORMALIZE_WHITESPACE
...     'list',      # list first function
...     'step',      # step into second function
...     'list',      # list second function
...     'list',      # continue listing to EOF
...     'list 1,3',  # list specific lines
...     'list x',    # invalid argument
...     'next',      # step to import
...     'next',      # step over import
...     'step',      # step into do_nothing
...     'longlist',  # list all lines
...     'source do_something',  # list all lines of function
...     'source fooxxx',        # something that doesn't exit
...     'continue',
... ]):
...    test_function()
&gt; &lt;doctest test.test_pdb.test_list_commands[1]&gt;(3)test_function()
-&gt; ret = test_function_2('baz')
(Pdb) list
  1         def test_function():
  2             import pdb; pdb.Pdb(nosigint=True, readrc=False).set_trace()
  3  -&gt;         ret = test_function_2('baz')
[EOF]
(Pdb) step
--Call--
&gt; &lt;doctest test.test_pdb.test_list_commands[0]&gt;(1)test_function_2()
-&gt; def test_function_2(foo):
(Pdb) list
  1  -&gt;     def test_function_2(foo):
  2             import test.test_pdb
  3             test.test_pdb.do_nothing()
  4             'some...'
  5             'more...'
  6             'code...'
  7             'to...'
  8             'make...'
  9             'a...'
 10             'long...'
 11             'listing...'
(Pdb) list
 12             'useful...'
 13             '...'
 14             '...'
 15             return foo
[EOF]
(Pdb) list 1,3
  1  -&gt;     def test_function_2(foo):
  2             import test.test_pdb
  3             test.test_pdb.do_nothing()
(Pdb) list x
*** ...
(Pdb) next
&gt; &lt;doctest test.test_pdb.test_list_commands[0]&gt;(2)test_function_2()
-&gt; import test.test_pdb
(Pdb) next
&gt; &lt;doctest test.test_pdb.test_list_commands[0]&gt;(3)test_function_2()
-&gt; test.test_pdb.do_nothing()
(Pdb) step
--Call--
&gt; ...test_pdb.py(...)do_nothing()
-&gt; def do_nothing():
(Pdb) longlist
...  -&gt;     def do_nothing():
...             pass
(Pdb) source do_something
...         def do_something():
...             print(42)
(Pdb) source fooxxx
*** ...
(Pdb) continue</p></div>
  </div>
</div><div class="basefunction">
  
  <a name="Lib.test.test_pdb.test_pdb_whatis_command">
    
  </a>
  <a name="test_pdb_whatis_command">
    
  </a>
  <div class="functionHeader">
    
    def
    test_pdb_whatis_command():
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Test the whatis command

&gt;&gt;&gt; myvar = (1,2)
&gt;&gt;&gt; def myfunc():
...     pass

&gt;&gt;&gt; class MyClass:
...    def mymethod(self):
...        pass

&gt;&gt;&gt; def test_function():
...   import pdb; pdb.Pdb(nosigint=True, readrc=False).set_trace()

&gt;&gt;&gt; with PdbTestInput([  # doctest: +ELLIPSIS, +NORMALIZE_WHITESPACE
...    'whatis myvar',
...    'whatis myfunc',
...    'whatis MyClass',
...    'whatis MyClass()',
...    'whatis MyClass.mymethod',
...    'whatis MyClass().mymethod',
...    'continue',
... ]):
...    test_function()
--Return--
&gt; &lt;doctest test.test_pdb.test_pdb_whatis_command[3]&gt;(2)test_function()-&gt;None
-&gt; import pdb; pdb.Pdb(nosigint=True, readrc=False).set_trace()
(Pdb) whatis myvar
&lt;class 'tuple'&gt;
(Pdb) whatis myfunc
Function myfunc
(Pdb) whatis MyClass
Class test.test_pdb.MyClass
(Pdb) whatis MyClass()
&lt;class 'test.test_pdb.MyClass'&gt;
(Pdb) whatis MyClass.mymethod
Function mymethod
(Pdb) whatis MyClass().mymethod
Method mymethod
(Pdb) continue</p></div>
  </div>
</div><div class="basefunction">
  
  <a name="Lib.test.test_pdb.test_post_mortem">
    
  </a>
  <a name="test_post_mortem">
    
  </a>
  <div class="functionHeader">
    
    def
    test_post_mortem():
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Test post mortem traceback debugging.

&gt;&gt;&gt; def test_function_2():
...     try:
...         1/0
...     finally:
...         print('Exception!')

&gt;&gt;&gt; def test_function():
...     import pdb; pdb.Pdb(nosigint=True, readrc=False).set_trace()
...     test_function_2()
...     print('Not reached.')

&gt;&gt;&gt; with PdbTestInput([  # doctest: +ELLIPSIS, +NORMALIZE_WHITESPACE
...     'next',      # step over exception-raising call
...     'bt',        # get a backtrace
...     'list',      # list code of test_function()
...     'down',      # step into test_function_2()
...     'list',      # list code of test_function_2()
...     'continue',
... ]):
...    try:
...        test_function()
...    except ZeroDivisionError:
...        print('Correctly reraised.')
&gt; &lt;doctest test.test_pdb.test_post_mortem[1]&gt;(3)test_function()
-&gt; test_function_2()
(Pdb) next
Exception!
ZeroDivisionError: division by zero
&gt; &lt;doctest test.test_pdb.test_post_mortem[1]&gt;(3)test_function()
-&gt; test_function_2()
(Pdb) bt
...
  &lt;doctest test.test_pdb.test_post_mortem[2]&gt;(10)&lt;module&gt;()
-&gt; test_function()
&gt; &lt;doctest test.test_pdb.test_post_mortem[1]&gt;(3)test_function()
-&gt; test_function_2()
  &lt;doctest test.test_pdb.test_post_mortem[0]&gt;(3)test_function_2()
-&gt; 1/0
(Pdb) list
  1         def test_function():
  2             import pdb; pdb.Pdb(nosigint=True, readrc=False).set_trace()
  3  -&gt;         test_function_2()
  4             print('Not reached.')
[EOF]
(Pdb) down
&gt; &lt;doctest test.test_pdb.test_post_mortem[0]&gt;(3)test_function_2()
-&gt; 1/0
(Pdb) list
  1         def test_function_2():
  2             try:
  3  &gt;&gt;             1/0
  4             finally:
  5  -&gt;             print('Exception!')
[EOF]
(Pdb) continue
Correctly reraised.</p></div>
  </div>
</div><div class="basefunction">
  
  <a name="Lib.test.test_pdb.test_pdb_skip_modules">
    
  </a>
  <a name="test_pdb_skip_modules">
    
  </a>
  <div class="functionHeader">
    
    def
    test_pdb_skip_modules():
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">This illustrates the simple case of module skipping.

&gt;&gt;&gt; def skip_module():
...     import string
...     import pdb; pdb.Pdb(skip=['stri*'], nosigint=True, readrc=False).set_trace()
...     string.capwords('FOO')

&gt;&gt;&gt; with PdbTestInput([
...     'step',
...     'continue',
... ]):
...     skip_module()
&gt; &lt;doctest test.test_pdb.test_pdb_skip_modules[0]&gt;(4)skip_module()
-&gt; string.capwords('FOO')
(Pdb) step
--Return--
&gt; &lt;doctest test.test_pdb.test_pdb_skip_modules[0]&gt;(4)skip_module()-&gt;None
-&gt; string.capwords('FOO')
(Pdb) continue</p></div>
  </div>
</div><div class="basevariable">
  
  <a name="Lib.test.test_pdb.mod">
    
  </a>
  <a name="mod">
    
  </a>
  <div class="functionHeader">
    mod =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basefunction">
  
  <a name="Lib.test.test_pdb.test_pdb_skip_modules_with_callback">
    
  </a>
  <a name="test_pdb_skip_modules_with_callback">
    
  </a>
  <div class="functionHeader">
    
    def
    test_pdb_skip_modules_with_callback():
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">This illustrates skipping of modules that call into other code.

&gt;&gt;&gt; def skip_module():
...     def callback():
...         return None
...     import pdb; pdb.Pdb(skip=['module_to_skip*'], nosigint=True, readrc=False).set_trace()
...     mod.foo_pony(callback)

&gt;&gt;&gt; with PdbTestInput([
...     'step',
...     'step',
...     'step',
...     'step',
...     'step',
...     'continue',
... ]):
...     skip_module()
...     pass  # provides something to "step" to
&gt; &lt;doctest test.test_pdb.test_pdb_skip_modules_with_callback[0]&gt;(5)skip_module()
-&gt; mod.foo_pony(callback)
(Pdb) step
--Call--
&gt; &lt;doctest test.test_pdb.test_pdb_skip_modules_with_callback[0]&gt;(2)callback()
-&gt; def callback():
(Pdb) step
&gt; &lt;doctest test.test_pdb.test_pdb_skip_modules_with_callback[0]&gt;(3)callback()
-&gt; return None
(Pdb) step
--Return--
&gt; &lt;doctest test.test_pdb.test_pdb_skip_modules_with_callback[0]&gt;(3)callback()-&gt;None
-&gt; return None
(Pdb) step
--Return--
&gt; &lt;doctest test.test_pdb.test_pdb_skip_modules_with_callback[0]&gt;(5)skip_module()-&gt;None
-&gt; mod.foo_pony(callback)
(Pdb) step
&gt; &lt;doctest test.test_pdb.test_pdb_skip_modules_with_callback[1]&gt;(10)&lt;module&gt;()
-&gt; pass  # provides something to "step" to
(Pdb) continue</p></div>
  </div>
</div><div class="basefunction">
  
  <a name="Lib.test.test_pdb.test_pdb_continue_in_bottomframe">
    
  </a>
  <a name="test_pdb_continue_in_bottomframe">
    
  </a>
  <div class="functionHeader">
    
    def
    test_pdb_continue_in_bottomframe():
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Test that "continue" and "next" work properly in bottom frame (issue #5294).

&gt;&gt;&gt; def test_function():
...     import pdb, sys; inst = pdb.Pdb(nosigint=True, readrc=False)
...     inst.set_trace()
...     inst.botframe = sys._getframe()  # hackery to get the right botframe
...     print(1)
...     print(2)
...     print(3)
...     print(4)

&gt;&gt;&gt; with PdbTestInput([  # doctest: +ELLIPSIS
...     'next',
...     'break 7',
...     'continue',
...     'next',
...     'continue',
...     'continue',
... ]):
...    test_function()
&gt; &lt;doctest test.test_pdb.test_pdb_continue_in_bottomframe[0]&gt;(4)test_function()
-&gt; inst.botframe = sys._getframe()  # hackery to get the right botframe
(Pdb) next
&gt; &lt;doctest test.test_pdb.test_pdb_continue_in_bottomframe[0]&gt;(5)test_function()
-&gt; print(1)
(Pdb) break 7
Breakpoint ... at &lt;doctest test.test_pdb.test_pdb_continue_in_bottomframe[0]&gt;:7
(Pdb) continue
1
2
&gt; &lt;doctest test.test_pdb.test_pdb_continue_in_bottomframe[0]&gt;(7)test_function()
-&gt; print(3)
(Pdb) next
3
&gt; &lt;doctest test.test_pdb.test_pdb_continue_in_bottomframe[0]&gt;(8)test_function()
-&gt; print(4)
(Pdb) continue
4</p></div>
  </div>
</div><div class="basefunction">
  
  <a name="Lib.test.test_pdb.pdb_invoke">
    
  </a>
  <a name="pdb_invoke">
    
  </a>
  <div class="functionHeader">
    
    def
    pdb_invoke(method, arg):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Run pdb.method(arg).</p></div>
  </div>
</div><div class="basefunction">
  
  <a name="Lib.test.test_pdb.test_pdb_run_with_incorrect_argument">
    
  </a>
  <a name="test_pdb_run_with_incorrect_argument">
    
  </a>
  <div class="functionHeader">
    
    def
    test_pdb_run_with_incorrect_argument():
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Testing run and runeval with incorrect first argument.

&gt;&gt;&gt; pti = PdbTestInput(['continue',])
&gt;&gt;&gt; with pti:
...     pdb_invoke('run', lambda x: x)
Traceback (most recent call last):
TypeError: exec() arg 1 must be a string, bytes or code object

&gt;&gt;&gt; with pti:
...     pdb_invoke('runeval', lambda x: x)
Traceback (most recent call last):
TypeError: eval() arg 1 must be a string, bytes or code object</p></div>
  </div>
</div><div class="basefunction">
  
  <a name="Lib.test.test_pdb.test_pdb_run_with_code_object">
    
  </a>
  <a name="test_pdb_run_with_code_object">
    
  </a>
  <div class="functionHeader">
    
    def
    test_pdb_run_with_code_object():
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Testing run and runeval with code object as a first argument.

&gt;&gt;&gt; with PdbTestInput(['step','x', 'continue']):  # doctest: +ELLIPSIS
...     pdb_invoke('run', compile('x=1', '&lt;string&gt;', 'exec'))
&gt; &lt;string&gt;(1)&lt;module&gt;()...
(Pdb) step
--Return--
&gt; &lt;string&gt;(1)&lt;module&gt;()-&gt;None
(Pdb) x
1
(Pdb) continue

&gt;&gt;&gt; with PdbTestInput(['x', 'continue']):
...     x=0
...     pdb_invoke('runeval', compile('x+1', '&lt;string&gt;', 'eval'))
&gt; &lt;string&gt;(1)&lt;module&gt;()-&gt;None
(Pdb) x
1
(Pdb) continue</p></div>
  </div>
</div><div class="basefunction">
  
  <a name="Lib.test.test_pdb.test_next_until_return_at_return_event">
    
  </a>
  <a name="test_next_until_return_at_return_event">
    
  </a>
  <div class="functionHeader">
    
    def
    test_next_until_return_at_return_event():
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Test that pdb stops after a next/until/return issued at a return debug event.

&gt;&gt;&gt; def test_function_2():
...     x = 1
...     x = 2

&gt;&gt;&gt; def test_function():
...     import pdb; pdb.Pdb(nosigint=True, readrc=False).set_trace()
...     test_function_2()
...     test_function_2()
...     test_function_2()
...     end = 1

&gt;&gt;&gt; from bdb import Breakpoint
&gt;&gt;&gt; Breakpoint.next = 1
&gt;&gt;&gt; with PdbTestInput(['break test_function_2',
...                    'continue',
...                    'return',
...                    'next',
...                    'continue',
...                    'return',
...                    'until',
...                    'continue',
...                    'return',
...                    'return',
...                    'continue']):
...     test_function()
&gt; &lt;doctest test.test_pdb.test_next_until_return_at_return_event[1]&gt;(3)test_function()
-&gt; test_function_2()
(Pdb) break test_function_2
Breakpoint 1 at &lt;doctest test.test_pdb.test_next_until_return_at_return_event[0]&gt;:1
(Pdb) continue
&gt; &lt;doctest test.test_pdb.test_next_until_return_at_return_event[0]&gt;(2)test_function_2()
-&gt; x = 1
(Pdb) return
--Return--
&gt; &lt;doctest test.test_pdb.test_next_until_return_at_return_event[0]&gt;(3)test_function_2()-&gt;None
-&gt; x = 2
(Pdb) next
&gt; &lt;doctest test.test_pdb.test_next_until_return_at_return_event[1]&gt;(4)test_function()
-&gt; test_function_2()
(Pdb) continue
&gt; &lt;doctest test.test_pdb.test_next_until_return_at_return_event[0]&gt;(2)test_function_2()
-&gt; x = 1
(Pdb) return
--Return--
&gt; &lt;doctest test.test_pdb.test_next_until_return_at_return_event[0]&gt;(3)test_function_2()-&gt;None
-&gt; x = 2
(Pdb) until
&gt; &lt;doctest test.test_pdb.test_next_until_return_at_return_event[1]&gt;(5)test_function()
-&gt; test_function_2()
(Pdb) continue
&gt; &lt;doctest test.test_pdb.test_next_until_return_at_return_event[0]&gt;(2)test_function_2()
-&gt; x = 1
(Pdb) return
--Return--
&gt; &lt;doctest test.test_pdb.test_next_until_return_at_return_event[0]&gt;(3)test_function_2()-&gt;None
-&gt; x = 2
(Pdb) return
&gt; &lt;doctest test.test_pdb.test_next_until_return_at_return_event[1]&gt;(6)test_function()
-&gt; end = 1
(Pdb) continue</p></div>
  </div>
</div><div class="basefunction">
  
  <a name="Lib.test.test_pdb.test_pdb_next_command_for_generator">
    
  </a>
  <a name="test_pdb_next_command_for_generator">
    
  </a>
  <div class="functionHeader">
    
    def
    test_pdb_next_command_for_generator():
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Testing skip unwindng stack on yield for generators for "next" command

&gt;&gt;&gt; def test_gen():
...     yield 0
...     return 1
...     yield 2

&gt;&gt;&gt; def test_function():
...     import pdb; pdb.Pdb(nosigint=True, readrc=False).set_trace()
...     it = test_gen()
...     try:
...         if next(it) != 0:
...             raise AssertionError
...         next(it)
...     except StopIteration as ex:
...         if ex.value != 1:
...             raise AssertionError
...     print("finished")

&gt;&gt;&gt; with PdbTestInput(['step',
...                    'step',
...                    'step',
...                    'next',
...                    'next',
...                    'step',
...                    'step',
...                    'continue']):
...     test_function()
&gt; &lt;doctest test.test_pdb.test_pdb_next_command_for_generator[1]&gt;(3)test_function()
-&gt; it = test_gen()
(Pdb) step
&gt; &lt;doctest test.test_pdb.test_pdb_next_command_for_generator[1]&gt;(4)test_function()
-&gt; try:
(Pdb) step
&gt; &lt;doctest test.test_pdb.test_pdb_next_command_for_generator[1]&gt;(5)test_function()
-&gt; if next(it) != 0:
(Pdb) step
--Call--
&gt; &lt;doctest test.test_pdb.test_pdb_next_command_for_generator[0]&gt;(1)test_gen()
-&gt; def test_gen():
(Pdb) next
&gt; &lt;doctest test.test_pdb.test_pdb_next_command_for_generator[0]&gt;(2)test_gen()
-&gt; yield 0
(Pdb) next
&gt; &lt;doctest test.test_pdb.test_pdb_next_command_for_generator[0]&gt;(3)test_gen()
-&gt; return 1
(Pdb) step
--Return--
&gt; &lt;doctest test.test_pdb.test_pdb_next_command_for_generator[0]&gt;(3)test_gen()-&gt;1
-&gt; return 1
(Pdb) step
StopIteration: 1
&gt; &lt;doctest test.test_pdb.test_pdb_next_command_for_generator[1]&gt;(7)test_function()
-&gt; next(it)
(Pdb) continue
finished</p></div>
  </div>
</div><div class="basefunction">
  
  <a name="Lib.test.test_pdb.test_pdb_next_command_for_coroutine">
    
  </a>
  <a name="test_pdb_next_command_for_coroutine">
    
  </a>
  <div class="functionHeader">
    
    def
    test_pdb_next_command_for_coroutine():
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Testing skip unwindng stack on yield for coroutines for "next" command

&gt;&gt;&gt; import asyncio

&gt;&gt;&gt; async def test_coro():
...     await asyncio.sleep(0)
...     await asyncio.sleep(0)
...     await asyncio.sleep(0)

&gt;&gt;&gt; async def test_main():
...     import pdb; pdb.Pdb(nosigint=True, readrc=False).set_trace()
...     await test_coro()

&gt;&gt;&gt; def test_function():
...     loop = asyncio.new_event_loop()
...     loop.run_until_complete(test_main())
...     loop.close()
...     asyncio.set_event_loop_policy(None)
...     print("finished")

&gt;&gt;&gt; with PdbTestInput(['step',
...                    'step',
...                    'next',
...                    'next',
...                    'next',
...                    'step',
...                    'continue']):
...     test_function()
&gt; &lt;doctest test.test_pdb.test_pdb_next_command_for_coroutine[2]&gt;(3)test_main()
-&gt; await test_coro()
(Pdb) step
--Call--
&gt; &lt;doctest test.test_pdb.test_pdb_next_command_for_coroutine[1]&gt;(1)test_coro()
-&gt; async def test_coro():
(Pdb) step
&gt; &lt;doctest test.test_pdb.test_pdb_next_command_for_coroutine[1]&gt;(2)test_coro()
-&gt; await asyncio.sleep(0)
(Pdb) next
&gt; &lt;doctest test.test_pdb.test_pdb_next_command_for_coroutine[1]&gt;(3)test_coro()
-&gt; await asyncio.sleep(0)
(Pdb) next
&gt; &lt;doctest test.test_pdb.test_pdb_next_command_for_coroutine[1]&gt;(4)test_coro()
-&gt; await asyncio.sleep(0)
(Pdb) next
Internal StopIteration
&gt; &lt;doctest test.test_pdb.test_pdb_next_command_for_coroutine[2]&gt;(3)test_main()
-&gt; await test_coro()
(Pdb) step
--Return--
&gt; &lt;doctest test.test_pdb.test_pdb_next_command_for_coroutine[2]&gt;(3)test_main()-&gt;None
-&gt; await test_coro()
(Pdb) continue
finished</p></div>
  </div>
</div><div class="basefunction">
  
  <a name="Lib.test.test_pdb.test_pdb_next_command_for_asyncgen">
    
  </a>
  <a name="test_pdb_next_command_for_asyncgen">
    
  </a>
  <div class="functionHeader">
    
    def
    test_pdb_next_command_for_asyncgen():
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Testing skip unwindng stack on yield for coroutines for "next" command

&gt;&gt;&gt; import asyncio

&gt;&gt;&gt; async def agen():
...     yield 1
...     await asyncio.sleep(0)
...     yield 2

&gt;&gt;&gt; async def test_coro():
...     async for x in agen():
...         print(x)

&gt;&gt;&gt; async def test_main():
...     import pdb; pdb.Pdb(nosigint=True, readrc=False).set_trace()
...     await test_coro()

&gt;&gt;&gt; def test_function():
...     loop = asyncio.new_event_loop()
...     loop.run_until_complete(test_main())
...     loop.close()
...     asyncio.set_event_loop_policy(None)
...     print("finished")

&gt;&gt;&gt; with PdbTestInput(['step',
...                    'step',
...                    'next',
...                    'next',
...                    'step',
...                    'next',
...                    'continue']):
...     test_function()
&gt; &lt;doctest test.test_pdb.test_pdb_next_command_for_asyncgen[3]&gt;(3)test_main()
-&gt; await test_coro()
(Pdb) step
--Call--
&gt; &lt;doctest test.test_pdb.test_pdb_next_command_for_asyncgen[2]&gt;(1)test_coro()
-&gt; async def test_coro():
(Pdb) step
&gt; &lt;doctest test.test_pdb.test_pdb_next_command_for_asyncgen[2]&gt;(2)test_coro()
-&gt; async for x in agen():
(Pdb) next
&gt; &lt;doctest test.test_pdb.test_pdb_next_command_for_asyncgen[2]&gt;(3)test_coro()
-&gt; print(x)
(Pdb) next
1
&gt; &lt;doctest test.test_pdb.test_pdb_next_command_for_asyncgen[2]&gt;(2)test_coro()
-&gt; async for x in agen():
(Pdb) step
--Call--
&gt; &lt;doctest test.test_pdb.test_pdb_next_command_for_asyncgen[1]&gt;(2)agen()
-&gt; yield 1
(Pdb) next
&gt; &lt;doctest test.test_pdb.test_pdb_next_command_for_asyncgen[1]&gt;(3)agen()
-&gt; await asyncio.sleep(0)
(Pdb) continue
2
finished</p></div>
  </div>
</div><div class="basefunction">
  
  <a name="Lib.test.test_pdb.test_pdb_return_command_for_generator">
    
  </a>
  <a name="test_pdb_return_command_for_generator">
    
  </a>
  <div class="functionHeader">
    
    def
    test_pdb_return_command_for_generator():
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Testing no unwindng stack on yield for generators
   for "return" command

&gt;&gt;&gt; def test_gen():
...     yield 0
...     return 1
...     yield 2

&gt;&gt;&gt; def test_function():
...     import pdb; pdb.Pdb(nosigint=True, readrc=False).set_trace()
...     it = test_gen()
...     try:
...         if next(it) != 0:
...             raise AssertionError
...         next(it)
...     except StopIteration as ex:
...         if ex.value != 1:
...             raise AssertionError
...     print("finished")

&gt;&gt;&gt; with PdbTestInput(['step',
...                    'step',
...                    'step',
...                    'return',
...                    'step',
...                    'step',
...                    'continue']):
...     test_function()
&gt; &lt;doctest test.test_pdb.test_pdb_return_command_for_generator[1]&gt;(3)test_function()
-&gt; it = test_gen()
(Pdb) step
&gt; &lt;doctest test.test_pdb.test_pdb_return_command_for_generator[1]&gt;(4)test_function()
-&gt; try:
(Pdb) step
&gt; &lt;doctest test.test_pdb.test_pdb_return_command_for_generator[1]&gt;(5)test_function()
-&gt; if next(it) != 0:
(Pdb) step
--Call--
&gt; &lt;doctest test.test_pdb.test_pdb_return_command_for_generator[0]&gt;(1)test_gen()
-&gt; def test_gen():
(Pdb) return
StopIteration: 1
&gt; &lt;doctest test.test_pdb.test_pdb_return_command_for_generator[1]&gt;(7)test_function()
-&gt; next(it)
(Pdb) step
&gt; &lt;doctest test.test_pdb.test_pdb_return_command_for_generator[1]&gt;(8)test_function()
-&gt; except StopIteration as ex:
(Pdb) step
&gt; &lt;doctest test.test_pdb.test_pdb_return_command_for_generator[1]&gt;(9)test_function()
-&gt; if ex.value != 1:
(Pdb) continue
finished</p></div>
  </div>
</div><div class="basefunction">
  
  <a name="Lib.test.test_pdb.test_pdb_return_command_for_coroutine">
    
  </a>
  <a name="test_pdb_return_command_for_coroutine">
    
  </a>
  <div class="functionHeader">
    
    def
    test_pdb_return_command_for_coroutine():
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Testing no unwindng stack on yield for coroutines for "return" command

&gt;&gt;&gt; import asyncio

&gt;&gt;&gt; async def test_coro():
...     await asyncio.sleep(0)
...     await asyncio.sleep(0)
...     await asyncio.sleep(0)

&gt;&gt;&gt; async def test_main():
...     import pdb; pdb.Pdb(nosigint=True, readrc=False).set_trace()
...     await test_coro()

&gt;&gt;&gt; def test_function():
...     loop = asyncio.new_event_loop()
...     loop.run_until_complete(test_main())
...     loop.close()
...     asyncio.set_event_loop_policy(None)
...     print("finished")

&gt;&gt;&gt; with PdbTestInput(['step',
...                    'step',
...                    'next',
...                    'continue']):
...     test_function()
&gt; &lt;doctest test.test_pdb.test_pdb_return_command_for_coroutine[2]&gt;(3)test_main()
-&gt; await test_coro()
(Pdb) step
--Call--
&gt; &lt;doctest test.test_pdb.test_pdb_return_command_for_coroutine[1]&gt;(1)test_coro()
-&gt; async def test_coro():
(Pdb) step
&gt; &lt;doctest test.test_pdb.test_pdb_return_command_for_coroutine[1]&gt;(2)test_coro()
-&gt; await asyncio.sleep(0)
(Pdb) next
&gt; &lt;doctest test.test_pdb.test_pdb_return_command_for_coroutine[1]&gt;(3)test_coro()
-&gt; await asyncio.sleep(0)
(Pdb) continue
finished</p></div>
  </div>
</div><div class="basefunction">
  
  <a name="Lib.test.test_pdb.test_pdb_until_command_for_generator">
    
  </a>
  <a name="test_pdb_until_command_for_generator">
    
  </a>
  <div class="functionHeader">
    
    def
    test_pdb_until_command_for_generator():
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Testing no unwindng stack on yield for generators
   for "until" command if target breakpoint is not reached

&gt;&gt;&gt; def test_gen():
...     yield 0
...     yield 1
...     yield 2

&gt;&gt;&gt; def test_function():
...     import pdb; pdb.Pdb(nosigint=True, readrc=False).set_trace()
...     for i in test_gen():
...         print(i)
...     print("finished")

&gt;&gt;&gt; with PdbTestInput(['step',
...                    'until 4',
...                    'step',
...                    'step',
...                    'continue']):
...     test_function()
&gt; &lt;doctest test.test_pdb.test_pdb_until_command_for_generator[1]&gt;(3)test_function()
-&gt; for i in test_gen():
(Pdb) step
--Call--
&gt; &lt;doctest test.test_pdb.test_pdb_until_command_for_generator[0]&gt;(1)test_gen()
-&gt; def test_gen():
(Pdb) until 4
0
1
&gt; &lt;doctest test.test_pdb.test_pdb_until_command_for_generator[0]&gt;(4)test_gen()
-&gt; yield 2
(Pdb) step
--Return--
&gt; &lt;doctest test.test_pdb.test_pdb_until_command_for_generator[0]&gt;(4)test_gen()-&gt;2
-&gt; yield 2
(Pdb) step
&gt; &lt;doctest test.test_pdb.test_pdb_until_command_for_generator[1]&gt;(4)test_function()
-&gt; print(i)
(Pdb) continue
2
finished</p></div>
  </div>
</div><div class="basefunction">
  
  <a name="Lib.test.test_pdb.test_pdb_until_command_for_coroutine">
    
  </a>
  <a name="test_pdb_until_command_for_coroutine">
    
  </a>
  <div class="functionHeader">
    
    def
    test_pdb_until_command_for_coroutine():
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Testing no unwindng stack for coroutines
   for "until" command if target breakpoint is not reached

&gt;&gt;&gt; import asyncio

&gt;&gt;&gt; async def test_coro():
...     print(0)
...     await asyncio.sleep(0)
...     print(1)
...     await asyncio.sleep(0)
...     print(2)
...     await asyncio.sleep(0)
...     print(3)

&gt;&gt;&gt; async def test_main():
...     import pdb; pdb.Pdb(nosigint=True, readrc=False).set_trace()
...     await test_coro()

&gt;&gt;&gt; def test_function():
...     loop = asyncio.new_event_loop()
...     loop.run_until_complete(test_main())
...     loop.close()
...     asyncio.set_event_loop_policy(None)
...     print("finished")

&gt;&gt;&gt; with PdbTestInput(['step',
...                    'until 8',
...                    'continue']):
...     test_function()
&gt; &lt;doctest test.test_pdb.test_pdb_until_command_for_coroutine[2]&gt;(3)test_main()
-&gt; await test_coro()
(Pdb) step
--Call--
&gt; &lt;doctest test.test_pdb.test_pdb_until_command_for_coroutine[1]&gt;(1)test_coro()
-&gt; async def test_coro():
(Pdb) until 8
0
1
2
&gt; &lt;doctest test.test_pdb.test_pdb_until_command_for_coroutine[1]&gt;(8)test_coro()
-&gt; print(3)
(Pdb) continue
3
finished</p></div>
  </div>
</div><div class="basefunction">
  
  <a name="Lib.test.test_pdb.test_pdb_next_command_in_generator_for_loop">
    
  </a>
  <a name="test_pdb_next_command_in_generator_for_loop">
    
  </a>
  <div class="functionHeader">
    
    def
    test_pdb_next_command_in_generator_for_loop():
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">The next command on returning from a generator controlled by a for loop.

&gt;&gt;&gt; def test_gen():
...     yield 0
...     return 1

&gt;&gt;&gt; def test_function():
...     import pdb; pdb.Pdb(nosigint=True, readrc=False).set_trace()
...     for i in test_gen():
...         print('value', i)
...     x = 123

&gt;&gt;&gt; with PdbTestInput(['break test_gen',
...                    'continue',
...                    'next',
...                    'next',
...                    'next',
...                    'continue']):
...     test_function()
&gt; &lt;doctest test.test_pdb.test_pdb_next_command_in_generator_for_loop[1]&gt;(3)test_function()
-&gt; for i in test_gen():
(Pdb) break test_gen
Breakpoint 6 at &lt;doctest test.test_pdb.test_pdb_next_command_in_generator_for_loop[0]&gt;:1
(Pdb) continue
&gt; &lt;doctest test.test_pdb.test_pdb_next_command_in_generator_for_loop[0]&gt;(2)test_gen()
-&gt; yield 0
(Pdb) next
value 0
&gt; &lt;doctest test.test_pdb.test_pdb_next_command_in_generator_for_loop[0]&gt;(3)test_gen()
-&gt; return 1
(Pdb) next
Internal StopIteration: 1
&gt; &lt;doctest test.test_pdb.test_pdb_next_command_in_generator_for_loop[1]&gt;(3)test_function()
-&gt; for i in test_gen():
(Pdb) next
&gt; &lt;doctest test.test_pdb.test_pdb_next_command_in_generator_for_loop[1]&gt;(5)test_function()
-&gt; x = 123
(Pdb) continue</p></div>
  </div>
</div><div class="basefunction">
  
  <a name="Lib.test.test_pdb.test_pdb_next_command_subiterator">
    
  </a>
  <a name="test_pdb_next_command_subiterator">
    
  </a>
  <div class="functionHeader">
    
    def
    test_pdb_next_command_subiterator():
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">The next command in a generator with a subiterator.

&gt;&gt;&gt; def test_subgenerator():
...     yield 0
...     return 1

&gt;&gt;&gt; def test_gen():
...     x = yield from test_subgenerator()
...     return x

&gt;&gt;&gt; def test_function():
...     import pdb; pdb.Pdb(nosigint=True, readrc=False).set_trace()
...     for i in test_gen():
...         print('value', i)
...     x = 123

&gt;&gt;&gt; with PdbTestInput(['step',
...                    'step',
...                    'next',
...                    'next',
...                    'next',
...                    'continue']):
...     test_function()
&gt; &lt;doctest test.test_pdb.test_pdb_next_command_subiterator[2]&gt;(3)test_function()
-&gt; for i in test_gen():
(Pdb) step
--Call--
&gt; &lt;doctest test.test_pdb.test_pdb_next_command_subiterator[1]&gt;(1)test_gen()
-&gt; def test_gen():
(Pdb) step
&gt; &lt;doctest test.test_pdb.test_pdb_next_command_subiterator[1]&gt;(2)test_gen()
-&gt; x = yield from test_subgenerator()
(Pdb) next
value 0
&gt; &lt;doctest test.test_pdb.test_pdb_next_command_subiterator[1]&gt;(3)test_gen()
-&gt; return x
(Pdb) next
Internal StopIteration: 1
&gt; &lt;doctest test.test_pdb.test_pdb_next_command_subiterator[2]&gt;(3)test_function()
-&gt; for i in test_gen():
(Pdb) next
&gt; &lt;doctest test.test_pdb.test_pdb_next_command_subiterator[2]&gt;(5)test_function()
-&gt; x = 123
(Pdb) continue</p></div>
  </div>
</div><div class="basefunction">
  
  <a name="Lib.test.test_pdb.test_pdb_issue_20766">
    
  </a>
  <a name="test_pdb_issue_20766">
    
  </a>
  <div class="functionHeader">
    
    def
    test_pdb_issue_20766():
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Test for reference leaks when the SIGINT handler is set.

&gt;&gt;&gt; def test_function():
...     i = 1
...     while i &lt;= 2:
...         sess = pdb.Pdb()
...         sess.set_trace(sys._getframe())
...         print('pdb %d: %s' % (i, sess._previous_sigint_handler))
...         i += 1

&gt;&gt;&gt; with PdbTestInput(['continue',
...                    'continue']):
...     test_function()
&gt; &lt;doctest test.test_pdb.test_pdb_issue_20766[0]&gt;(6)test_function()
-&gt; print('pdb %d: %s' % (i, sess._previous_sigint_handler))
(Pdb) continue
pdb 1: &lt;built-in function default_int_handler&gt;
&gt; &lt;doctest test.test_pdb.test_pdb_issue_20766[0]&gt;(5)test_function()
-&gt; sess.set_trace(sys._getframe())
(Pdb) continue
pdb 2: &lt;built-in function default_int_handler&gt;</p></div>
  </div>
</div><div class="basefunction">
  
  <a name="Lib.test.test_pdb.load_tests">
    
  </a>
  <a name="load_tests">
    
  </a>
  <div class="functionHeader">
    
    def
    load_tests(*args):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div class="undocumented">Undocumented</div>
  </div>
</div>

      </div>
      <address>
        <a href="index.html">API Documentation</a> for Python3.8, generated by <a href="https://github.com/twisted/pydoctor/">pydoctor</a> 20.7.1 at 2020-11-24 05:11:37.
      </address>

    </div>

    <script src="pydoctor.js" type="text/javascript"></script>

  </body>
</html>