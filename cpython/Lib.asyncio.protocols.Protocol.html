<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
          "DTD/xhtml1-strict.dtd">
<html>
  <head>
    <title>Lib.asyncio.protocols.Protocol : API documentation</title>

    <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
    <link rel="stylesheet" type="text/css" href="bootstrap.min.css" />
    <link rel="stylesheet" type="text/css" href="apidocs.css" />
  </head>
  <body>

    <nav class="navbar navbar-default">
      <div class="container">
        <div class="navbar-header">
          <a class="navbar-brand" href="index.html">
            Python3.8 API Documentation
          </a>
        </div>
      </div>
    </nav>

    <div id="showPrivate">
      <button class="btn btn-link" onclick="togglePrivate()">Toggle Private API</button>
    </div>

    <div class="container">

      <div class="page-header">
        <h1 class="class"><code><a href="Lib.html" class="code" data-type="Package">Lib</a>.<a href="Lib.asyncio.html" class="code" data-type="Package">asyncio</a>.<a href="Lib.asyncio.protocols.html" class="code" data-type="Module">protocols</a>.<a href="Lib.asyncio.protocols.Protocol.html" class="code" data-type="Class">Protocol</a></code></h1>
      </div>

      <div class="categoryHeader">
        class documentation
      </div>

      <div class="extrasDocstring">
        <p><code><span class="py-keyword">class</span> Lib.asyncio.protocols.Protocol(<a href="Lib.asyncio.protocols.BaseProtocol.html" class="code" data-type="Class">BaseProtocol</a>):</code></p>
        <p><a href="classIndex.html#Lib.asyncio.protocols.Protocol">View In Hierarchy</a></p>
      </div>

      <div class="moduleDocstring">
        <div><p class="pre">Interface for stream protocol.

The user should implement this interface.  They can inherit from
this class but don't need to.  The implementations here do
nothing (they don't raise exceptions).

When the user wants to requests a transport, they pass a protocol
factory to a utility function (e.g., EventLoop.create_connection()).

When the connection is made successfully, connection_made() is
called with a suitable transport object.  Then data_received()
will be called 0 or more times with data (bytes) received from the
transport; finally, connection_lost() will be called exactly once
with either an exception object or None as an argument.

State machine of calls:

  start -&gt; CM [-&gt; DR*] [-&gt; ER?] -&gt; CL -&gt; end

* CM: connection_made()
* DR: data_received()
* ER: eof_received()
* CL: connection_lost()</p></div>
      </div>

      <div id="splitTables">
        <table class="children sortable" id="id355">
  
  <tr class="classvariable">
    
    <td>Class Variable</td>
    <td><a href="Lib.asyncio.protocols.Protocol.html#__slots__" class="code" data-type="Class Variable">__slots__</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.asyncio.protocols.Protocol.html#data_received" class="code" data-type="Method">data_received</a></td>
    <td><span>Called when some data is received.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.asyncio.protocols.Protocol.html#eof_received" class="code" data-type="Method">eof_received</a></td>
    <td><span>Called when the other end calls write_eof() or equivalent.</span></td>
  </tr>
</table>
        
          <p class="inheritedFrom">
            Inherited from <a href="Lib.asyncio.protocols.BaseProtocol.html" class="code" data-type="Class">BaseProtocol</a>:
          </p>
          <table class="children sortable" id="id356">
  
  <tr class="basemethod">
    
    <td>Method</td>
    <td><a href="Lib.asyncio.protocols.BaseProtocol.html#connection_made" class="code" data-type="Method">connection_made</a></td>
    <td><span>Called when a connection is made.</span></td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><a href="Lib.asyncio.protocols.BaseProtocol.html#connection_lost" class="code" data-type="Method">connection_lost</a></td>
    <td><span>Called when the connection is lost or closed.</span></td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><a href="Lib.asyncio.protocols.BaseProtocol.html#pause_writing" class="code" data-type="Method">pause_writing</a></td>
    <td><span>Called when the transport's buffer goes over the high-water mark.</span></td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><a href="Lib.asyncio.protocols.BaseProtocol.html#resume_writing" class="code" data-type="Method">resume_writing</a></td>
    <td><span>Called when the transport's buffer drains below the low-water mark.</span></td>
  </tr>
</table>
          

          
      </div>

      <div id="childList">

        <div class="baseclassvariable">
  
  <a name="Lib.asyncio.protocols.Protocol.__slots__">
    
  </a>
  <a name="__slots__">
    
  </a>
  <div class="functionHeader">
    __slots__ =
    
  </div>
  <div class="functionBody">
    <div class="interfaceinfo">overrides <a href="Lib.asyncio.protocols.BaseProtocol.html#__slots__" class="code" data-type="Class Variable">Lib.asyncio.protocols.BaseProtocol.__slots__</a></div>
    <div class="undocumented">Undocumented</div> (type: <code>Tuple</code>)
  </div>
</div><div class="basemethod">
  
  <a name="Lib.asyncio.protocols.Protocol.data_received">
    
  </a>
  <a name="data_received">
    
  </a>
  <div class="functionHeader">
    
    def
    data_received(self, data):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Called when some data is received.

The argument is a bytes object.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.asyncio.protocols.Protocol.eof_received">
    
  </a>
  <a name="eof_received">
    
  </a>
  <div class="functionHeader">
    
    def
    eof_received(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Called when the other end calls write_eof() or equivalent.

If this returns a false value (including None), the transport
will close itself.  If it returns a true value, closing the
transport is up to the protocol.</p></div>
  </div>
</div>

      </div>
      <address>
        <a href="index.html">API Documentation</a> for Python3.8, generated by <a href="https://github.com/twisted/pydoctor/">pydoctor</a> 20.7.1 at 2020-11-24 05:02:55.
      </address>

    </div>

    <script src="pydoctor.js" type="text/javascript"></script>

  </body>
</html>