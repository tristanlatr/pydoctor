<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
          "DTD/xhtml1-strict.dtd">
<html>
  <head>
    <title>Lib.email._encoded_words : API documentation</title>

    <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
    <link rel="stylesheet" type="text/css" href="bootstrap.min.css" />
    <link rel="stylesheet" type="text/css" href="apidocs.css" />
  </head>
  <body>

    <nav class="navbar navbar-default">
      <div class="container">
        <div class="navbar-header">
          <a class="navbar-brand" href="index.html">
            Python3.8 API Documentation
          </a>
        </div>
      </div>
    </nav>

    <div id="showPrivate">
      <button class="btn btn-link" onclick="togglePrivate()">Toggle Private API</button>
    </div>

    <div class="container">

      <div class="page-header">
        <h1 class="module private"><code><a href="Lib.html" class="code" data-type="Package">Lib</a>.<a href="Lib.email.html" class="code" data-type="Package">email</a>.<a href="Lib.email._encoded_words.html" class="code" data-type="Module">_encoded_words</a></code></h1>
      </div>

      <div class="categoryHeader">
        module documentation
      </div>

      <div class="extrasDocstring">
        
        <p></p>
      </div>

      <div class="moduleDocstring">
        <div><p class="pre">Routines for manipulating RFC2047 encoded words.

This is currently a package-private API, but will be considered for promotion
to a public API if there is demand.</p></div>
      </div>

      <div id="splitTables">
        <table class="children sortable" id="id1134">
  
  <tr class="function">
    
    <td>Function</td>
    <td><a href="Lib.email._encoded_words.html#decode_q" class="code" data-type="Function">decode_q</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><a href="Lib.email._encoded_words.html#encode_q" class="code" data-type="Function">encode_q</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><a href="Lib.email._encoded_words.html#len_q" class="code" data-type="Function">len_q</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><a href="Lib.email._encoded_words.html#decode_b" class="code" data-type="Function">decode_b</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><a href="Lib.email._encoded_words.html#encode_b" class="code" data-type="Function">encode_b</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><a href="Lib.email._encoded_words.html#len_b" class="code" data-type="Function">len_b</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><a href="Lib.email._encoded_words.html#decode" class="code" data-type="Function">decode</a></td>
    <td><span>Decode encoded word and return (string, charset, lang, defects) tuple.</span></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><a href="Lib.email._encoded_words.html#encode" class="code" data-type="Function">encode</a></td>
    <td><span>Encode string using the CTE encoding that produces the shorter result.</span></td>
  </tr><tr class="variable private">
    
    <td>Variable</td>
    <td><a href="Lib.email._encoded_words.html#_q_byte_subber" class="code" data-type="Variable">_q_byte_subber</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="class private">
    
    <td>Class</td>
    <td><a href="Lib.email._encoded_words._QByteMap.html" class="code" data-type="Class">_QByteMap</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="variable private">
    
    <td>Variable</td>
    <td><a href="Lib.email._encoded_words.html#_q_byte_map" class="code" data-type="Variable">_q_byte_map</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="variable private">
    
    <td>Variable</td>
    <td><a href="Lib.email._encoded_words.html#_cte_decoders" class="code" data-type="Variable">_cte_decoders</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="variable private">
    
    <td>Variable</td>
    <td><a href="Lib.email._encoded_words.html#_cte_encoders" class="code" data-type="Variable">_cte_encoders</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="variable private">
    
    <td>Variable</td>
    <td><a href="Lib.email._encoded_words.html#_cte_encode_length" class="code" data-type="Variable">_cte_encode_length</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr>
</table>
        

          
      </div>

      <div id="childList">

        <div class="basevariable private">
  
  <a name="Lib.email._encoded_words._q_byte_subber">
    
  </a>
  <a name="_q_byte_subber">
    
  </a>
  <div class="functionHeader">
    _q_byte_subber =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basefunction">
  
  <a name="Lib.email._encoded_words.decode_q">
    
  </a>
  <a name="decode_q">
    
  </a>
  <div class="functionHeader">
    
    def
    decode_q(encoded):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basevariable private">
  
  <a name="Lib.email._encoded_words._q_byte_map">
    
  </a>
  <a name="_q_byte_map">
    
  </a>
  <div class="functionHeader">
    _q_byte_map =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basefunction">
  
  <a name="Lib.email._encoded_words.encode_q">
    
  </a>
  <a name="encode_q">
    
  </a>
  <div class="functionHeader">
    
    def
    encode_q(bstring):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basefunction">
  
  <a name="Lib.email._encoded_words.len_q">
    
  </a>
  <a name="len_q">
    
  </a>
  <div class="functionHeader">
    
    def
    len_q(bstring):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basefunction">
  
  <a name="Lib.email._encoded_words.decode_b">
    
  </a>
  <a name="decode_b">
    
  </a>
  <div class="functionHeader">
    
    def
    decode_b(encoded):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basefunction">
  
  <a name="Lib.email._encoded_words.encode_b">
    
  </a>
  <a name="encode_b">
    
  </a>
  <div class="functionHeader">
    
    def
    encode_b(bstring):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basefunction">
  
  <a name="Lib.email._encoded_words.len_b">
    
  </a>
  <a name="len_b">
    
  </a>
  <div class="functionHeader">
    
    def
    len_b(bstring):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basevariable private">
  
  <a name="Lib.email._encoded_words._cte_decoders">
    
  </a>
  <a name="_cte_decoders">
    
  </a>
  <div class="functionHeader">
    _cte_decoders =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basefunction">
  
  <a name="Lib.email._encoded_words.decode">
    
  </a>
  <a name="decode">
    
  </a>
  <div class="functionHeader">
    
    def
    decode(ew):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Decode encoded word and return (string, charset, lang, defects) tuple.

An RFC 2047/2243 encoded word has the form:

    =?charset*lang?cte?encoded_string?=

where '*lang' may be omitted but the other parts may not be.

This function expects exactly such a string (that is, it does not check the
syntax and may raise errors if the string is not well formed), and returns
the encoded_string decoded first from its Content Transfer Encoding and
then from the resulting bytes into unicode using the specified charset.  If
the cte-decoded string does not successfully decode using the specified
character set, a defect is added to the defects list and the unknown octets
are replaced by the unicode 'unknown' character \uFDFF.

The specified charset and language are returned.  The default for language,
which is rarely if ever encountered, is the empty string.</p></div>
  </div>
</div><div class="basevariable private">
  
  <a name="Lib.email._encoded_words._cte_encoders">
    
  </a>
  <a name="_cte_encoders">
    
  </a>
  <div class="functionHeader">
    _cte_encoders =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basevariable private">
  
  <a name="Lib.email._encoded_words._cte_encode_length">
    
  </a>
  <a name="_cte_encode_length">
    
  </a>
  <div class="functionHeader">
    _cte_encode_length =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basefunction">
  
  <a name="Lib.email._encoded_words.encode">
    
  </a>
  <a name="encode">
    
  </a>
  <div class="functionHeader">
    
    def
    encode(string, charset="""utf-8""", encoding=None, lang=""""""):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Encode string using the CTE encoding that produces the shorter result.

Produces an RFC 2047/2243 encoded word of the form:

    =?charset*lang?cte?encoded_string?=

where '*lang' is omitted unless the 'lang' parameter is given a value.
Optional argument charset (defaults to utf-8) specifies the charset to use
to encode the string to binary before CTE encoding it.  Optional argument
'encoding' is the cte specifier for the encoding that should be used ('q'
or 'b'); if it is None (the default) the encoding which produces the
shortest encoded sequence is used, except that 'q' is preferred if it is up
to five characters longer.  Optional argument 'lang' (default '') gives the
RFC 2243 language string to specify in the encoded word.</p></div>
  </div>
</div>

      </div>
      <address>
        <a href="index.html">API Documentation</a> for Python3.8, generated by <a href="https://github.com/twisted/pydoctor/">pydoctor</a> 20.7.1 at 2020-11-24 05:40:36.
      </address>

    </div>

    <script src="pydoctor.js" type="text/javascript"></script>

  </body>
</html>