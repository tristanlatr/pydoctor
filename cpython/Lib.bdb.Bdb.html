<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
          "DTD/xhtml1-strict.dtd">
<html>
  <head>
    <title>Lib.bdb.Bdb : API documentation</title>

    <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
    <link rel="stylesheet" type="text/css" href="bootstrap.min.css" />
    <link rel="stylesheet" type="text/css" href="apidocs.css" />
  </head>
  <body>

    <nav class="navbar navbar-default">
      <div class="container">
        <div class="navbar-header">
          <a class="navbar-brand" href="index.html">
            Python3.8 API Documentation
          </a>
        </div>
      </div>
    </nav>

    <div id="showPrivate">
      <button class="btn btn-link" onclick="togglePrivate()">Toggle Private API</button>
    </div>

    <div class="container">

      <div class="page-header">
        <h1 class="class"><code><a href="Lib.html" class="code" data-type="Package">Lib</a>.<a href="Lib.bdb.html" class="code" data-type="Module">bdb</a>.<a href="Lib.bdb.Bdb.html" class="code" data-type="Class">Bdb</a></code></h1>
      </div>

      <div class="categoryHeader">
        class documentation
      </div>

      <div class="extrasDocstring">
        <p><code><span class="py-keyword">class</span> Lib.bdb.Bdb:</code></p><p>Known subclasses: <a href="Lib.bdb.Tdb.html" class="code" data-type="Class">Lib.bdb.Tdb</a></p>
        <p><a href="classIndex.html#Lib.bdb.Bdb">View In Hierarchy</a></p>
      </div>

      <div class="moduleDocstring">
        <div><p class="pre">Generic Python debugger base class.

This class takes care of details of the trace facility;
a derived class should implement user interaction.
The standard debugger class (pdb.Pdb) is an example.

The optional skip argument must be an iterable of glob-style
module name patterns.  The debugger will not step into frames
that originate in a module that matches one of these patterns.
Whether a frame is considered to originate in a certain module
is determined by the __name__ in the frame globals.</p></div>
      </div>

      <div id="splitTables">
        <table class="children sortable" id="id456">
  
  <tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.bdb.Bdb.html#__init__" class="code" data-type="Method">__init__</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="instancevariable">
    
    <td>Instance Variable</td>
    <td><a href="Lib.bdb.Bdb.html#skip" class="code" data-type="Instance Variable">skip</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="instancevariable">
    
    <td>Instance Variable</td>
    <td><a href="Lib.bdb.Bdb.html#breaks" class="code" data-type="Instance Variable">breaks</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="instancevariable">
    
    <td>Instance Variable</td>
    <td><a href="Lib.bdb.Bdb.html#fncache" class="code" data-type="Instance Variable">fncache</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="instancevariable">
    
    <td>Instance Variable</td>
    <td><a href="Lib.bdb.Bdb.html#frame_returning" class="code" data-type="Instance Variable">frame_returning</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.bdb.Bdb.html#canonic" class="code" data-type="Method">canonic</a></td>
    <td><span>Return canonical form of filename.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.bdb.Bdb.html#reset" class="code" data-type="Method">reset</a></td>
    <td><span>Set values of attributes as ready to start debugging.</span></td>
  </tr><tr class="instancevariable">
    
    <td>Instance Variable</td>
    <td><a href="Lib.bdb.Bdb.html#botframe" class="code" data-type="Instance Variable">botframe</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.bdb.Bdb.html#trace_dispatch" class="code" data-type="Method">trace_dispatch</a></td>
    <td><span>Dispatch a trace function for debugged frames based on the event.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.bdb.Bdb.html#dispatch_line" class="code" data-type="Method">dispatch_line</a></td>
    <td><span>Invoke user function and return trace function for line event.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.bdb.Bdb.html#dispatch_call" class="code" data-type="Method">dispatch_call</a></td>
    <td><span>Invoke user function and return trace function for call event.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.bdb.Bdb.html#dispatch_return" class="code" data-type="Method">dispatch_return</a></td>
    <td><span>Invoke user function and return trace function for return event.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.bdb.Bdb.html#dispatch_exception" class="code" data-type="Method">dispatch_exception</a></td>
    <td><span>Invoke user function and return trace function for exception event.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.bdb.Bdb.html#is_skipped_module" class="code" data-type="Method">is_skipped_module</a></td>
    <td><span>Return True if module_name matches any skip pattern.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.bdb.Bdb.html#stop_here" class="code" data-type="Method">stop_here</a></td>
    <td><span>Return True if frame is below the starting frame in the stack.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.bdb.Bdb.html#break_here" class="code" data-type="Method">break_here</a></td>
    <td><span>Return True if there is an effective breakpoint for this line.</span></td>
  </tr><tr class="instancevariable">
    
    <td>Instance Variable</td>
    <td><a href="Lib.bdb.Bdb.html#currentbp" class="code" data-type="Instance Variable">currentbp</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.bdb.Bdb.html#do_clear" class="code" data-type="Method">do_clear</a></td>
    <td><span>Remove temporary breakpoint.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.bdb.Bdb.html#break_anywhere" class="code" data-type="Method">break_anywhere</a></td>
    <td><span>Return True if there is any breakpoint for frame's filename.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.bdb.Bdb.html#user_call" class="code" data-type="Method">user_call</a></td>
    <td><span>Called if we might stop in a function.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.bdb.Bdb.html#user_line" class="code" data-type="Method">user_line</a></td>
    <td><span>Called when we stop or break at a line.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.bdb.Bdb.html#user_return" class="code" data-type="Method">user_return</a></td>
    <td><span>Called when a return trap is set here.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.bdb.Bdb.html#user_exception" class="code" data-type="Method">user_exception</a></td>
    <td><span>Called when we stop on an exception.</span></td>
  </tr><tr class="instancevariable">
    
    <td>Instance Variable</td>
    <td><a href="Lib.bdb.Bdb.html#stopframe" class="code" data-type="Instance Variable">stopframe</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="instancevariable">
    
    <td>Instance Variable</td>
    <td><a href="Lib.bdb.Bdb.html#returnframe" class="code" data-type="Instance Variable">returnframe</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="instancevariable">
    
    <td>Instance Variable</td>
    <td><a href="Lib.bdb.Bdb.html#quitting" class="code" data-type="Instance Variable">quitting</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="instancevariable">
    
    <td>Instance Variable</td>
    <td><a href="Lib.bdb.Bdb.html#stoplineno" class="code" data-type="Instance Variable">stoplineno</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.bdb.Bdb.html#set_until" class="code" data-type="Method">set_until</a></td>
    <td><span>Stop when the line with the lineno greater than the current one is reached or when returning from current frame.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.bdb.Bdb.html#set_step" class="code" data-type="Method">set_step</a></td>
    <td><span>Stop after one line of code.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.bdb.Bdb.html#set_next" class="code" data-type="Method">set_next</a></td>
    <td><span>Stop on the next line in or below the given frame.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.bdb.Bdb.html#set_return" class="code" data-type="Method">set_return</a></td>
    <td><span>Stop when returning from the given frame.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.bdb.Bdb.html#set_trace" class="code" data-type="Method">set_trace</a></td>
    <td><span>Start debugging from frame.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.bdb.Bdb.html#set_continue" class="code" data-type="Method">set_continue</a></td>
    <td><span>Stop only at breakpoints or when finished.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.bdb.Bdb.html#set_quit" class="code" data-type="Method">set_quit</a></td>
    <td><span>Set quitting attribute to True.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.bdb.Bdb.html#set_break" class="code" data-type="Method">set_break</a></td>
    <td><span>Set a new breakpoint for filename:lineno.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.bdb.Bdb.html#clear_break" class="code" data-type="Method">clear_break</a></td>
    <td><span>Delete breakpoints for filename:lineno.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.bdb.Bdb.html#clear_bpbynumber" class="code" data-type="Method">clear_bpbynumber</a></td>
    <td><span>Delete a breakpoint by its index in Breakpoint.bpbynumber.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.bdb.Bdb.html#clear_all_file_breaks" class="code" data-type="Method">clear_all_file_breaks</a></td>
    <td><span>Delete all breakpoints in filename.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.bdb.Bdb.html#clear_all_breaks" class="code" data-type="Method">clear_all_breaks</a></td>
    <td><span>Delete all existing breakpoints.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.bdb.Bdb.html#get_bpbynumber" class="code" data-type="Method">get_bpbynumber</a></td>
    <td><span>Return a breakpoint by its index in Breakpoint.bybpnumber.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.bdb.Bdb.html#get_break" class="code" data-type="Method">get_break</a></td>
    <td><span>Return True if there is a breakpoint for filename:lineno.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.bdb.Bdb.html#get_breaks" class="code" data-type="Method">get_breaks</a></td>
    <td><span>Return all breakpoints for filename:lineno.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.bdb.Bdb.html#get_file_breaks" class="code" data-type="Method">get_file_breaks</a></td>
    <td><span>Return all lines with breakpoints for filename.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.bdb.Bdb.html#get_all_breaks" class="code" data-type="Method">get_all_breaks</a></td>
    <td><span>Return all breakpoints that are set.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.bdb.Bdb.html#get_stack" class="code" data-type="Method">get_stack</a></td>
    <td><span>Return a list of (frame, lineno) in a stack trace and a size.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.bdb.Bdb.html#format_stack_entry" class="code" data-type="Method">format_stack_entry</a></td>
    <td><span>Return a string with information about a stack entry.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.bdb.Bdb.html#run" class="code" data-type="Method">run</a></td>
    <td><span>Debug a statement executed via the exec() function.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.bdb.Bdb.html#runeval" class="code" data-type="Method">runeval</a></td>
    <td><span>Debug an expression executed via the eval() function.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.bdb.Bdb.html#runctx" class="code" data-type="Method">runctx</a></td>
    <td><span>For backwards-compatibility.  Defers to run().</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.bdb.Bdb.html#runcall" class="code" data-type="Method">runcall</a></td>
    <td><span>Debug a single function call.</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><a href="Lib.bdb.Bdb.html#_set_stopinfo" class="code" data-type="Method">_set_stopinfo</a></td>
    <td><span>Set the attributes for stopping.</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><a href="Lib.bdb.Bdb.html#_prune_breaks" class="code" data-type="Method">_prune_breaks</a></td>
    <td><span>Prune breakpoints for filename:lineno.</span></td>
  </tr>
</table>
        

          
      </div>

      <div id="childList">

        <div class="basemethod">
  
  <a name="Lib.bdb.Bdb.__init__">
    
  </a>
  <a name="__init__">
    
  </a>
  <div class="functionHeader">
    
    def
    __init__(self, skip=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="baseinstancevariable">
  
  <a name="Lib.bdb.Bdb.skip">
    
  </a>
  <a name="skip">
    
  </a>
  <div class="functionHeader">
    skip =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="baseinstancevariable">
  
  <a name="Lib.bdb.Bdb.breaks">
    
  </a>
  <a name="breaks">
    
  </a>
  <div class="functionHeader">
    breaks =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div> (type: <code>Dict</code>)
  </div>
</div><div class="baseinstancevariable">
  
  <a name="Lib.bdb.Bdb.fncache">
    
  </a>
  <a name="fncache">
    
  </a>
  <div class="functionHeader">
    fncache =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div> (type: <code>Dict</code>)
  </div>
</div><div class="baseinstancevariable">
  
  <a name="Lib.bdb.Bdb.frame_returning">
    
  </a>
  <a name="frame_returning">
    
  </a>
  <div class="functionHeader">
    frame_returning =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.bdb.Bdb.canonic">
    
  </a>
  <a name="canonic">
    
  </a>
  <div class="functionHeader">
    
    def
    canonic(self, filename):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Return canonical form of filename.

For real filenames, the canonical form is a case-normalized (on
case insensitive filesystems) absolute path.  'Filenames' with
angle brackets, such as "&lt;stdin&gt;", generated in interactive
mode, are returned unchanged.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.bdb.Bdb.reset">
    
  </a>
  <a name="reset">
    
  </a>
  <div class="functionHeader">
    
    def
    reset(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Set values of attributes as ready to start debugging.</p></div>
  </div>
</div><div class="baseinstancevariable">
  
  <a name="Lib.bdb.Bdb.botframe">
    
  </a>
  <a name="botframe">
    
  </a>
  <div class="functionHeader">
    botframe =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.bdb.Bdb.trace_dispatch">
    
  </a>
  <a name="trace_dispatch">
    
  </a>
  <div class="functionHeader">
    
    def
    trace_dispatch(self, frame, event, arg):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Dispatch a trace function for debugged frames based on the event.

This function is installed as the trace function for debugged
frames. Its return value is the new trace function, which is
usually itself. The default implementation decides how to
dispatch a frame, depending on the type of event (passed in as a
string) that is about to be executed.

The event can be one of the following:
    line: A new line of code is going to be executed.
    call: A function is about to be called or another code block
          is entered.
    return: A function or other code block is about to return.
    exception: An exception has occurred.
    c_call: A C function is about to be called.
    c_return: A C function has returned.
    c_exception: A C function has raised an exception.

For the Python events, specialized functions (see the dispatch_*()
methods) are called.  For the C events, no action is taken.

The arg parameter depends on the previous event.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.bdb.Bdb.dispatch_line">
    
  </a>
  <a name="dispatch_line">
    
  </a>
  <div class="functionHeader">
    
    def
    dispatch_line(self, frame):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Invoke user function and return trace function for line event.

If the debugger stops on the current line, invoke
self.user_line(). Raise BdbQuit if self.quitting is set.
Return self.trace_dispatch to continue tracing in this scope.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.bdb.Bdb.dispatch_call">
    
  </a>
  <a name="dispatch_call">
    
  </a>
  <div class="functionHeader">
    
    def
    dispatch_call(self, frame, arg):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Invoke user function and return trace function for call event.

If the debugger stops on this function call, invoke
self.user_call(). Raise BbdQuit if self.quitting is set.
Return self.trace_dispatch to continue tracing in this scope.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.bdb.Bdb.dispatch_return">
    
  </a>
  <a name="dispatch_return">
    
  </a>
  <div class="functionHeader">
    
    def
    dispatch_return(self, frame, arg):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Invoke user function and return trace function for return event.

If the debugger stops on this function return, invoke
self.user_return(). Raise BdbQuit if self.quitting is set.
Return self.trace_dispatch to continue tracing in this scope.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.bdb.Bdb.dispatch_exception">
    
  </a>
  <a name="dispatch_exception">
    
  </a>
  <div class="functionHeader">
    
    def
    dispatch_exception(self, frame, arg):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Invoke user function and return trace function for exception event.

If the debugger stops on this exception, invoke
self.user_exception(). Raise BdbQuit if self.quitting is set.
Return self.trace_dispatch to continue tracing in this scope.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.bdb.Bdb.is_skipped_module">
    
  </a>
  <a name="is_skipped_module">
    
  </a>
  <div class="functionHeader">
    
    def
    is_skipped_module(self, module_name):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Return True if module_name matches any skip pattern.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.bdb.Bdb.stop_here">
    
  </a>
  <a name="stop_here">
    
  </a>
  <div class="functionHeader">
    
    def
    stop_here(self, frame):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Return True if frame is below the starting frame in the stack.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.bdb.Bdb.break_here">
    
  </a>
  <a name="break_here">
    
  </a>
  <div class="functionHeader">
    
    def
    break_here(self, frame):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Return True if there is an effective breakpoint for this line.

Check for line or function breakpoint and if in effect.
Delete temporary breakpoints if effective() says to.</p></div>
  </div>
</div><div class="baseinstancevariable">
  
  <a name="Lib.bdb.Bdb.currentbp">
    
  </a>
  <a name="currentbp">
    
  </a>
  <div class="functionHeader">
    currentbp =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.bdb.Bdb.do_clear">
    
  </a>
  <a name="do_clear">
    
  </a>
  <div class="functionHeader">
    
    def
    do_clear(self, arg):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Remove temporary breakpoint.

Must implement in derived classes or get NotImplementedError.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.bdb.Bdb.break_anywhere">
    
  </a>
  <a name="break_anywhere">
    
  </a>
  <div class="functionHeader">
    
    def
    break_anywhere(self, frame):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Return True if there is any breakpoint for frame's filename.
        </p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.bdb.Bdb.user_call">
    
  </a>
  <a name="user_call">
    
  </a>
  <div class="functionHeader">
    
    def
    user_call(self, frame, argument_list):
    
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overridden in <a href="Lib.bdb.Tdb.html" class="code" data-type="Class">Lib.bdb.Tdb</a></div>
    
    <div><p class="pre">Called if we might stop in a function.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.bdb.Bdb.user_line">
    
  </a>
  <a name="user_line">
    
  </a>
  <div class="functionHeader">
    
    def
    user_line(self, frame):
    
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overridden in <a href="Lib.bdb.Tdb.html" class="code" data-type="Class">Lib.bdb.Tdb</a></div>
    
    <div><p class="pre">Called when we stop or break at a line.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.bdb.Bdb.user_return">
    
  </a>
  <a name="user_return">
    
  </a>
  <div class="functionHeader">
    
    def
    user_return(self, frame, return_value):
    
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overridden in <a href="Lib.bdb.Tdb.html" class="code" data-type="Class">Lib.bdb.Tdb</a></div>
    
    <div><p class="pre">Called when a return trap is set here.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.bdb.Bdb.user_exception">
    
  </a>
  <a name="user_exception">
    
  </a>
  <div class="functionHeader">
    
    def
    user_exception(self, frame, exc_info):
    
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overridden in <a href="Lib.bdb.Tdb.html" class="code" data-type="Class">Lib.bdb.Tdb</a></div>
    
    <div><p class="pre">Called when we stop on an exception.</p></div>
  </div>
</div><div class="basemethod private">
  
  <a name="Lib.bdb.Bdb._set_stopinfo">
    
  </a>
  <a name="_set_stopinfo">
    
  </a>
  <div class="functionHeader">
    
    def
    _set_stopinfo(self, stopframe, returnframe, stoplineno=0):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Set the attributes for stopping.

If stoplineno is greater than or equal to 0, then stop at line
greater than or equal to the stopline.  If stoplineno is -1, then
don't stop at all.</p></div>
  </div>
</div><div class="baseinstancevariable">
  
  <a name="Lib.bdb.Bdb.stopframe">
    
  </a>
  <a name="stopframe">
    
  </a>
  <div class="functionHeader">
    stopframe =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="baseinstancevariable">
  
  <a name="Lib.bdb.Bdb.returnframe">
    
  </a>
  <a name="returnframe">
    
  </a>
  <div class="functionHeader">
    returnframe =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="baseinstancevariable">
  
  <a name="Lib.bdb.Bdb.quitting">
    
  </a>
  <a name="quitting">
    
  </a>
  <div class="functionHeader">
    quitting =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div> (type: <code>bool</code>)
  </div>
</div><div class="baseinstancevariable">
  
  <a name="Lib.bdb.Bdb.stoplineno">
    
  </a>
  <a name="stoplineno">
    
  </a>
  <div class="functionHeader">
    stoplineno =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.bdb.Bdb.set_until">
    
  </a>
  <a name="set_until">
    
  </a>
  <div class="functionHeader">
    
    def
    set_until(self, frame, lineno=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Stop when the line with the lineno greater than the current one is
reached or when returning from current frame.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.bdb.Bdb.set_step">
    
  </a>
  <a name="set_step">
    
  </a>
  <div class="functionHeader">
    
    def
    set_step(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Stop after one line of code.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.bdb.Bdb.set_next">
    
  </a>
  <a name="set_next">
    
  </a>
  <div class="functionHeader">
    
    def
    set_next(self, frame):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Stop on the next line in or below the given frame.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.bdb.Bdb.set_return">
    
  </a>
  <a name="set_return">
    
  </a>
  <div class="functionHeader">
    
    def
    set_return(self, frame):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Stop when returning from the given frame.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.bdb.Bdb.set_trace">
    
  </a>
  <a name="set_trace">
    
  </a>
  <div class="functionHeader">
    
    def
    set_trace(self, frame=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Start debugging from frame.

If frame is not specified, debugging starts from caller's frame.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.bdb.Bdb.set_continue">
    
  </a>
  <a name="set_continue">
    
  </a>
  <div class="functionHeader">
    
    def
    set_continue(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Stop only at breakpoints or when finished.

If there are no breakpoints, set the system trace function to None.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.bdb.Bdb.set_quit">
    
  </a>
  <a name="set_quit">
    
  </a>
  <div class="functionHeader">
    
    def
    set_quit(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Set quitting attribute to True.

Raises BdbQuit exception in the next call to a dispatch_*() method.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.bdb.Bdb.set_break">
    
  </a>
  <a name="set_break">
    
  </a>
  <div class="functionHeader">
    
    def
    set_break(self, filename, lineno, temporary=(False), cond=None, funcname=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Set a new breakpoint for filename:lineno.

If lineno doesn't exist for the filename, return an error message.
The filename should be in canonical form.</p></div>
  </div>
</div><div class="basemethod private">
  
  <a name="Lib.bdb.Bdb._prune_breaks">
    
  </a>
  <a name="_prune_breaks">
    
  </a>
  <div class="functionHeader">
    
    def
    _prune_breaks(self, filename, lineno):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Prune breakpoints for filename:lineno.

A list of breakpoints is maintained in the Bdb instance and in
the Breakpoint class.  If a breakpoint in the Bdb instance no
longer exists in the Breakpoint class, then it's removed from the
Bdb instance.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.bdb.Bdb.clear_break">
    
  </a>
  <a name="clear_break">
    
  </a>
  <div class="functionHeader">
    
    def
    clear_break(self, filename, lineno):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Delete breakpoints for filename:lineno.

If no breakpoints were set, return an error message.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.bdb.Bdb.clear_bpbynumber">
    
  </a>
  <a name="clear_bpbynumber">
    
  </a>
  <div class="functionHeader">
    
    def
    clear_bpbynumber(self, arg):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Delete a breakpoint by its index in Breakpoint.bpbynumber.

If arg is invalid, return an error message.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.bdb.Bdb.clear_all_file_breaks">
    
  </a>
  <a name="clear_all_file_breaks">
    
  </a>
  <div class="functionHeader">
    
    def
    clear_all_file_breaks(self, filename):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Delete all breakpoints in filename.

If none were set, return an error message.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.bdb.Bdb.clear_all_breaks">
    
  </a>
  <a name="clear_all_breaks">
    
  </a>
  <div class="functionHeader">
    
    def
    clear_all_breaks(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Delete all existing breakpoints.

If none were set, return an error message.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.bdb.Bdb.get_bpbynumber">
    
  </a>
  <a name="get_bpbynumber">
    
  </a>
  <div class="functionHeader">
    
    def
    get_bpbynumber(self, arg):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Return a breakpoint by its index in Breakpoint.bybpnumber.

For invalid arg values or if the breakpoint doesn't exist,
raise a ValueError.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.bdb.Bdb.get_break">
    
  </a>
  <a name="get_break">
    
  </a>
  <div class="functionHeader">
    
    def
    get_break(self, filename, lineno):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Return True if there is a breakpoint for filename:lineno.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.bdb.Bdb.get_breaks">
    
  </a>
  <a name="get_breaks">
    
  </a>
  <div class="functionHeader">
    
    def
    get_breaks(self, filename, lineno):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Return all breakpoints for filename:lineno.

If no breakpoints are set, return an empty list.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.bdb.Bdb.get_file_breaks">
    
  </a>
  <a name="get_file_breaks">
    
  </a>
  <div class="functionHeader">
    
    def
    get_file_breaks(self, filename):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Return all lines with breakpoints for filename.

If no breakpoints are set, return an empty list.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.bdb.Bdb.get_all_breaks">
    
  </a>
  <a name="get_all_breaks">
    
  </a>
  <div class="functionHeader">
    
    def
    get_all_breaks(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Return all breakpoints that are set.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.bdb.Bdb.get_stack">
    
  </a>
  <a name="get_stack">
    
  </a>
  <div class="functionHeader">
    
    def
    get_stack(self, f, t):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Return a list of (frame, lineno) in a stack trace and a size.

List starts with original calling frame, if there is one.
Size may be number of frames above or below f.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.bdb.Bdb.format_stack_entry">
    
  </a>
  <a name="format_stack_entry">
    
  </a>
  <div class="functionHeader">
    
    def
    format_stack_entry(self, frame_lineno, lprefix=""": """):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Return a string with information about a stack entry.

The stack entry frame_lineno is a (frame, lineno) tuple.  The
return string contains the canonical filename, the function name
or '&lt;lambda&gt;', the input arguments, the return value, and the
line of code (if it exists).</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.bdb.Bdb.run">
    
  </a>
  <a name="run">
    
  </a>
  <div class="functionHeader">
    
    def
    run(self, cmd, globals=None, locals=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Debug a statement executed via the exec() function.

globals defaults to __main__.dict; locals defaults to globals.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.bdb.Bdb.runeval">
    
  </a>
  <a name="runeval">
    
  </a>
  <div class="functionHeader">
    
    def
    runeval(self, expr, globals=None, locals=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Debug an expression executed via the eval() function.

globals defaults to __main__.dict; locals defaults to globals.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.bdb.Bdb.runctx">
    
  </a>
  <a name="runctx">
    
  </a>
  <div class="functionHeader">
    
    def
    runctx(self, cmd, globals, locals):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">For backwards-compatibility.  Defers to run().</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.bdb.Bdb.runcall">
    
  </a>
  <a name="runcall">
    
  </a>
  <div class="functionHeader">
    
    def
    runcall(*args, **kwds):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Debug a single function call.

Return the result of the function call.</p></div>
  </div>
</div>

      </div>
      <address>
        <a href="index.html">API Documentation</a> for Python3.8, generated by <a href="https://github.com/twisted/pydoctor/">pydoctor</a> 20.7.1 at 2020-11-24 05:11:37.
      </address>

    </div>

    <script src="pydoctor.js" type="text/javascript"></script>

  </body>
</html>