<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
          "DTD/xhtml1-strict.dtd">
<html>
  <head>
    <title>Lib._pyio.BufferedIOBase : API documentation</title>

    <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
    <link rel="stylesheet" type="text/css" href="bootstrap.min.css" />
    <link rel="stylesheet" type="text/css" href="apidocs.css" />
  </head>
  <body>

    <nav class="navbar navbar-default">
      <div class="container">
        <div class="navbar-header">
          <a class="navbar-brand" href="index.html">
            Python3.8 API Documentation
          </a>
        </div>
      </div>
    </nav>

    <div id="showPrivate">
      <button class="btn btn-link" onclick="togglePrivate()">Toggle Private API</button>
    </div>

    <div class="container">

      <div class="page-header">
        <h1 class="class"><code><a href="Lib.html" class="code" data-type="Package">Lib</a>.<a href="Lib._pyio.html" class="code" data-type="Module">_pyio</a>.<a href="Lib._pyio.BufferedIOBase.html" class="code" data-type="Class">BufferedIOBase</a></code></h1>
      </div>

      <div class="categoryHeader">
        class documentation
      </div>

      <div class="extrasDocstring">
        <p><code><span class="py-keyword">class</span> Lib._pyio.BufferedIOBase(<a href="Lib._pyio.IOBase.html" class="code" data-type="Class">IOBase</a>):</code></p><p>Known subclasses: <a href="Lib._pyio._BufferedIOMixin.html" class="code" data-type="Class">Lib._pyio._BufferedIOMixin</a>, <a href="Lib._pyio.BufferedRWPair.html" class="code" data-type="Class">Lib._pyio.BufferedRWPair</a>, <a href="Lib._pyio.BytesIO.html" class="code" data-type="Class">Lib._pyio.BytesIO</a></p>
        <p><a href="classIndex.html#Lib._pyio.BufferedIOBase">View In Hierarchy</a></p>
      </div>

      <div class="moduleDocstring">
        <div><p class="pre">Base class for buffered IO objects.

The main difference with RawIOBase is that the read() method
supports omitting the size argument, and does not have a default
implementation that defers to readinto().

In addition, read(), readinto() and write() may raise
BlockingIOError if the underlying raw stream is in non-blocking
mode and not ready; unlike their raw counterparts, they will never
return None.

A typical implementation should not inherit from a RawIOBase
implementation, but wrap one.</p></div>
      </div>

      <div id="splitTables">
        <table class="children sortable" id="id140">
  
  <tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pyio.BufferedIOBase.html#read" class="code" data-type="Method">read</a></td>
    <td><span>Read and return up to size bytes, where size is an int.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pyio.BufferedIOBase.html#read1" class="code" data-type="Method">read1</a></td>
    <td><span>Read up to size bytes with at most one read() system call, where size is an int.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pyio.BufferedIOBase.html#readinto" class="code" data-type="Method">readinto</a></td>
    <td><span>Read bytes into a pre-allocated bytes-like object b.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pyio.BufferedIOBase.html#readinto1" class="code" data-type="Method">readinto1</a></td>
    <td><span>Read bytes into buffer *b*, using at most one system call</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pyio.BufferedIOBase.html#write" class="code" data-type="Method">write</a></td>
    <td><span>Write the given bytes buffer to the IO stream.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib._pyio.BufferedIOBase.html#detach" class="code" data-type="Method">detach</a></td>
    <td><span>Separate the underlying raw stream from the buffer and return it.</span></td>
  </tr><tr class="method private">
    
    <td>Method</td>
    <td><a href="Lib._pyio.BufferedIOBase.html#_readinto" class="code" data-type="Method">_readinto</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr>
</table>
        
          <p class="inheritedFrom">
            Inherited from <a href="Lib._pyio.IOBase.html" class="code" data-type="Class">IOBase</a>:
          </p>
          <table class="children sortable" id="id141">
  
  <tr class="basemethod">
    
    <td>Method</td>
    <td><a href="Lib._pyio.IOBase.html#seek" class="code" data-type="Method">seek</a></td>
    <td><span>Change stream position.</span></td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><a href="Lib._pyio.IOBase.html#tell" class="code" data-type="Method">tell</a></td>
    <td><span>Return an int indicating the current stream position.</span></td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><a href="Lib._pyio.IOBase.html#truncate" class="code" data-type="Method">truncate</a></td>
    <td><span>Truncate file to size bytes.</span></td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><a href="Lib._pyio.IOBase.html#flush" class="code" data-type="Method">flush</a></td>
    <td><span>Flush write buffers, if applicable.</span></td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><a href="Lib._pyio.IOBase.html#close" class="code" data-type="Method">close</a></td>
    <td><span>Flush and close the IO object.</span></td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><a href="Lib._pyio.IOBase.html#__del__" class="code" data-type="Method">__del__</a></td>
    <td><span>Destructor.  Calls close().</span></td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><a href="Lib._pyio.IOBase.html#seekable" class="code" data-type="Method">seekable</a></td>
    <td><span>Return a bool indicating whether object supports random access.</span></td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><a href="Lib._pyio.IOBase.html#readable" class="code" data-type="Method">readable</a></td>
    <td><span>Return a bool indicating whether object was opened for reading.</span></td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><a href="Lib._pyio.IOBase.html#writable" class="code" data-type="Method">writable</a></td>
    <td><span>Return a bool indicating whether object was opened for writing.</span></td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><a href="Lib._pyio.IOBase.html#closed" class="code" data-type="Method">closed</a></td>
    <td><span>closed: bool.  True iff the file has been closed.</span></td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><a href="Lib._pyio.IOBase.html#__enter__" class="code" data-type="Method">__enter__</a></td>
    <td><span>Context management protocol.  Returns self (an instance of IOBase).</span></td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><a href="Lib._pyio.IOBase.html#__exit__" class="code" data-type="Method">__exit__</a></td>
    <td><span>Context management protocol.  Calls close()</span></td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><a href="Lib._pyio.IOBase.html#fileno" class="code" data-type="Method">fileno</a></td>
    <td><span>Returns underlying file descriptor (an int) if one exists.</span></td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><a href="Lib._pyio.IOBase.html#isatty" class="code" data-type="Method">isatty</a></td>
    <td><span>Return a bool indicating whether this is an 'interactive' stream.</span></td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><a href="Lib._pyio.IOBase.html#readline" class="code" data-type="Method">readline</a></td>
    <td><span>Read and return a line of bytes from the stream.</span></td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><a href="Lib._pyio.IOBase.html#__iter__" class="code" data-type="Method">__iter__</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><a href="Lib._pyio.IOBase.html#__next__" class="code" data-type="Method">__next__</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><a href="Lib._pyio.IOBase.html#readlines" class="code" data-type="Method">readlines</a></td>
    <td><span>Return a list of lines from the stream.</span></td>
  </tr><tr class="basemethod">
    
    <td>Method</td>
    <td><a href="Lib._pyio.IOBase.html#writelines" class="code" data-type="Method">writelines</a></td>
    <td><span>Write a list of lines to the stream.</span></td>
  </tr><tr class="basemethod private">
    
    <td>Method</td>
    <td><a href="Lib._pyio.IOBase.html#_unsupported" class="code" data-type="Method">_unsupported</a></td>
    <td><span>Internal: raise an OSError exception for unsupported operations.</span></td>
  </tr><tr class="baseinstancevariable private">
    
    <td>Instance Variable</td>
    <td><a href="Lib._pyio.IOBase.html#__closed" class="code" data-type="Instance Variable">__closed</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="basemethod private">
    
    <td>Method</td>
    <td><a href="Lib._pyio.IOBase.html#_checkSeekable" class="code" data-type="Method">_checkSeekable</a></td>
    <td><span>Internal: raise UnsupportedOperation if file is not seekable</span></td>
  </tr><tr class="basemethod private">
    
    <td>Method</td>
    <td><a href="Lib._pyio.IOBase.html#_checkReadable" class="code" data-type="Method">_checkReadable</a></td>
    <td><span>Internal: raise UnsupportedOperation if file is not readable</span></td>
  </tr><tr class="basemethod private">
    
    <td>Method</td>
    <td><a href="Lib._pyio.IOBase.html#_checkWritable" class="code" data-type="Method">_checkWritable</a></td>
    <td><span>Internal: raise UnsupportedOperation if file is not writable</span></td>
  </tr><tr class="basemethod private">
    
    <td>Method</td>
    <td><a href="Lib._pyio.IOBase.html#_checkClosed" class="code" data-type="Method">_checkClosed</a></td>
    <td><span>Internal: raise a ValueError if file is closed</span></td>
  </tr>
</table>
          

          
      </div>

      <div id="childList">

        <div class="basemethod">
  
  <a name="Lib._pyio.BufferedIOBase.read">
    
  </a>
  <a name="read">
    
  </a>
  <div class="functionHeader">
    
    def
    read(self, size=(-1)):
    
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overridden in <a href="Lib._pyio.BufferedRandom.html" class="code" data-type="Class">Lib._pyio.BufferedRandom</a>, <a href="Lib._pyio.BufferedReader.html" class="code" data-type="Class">Lib._pyio.BufferedReader</a>, <a href="Lib._pyio.BufferedRWPair.html" class="code" data-type="Class">Lib._pyio.BufferedRWPair</a>, <a href="Lib._pyio.BytesIO.html" class="code" data-type="Class">Lib._pyio.BytesIO</a></div>
    
    <div><p class="pre">Read and return up to size bytes, where size is an int.

If the argument is omitted, None, or negative, reads and
returns all data until EOF.

If the argument is positive, and the underlying raw stream is
not 'interactive', multiple raw reads may be issued to satisfy
the byte count (unless EOF is reached first).  But for
interactive raw streams (XXX and for pipes?), at most one raw
read will be issued, and a short result does not imply that
EOF is imminent.

Returns an empty bytes array on EOF.

Raises BlockingIOError if the underlying raw stream has no
data at the moment.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pyio.BufferedIOBase.read1">
    
  </a>
  <a name="read1">
    
  </a>
  <div class="functionHeader">
    
    def
    read1(self, size=(-1)):
    
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overridden in <a href="Lib._pyio.BufferedRandom.html" class="code" data-type="Class">Lib._pyio.BufferedRandom</a>, <a href="Lib._pyio.BufferedReader.html" class="code" data-type="Class">Lib._pyio.BufferedReader</a>, <a href="Lib._pyio.BufferedRWPair.html" class="code" data-type="Class">Lib._pyio.BufferedRWPair</a>, <a href="Lib._pyio.BytesIO.html" class="code" data-type="Class">Lib._pyio.BytesIO</a></div>
    
    <div><p class="pre">Read up to size bytes with at most one read() system call,
where size is an int.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pyio.BufferedIOBase.readinto">
    
  </a>
  <a name="readinto">
    
  </a>
  <div class="functionHeader">
    
    def
    readinto(self, b):
    
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overridden in <a href="Lib._pyio.BufferedRandom.html" class="code" data-type="Class">Lib._pyio.BufferedRandom</a>, <a href="Lib._pyio.BufferedRandom.html" class="code" data-type="Class">Lib._pyio.BufferedRandom</a>, <a href="Lib._pyio.BufferedRWPair.html" class="code" data-type="Class">Lib._pyio.BufferedRWPair</a></div>
    
    <div><p class="pre">Read bytes into a pre-allocated bytes-like object b.

Like read(), this may issue multiple reads to the underlying raw
stream, unless the latter is 'interactive'.

Returns an int representing the number of bytes read (0 for EOF).

Raises BlockingIOError if the underlying raw stream has no
data at the moment.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pyio.BufferedIOBase.readinto1">
    
  </a>
  <a name="readinto1">
    
  </a>
  <div class="functionHeader">
    
    def
    readinto1(self, b):
    
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overridden in <a href="Lib._pyio.BufferedRandom.html" class="code" data-type="Class">Lib._pyio.BufferedRandom</a>, <a href="Lib._pyio.BufferedRandom.html" class="code" data-type="Class">Lib._pyio.BufferedRandom</a>, <a href="Lib._pyio.BufferedRWPair.html" class="code" data-type="Class">Lib._pyio.BufferedRWPair</a></div>
    
    <div><p class="pre">Read bytes into buffer *b*, using at most one system call

Returns an int representing the number of bytes read (0 for EOF).

Raises BlockingIOError if the underlying raw stream has no
data at the moment.</p></div>
  </div>
</div><div class="basemethod private">
  
  <a name="Lib._pyio.BufferedIOBase._readinto">
    
  </a>
  <a name="_readinto">
    
  </a>
  <div class="functionHeader">
    
    def
    _readinto(self, b, read1):
    
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overridden in <a href="Lib._pyio.BufferedReader.html" class="code" data-type="Class">Lib._pyio.BufferedReader</a></div>
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pyio.BufferedIOBase.write">
    
  </a>
  <a name="write">
    
  </a>
  <div class="functionHeader">
    
    def
    write(self, b):
    
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overridden in <a href="Lib._pyio.BufferedRandom.html" class="code" data-type="Class">Lib._pyio.BufferedRandom</a>, <a href="Lib._pyio.BufferedRWPair.html" class="code" data-type="Class">Lib._pyio.BufferedRWPair</a>, <a href="Lib._pyio.BufferedWriter.html" class="code" data-type="Class">Lib._pyio.BufferedWriter</a>, <a href="Lib._pyio.BytesIO.html" class="code" data-type="Class">Lib._pyio.BytesIO</a></div>
    
    <div><p class="pre">Write the given bytes buffer to the IO stream.

Return the number of bytes written, which is always the length of b
in bytes.

Raises BlockingIOError if the buffer is full and the
underlying raw stream cannot accept more data at the moment.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib._pyio.BufferedIOBase.detach">
    
  </a>
  <a name="detach">
    
  </a>
  <div class="functionHeader">
    
    def
    detach(self):
    
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overridden in <a href="Lib._pyio._BufferedIOMixin.html" class="code" data-type="Class">Lib._pyio._BufferedIOMixin</a></div>
    
    <div><p class="pre">Separate the underlying raw stream from the buffer and return it.

After the raw stream has been detached, the buffer is in an unusable
state.</p></div>
  </div>
</div>

      </div>
      <address>
        <a href="index.html">API Documentation</a> for Python3.8, generated by <a href="https://github.com/twisted/pydoctor/">pydoctor</a> 20.7.1 at 2020-11-24 05:02:55.
      </address>

    </div>

    <script src="pydoctor.js" type="text/javascript"></script>

  </body>
</html>