<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
          "DTD/xhtml1-strict.dtd">
<html>
  <head>
    <title>Lib.numbers.Complex : API documentation</title>

    <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
    <link rel="stylesheet" type="text/css" href="bootstrap.min.css" />
    <link rel="stylesheet" type="text/css" href="apidocs.css" />
  </head>
  <body>

    <nav class="navbar navbar-default">
      <div class="container">
        <div class="navbar-header">
          <a class="navbar-brand" href="index.html">
            Python3.8 API Documentation
          </a>
        </div>
      </div>
    </nav>

    <div id="showPrivate">
      <button class="btn btn-link" onclick="togglePrivate()">Toggle Private API</button>
    </div>

    <div class="container">

      <div class="page-header">
        <h1 class="class"><code><a href="Lib.html" class="code" data-type="Package">Lib</a>.<a href="Lib.numbers.html" class="code" data-type="Module">numbers</a>.<a href="Lib.numbers.Complex.html" class="code" data-type="Class">Complex</a></code></h1>
      </div>

      <div class="categoryHeader">
        class documentation
      </div>

      <div class="extrasDocstring">
        <p><code><span class="py-keyword">class</span> Lib.numbers.Complex(<a href="Lib.numbers.Number.html" class="code" data-type="Class">Number</a>):</code></p><p>Known subclasses: <a href="Lib.numbers.Real.html" class="code" data-type="Class">Lib.numbers.Real</a></p>
        <p><a href="classIndex.html#Lib.numbers.Complex">View In Hierarchy</a></p>
      </div>

      <div class="moduleDocstring">
        <div><p class="pre">Complex defines the operations that work on the builtin complex type.

In short, those are: a conversion to complex, .real, .imag, +, -,
*, /, abs(), .conjugate, ==, and !=.

If it is given heterogeneous arguments, and doesn't have special
knowledge about them, it should fall back to the builtin complex
type as described below.</p></div>
      </div>

      <div id="splitTables">
        <table class="children sortable" id="id3293">
  
  <tr class="classvariable">
    
    <td>Class Variable</td>
    <td><a href="Lib.numbers.Complex.html#__slots__" class="code" data-type="Class Variable">__slots__</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.numbers.Complex.html#__complex__" class="code" data-type="Method">__complex__</a></td>
    <td><span>Return a builtin complex instance. Called for complex(self).</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.numbers.Complex.html#__bool__" class="code" data-type="Method">__bool__</a></td>
    <td><span>True if self != 0. Called for bool(self).</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.numbers.Complex.html#real" class="code" data-type="Method">real</a></td>
    <td><span>Retrieve the real component of this number.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.numbers.Complex.html#imag" class="code" data-type="Method">imag</a></td>
    <td><span>Retrieve the imaginary component of this number.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.numbers.Complex.html#__add__" class="code" data-type="Method">__add__</a></td>
    <td><span>self + other</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.numbers.Complex.html#__radd__" class="code" data-type="Method">__radd__</a></td>
    <td><span>other + self</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.numbers.Complex.html#__neg__" class="code" data-type="Method">__neg__</a></td>
    <td><span>-self</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.numbers.Complex.html#__pos__" class="code" data-type="Method">__pos__</a></td>
    <td><span>+self</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.numbers.Complex.html#__sub__" class="code" data-type="Method">__sub__</a></td>
    <td><span>self - other</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.numbers.Complex.html#__rsub__" class="code" data-type="Method">__rsub__</a></td>
    <td><span>other - self</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.numbers.Complex.html#__mul__" class="code" data-type="Method">__mul__</a></td>
    <td><span>self * other</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.numbers.Complex.html#__rmul__" class="code" data-type="Method">__rmul__</a></td>
    <td><span>other * self</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.numbers.Complex.html#__truediv__" class="code" data-type="Method">__truediv__</a></td>
    <td><span>self / other: Should promote to float when necessary.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.numbers.Complex.html#__rtruediv__" class="code" data-type="Method">__rtruediv__</a></td>
    <td><span>other / self</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.numbers.Complex.html#__pow__" class="code" data-type="Method">__pow__</a></td>
    <td><span>self**exponent; should promote to float or complex when necessary.</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.numbers.Complex.html#__rpow__" class="code" data-type="Method">__rpow__</a></td>
    <td><span>base ** self</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.numbers.Complex.html#__abs__" class="code" data-type="Method">__abs__</a></td>
    <td><span>Returns the Real distance from 0. Called for abs(self).</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.numbers.Complex.html#conjugate" class="code" data-type="Method">conjugate</a></td>
    <td><span>(x+y*i).conjugate() returns (x-y*i).</span></td>
  </tr><tr class="method">
    
    <td>Method</td>
    <td><a href="Lib.numbers.Complex.html#__eq__" class="code" data-type="Method">__eq__</a></td>
    <td><span>self == other</span></td>
  </tr>
</table>
        
          <p class="inheritedFrom">
            Inherited from <a href="Lib.numbers.Number.html" class="code" data-type="Class">Number</a>:
          </p>
          <table class="children sortable" id="id3294">
  
  <tr class="baseclassvariable">
    
    <td>Class Variable</td>
    <td><a href="Lib.numbers.Number.html#__hash__" class="code" data-type="Class Variable">__hash__</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr>
</table>
          

          
      </div>

      <div id="childList">

        <div class="baseclassvariable">
  
  <a name="Lib.numbers.Complex.__slots__">
    
  </a>
  <a name="__slots__">
    
  </a>
  <div class="functionHeader">
    __slots__ =
    
  </div>
  <div class="functionBody">
    <div class="interfaceinfo">overrides <a href="Lib.numbers.Number.html#__slots__" class="code" data-type="Class Variable">Lib.numbers.Number.__slots__</a></div><div class="interfaceinfo">overridden in <a href="Lib.numbers.Real.html" class="code" data-type="Class">Lib.numbers.Real</a></div>
    <div class="undocumented">Undocumented</div> (type: <code>Tuple</code>)
  </div>
</div><div class="basemethod">
  
  <a name="Lib.numbers.Complex.__complex__">
    
  </a>
  <a name="__complex__">
    
  </a>
  <div class="functionHeader">
    @abstractmethod<br />
    def
    __complex__(self):
    
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overridden in <a href="Lib.numbers.Real.html" class="code" data-type="Class">Lib.numbers.Real</a></div>
    
    <div><p class="pre">Return a builtin complex instance. Called for complex(self).</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.numbers.Complex.__bool__">
    
  </a>
  <a name="__bool__">
    
  </a>
  <div class="functionHeader">
    
    def
    __bool__(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">True if self != 0. Called for bool(self).</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.numbers.Complex.real">
    
  </a>
  <a name="real">
    
  </a>
  <div class="functionHeader">
    @property<br />@abstractmethod<br />
    def
    real(self):
    
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overridden in <a href="Lib.numbers.Real.html" class="code" data-type="Class">Lib.numbers.Real</a></div>
    
    <div><p class="pre">Retrieve the real component of this number.

This should subclass Real.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.numbers.Complex.imag">
    
  </a>
  <a name="imag">
    
  </a>
  <div class="functionHeader">
    @property<br />@abstractmethod<br />
    def
    imag(self):
    
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overridden in <a href="Lib.numbers.Real.html" class="code" data-type="Class">Lib.numbers.Real</a></div>
    
    <div><p class="pre">Retrieve the imaginary component of this number.

This should subclass Real.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.numbers.Complex.__add__">
    
  </a>
  <a name="__add__">
    
  </a>
  <div class="functionHeader">
    @abstractmethod<br />
    def
    __add__(self, other):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">self + other</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.numbers.Complex.__radd__">
    
  </a>
  <a name="__radd__">
    
  </a>
  <div class="functionHeader">
    @abstractmethod<br />
    def
    __radd__(self, other):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">other + self</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.numbers.Complex.__neg__">
    
  </a>
  <a name="__neg__">
    
  </a>
  <div class="functionHeader">
    @abstractmethod<br />
    def
    __neg__(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">-self</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.numbers.Complex.__pos__">
    
  </a>
  <a name="__pos__">
    
  </a>
  <div class="functionHeader">
    @abstractmethod<br />
    def
    __pos__(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">+self</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.numbers.Complex.__sub__">
    
  </a>
  <a name="__sub__">
    
  </a>
  <div class="functionHeader">
    
    def
    __sub__(self, other):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">self - other</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.numbers.Complex.__rsub__">
    
  </a>
  <a name="__rsub__">
    
  </a>
  <div class="functionHeader">
    
    def
    __rsub__(self, other):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">other - self</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.numbers.Complex.__mul__">
    
  </a>
  <a name="__mul__">
    
  </a>
  <div class="functionHeader">
    @abstractmethod<br />
    def
    __mul__(self, other):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">self * other</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.numbers.Complex.__rmul__">
    
  </a>
  <a name="__rmul__">
    
  </a>
  <div class="functionHeader">
    @abstractmethod<br />
    def
    __rmul__(self, other):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">other * self</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.numbers.Complex.__truediv__">
    
  </a>
  <a name="__truediv__">
    
  </a>
  <div class="functionHeader">
    @abstractmethod<br />
    def
    __truediv__(self, other):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">self / other: Should promote to float when necessary.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.numbers.Complex.__rtruediv__">
    
  </a>
  <a name="__rtruediv__">
    
  </a>
  <div class="functionHeader">
    @abstractmethod<br />
    def
    __rtruediv__(self, other):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">other / self</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.numbers.Complex.__pow__">
    
  </a>
  <a name="__pow__">
    
  </a>
  <div class="functionHeader">
    @abstractmethod<br />
    def
    __pow__(self, exponent):
    
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overridden in <a href="Lib.numbers.Integral.html" class="code" data-type="Class">Lib.numbers.Integral</a></div>
    
    <div><p class="pre">self**exponent; should promote to float or complex when necessary.</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.numbers.Complex.__rpow__">
    
  </a>
  <a name="__rpow__">
    
  </a>
  <div class="functionHeader">
    @abstractmethod<br />
    def
    __rpow__(self, base):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">base ** self</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.numbers.Complex.__abs__">
    
  </a>
  <a name="__abs__">
    
  </a>
  <div class="functionHeader">
    @abstractmethod<br />
    def
    __abs__(self):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Returns the Real distance from 0. Called for abs(self).</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.numbers.Complex.conjugate">
    
  </a>
  <a name="conjugate">
    
  </a>
  <div class="functionHeader">
    @abstractmethod<br />
    def
    conjugate(self):
    
  </div>
  <div class="docstring functionBody">
    <div class="interfaceinfo">overridden in <a href="Lib.numbers.Real.html" class="code" data-type="Class">Lib.numbers.Real</a></div>
    
    <div><p class="pre">(x+y*i).conjugate() returns (x-y*i).</p></div>
  </div>
</div><div class="basemethod">
  
  <a name="Lib.numbers.Complex.__eq__">
    
  </a>
  <a name="__eq__">
    
  </a>
  <div class="functionHeader">
    @abstractmethod<br />
    def
    __eq__(self, other):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">self == other</p></div>
  </div>
</div>

      </div>
      <address>
        <a href="index.html">API Documentation</a> for Python3.8, generated by <a href="https://github.com/twisted/pydoctor/">pydoctor</a> 20.7.1 at 2020-11-24 05:02:55.
      </address>

    </div>

    <script src="pydoctor.js" type="text/javascript"></script>

  </body>
</html>