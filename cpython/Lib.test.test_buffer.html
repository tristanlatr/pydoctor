<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
          "DTD/xhtml1-strict.dtd">
<html>
  <head>
    <title>Lib.test.test_buffer : API documentation</title>

    <meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
    <link rel="stylesheet" type="text/css" href="bootstrap.min.css" />
    <link rel="stylesheet" type="text/css" href="apidocs.css" />
  </head>
  <body>

    <nav class="navbar navbar-default">
      <div class="container">
        <div class="navbar-header">
          <a class="navbar-brand" href="index.html">
            Python3.8 API Documentation
          </a>
        </div>
      </div>
    </nav>

    <div id="showPrivate">
      <button class="btn btn-link" onclick="togglePrivate()">Toggle Private API</button>
    </div>

    <div class="container">

      <div class="page-header">
        <h1 class="module"><code><a href="Lib.html" class="code" data-type="Package">Lib</a>.<a href="Lib.test.html" class="code" data-type="Package">test</a>.<a href="Lib.test.test_buffer.html" class="code" data-type="Module">test_buffer</a></code></h1>
      </div>

      <div class="categoryHeader">
        module documentation
      </div>

      <div class="extrasDocstring">
        
        <p></p>
      </div>

      <div class="moduleDocstring">
        <div class="undocumented">Undocumented</div>
      </div>

      <div id="splitTables">
        <table class="children sortable" id="id5091">
  
  <tr class="variable">
    
    <td>Variable</td>
    <td><a href="Lib.test.test_buffer.html#ndarray" class="code" data-type="Variable">ndarray</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="variable">
    
    <td>Variable</td>
    <td><a href="Lib.test.test_buffer.html#struct" class="code" data-type="Variable">struct</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="variable">
    
    <td>Variable</td>
    <td><a href="Lib.test.test_buffer.html#ctypes" class="code" data-type="Variable">ctypes</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="variable">
    
    <td>Variable</td>
    <td><a href="Lib.test.test_buffer.html#numpy_array" class="code" data-type="Variable">numpy_array</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="variable">
    
    <td>Variable</td>
    <td><a href="Lib.test.test_buffer.html#SHORT_TEST" class="code" data-type="Variable">SHORT_TEST</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="variable">
    
    <td>Variable</td>
    <td><a href="Lib.test.test_buffer.html#NATIVE" class="code" data-type="Variable">NATIVE</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="variable">
    
    <td>Variable</td>
    <td><a href="Lib.test.test_buffer.html#STANDARD" class="code" data-type="Variable">STANDARD</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><a href="Lib.test.test_buffer.html#native_type_range" class="code" data-type="Function">native_type_range</a></td>
    <td><span>Return range of a native type.</span></td>
  </tr><tr class="variable">
    
    <td>Variable</td>
    <td><a href="Lib.test.test_buffer.html#fmtdict" class="code" data-type="Variable">fmtdict</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="variable">
    
    <td>Variable</td>
    <td><a href="Lib.test.test_buffer.html#MEMORYVIEW" class="code" data-type="Variable">MEMORYVIEW</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="variable">
    
    <td>Variable</td>
    <td><a href="Lib.test.test_buffer.html#ARRAY" class="code" data-type="Variable">ARRAY</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="variable">
    
    <td>Variable</td>
    <td><a href="Lib.test.test_buffer.html#BYTEFMT" class="code" data-type="Variable">BYTEFMT</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="variable">
    
    <td>Variable</td>
    <td><a href="Lib.test.test_buffer.html#MODE" class="code" data-type="Variable">MODE</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="variable">
    
    <td>Variable</td>
    <td><a href="Lib.test.test_buffer.html#MULT" class="code" data-type="Variable">MULT</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="variable">
    
    <td>Variable</td>
    <td><a href="Lib.test.test_buffer.html#cap" class="code" data-type="Variable">cap</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><a href="Lib.test.test_buffer.html#randrange_fmt" class="code" data-type="Function">randrange_fmt</a></td>
    <td><span>Return random item for a type specified by a mode and a single format character.</span></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><a href="Lib.test.test_buffer.html#gen_item" class="code" data-type="Function">gen_item</a></td>
    <td><span>Return single random item.</span></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><a href="Lib.test.test_buffer.html#gen_items" class="code" data-type="Function">gen_items</a></td>
    <td><span>Return a list of random items (or a scalar).</span></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><a href="Lib.test.test_buffer.html#struct_items" class="code" data-type="Function">struct_items</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><a href="Lib.test.test_buffer.html#randitems" class="code" data-type="Function">randitems</a></td>
    <td><span>Return random format, items, item.</span></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><a href="Lib.test.test_buffer.html#iter_mode" class="code" data-type="Function">iter_mode</a></td>
    <td><span>Iterate through supported mode/char combinations.</span></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><a href="Lib.test.test_buffer.html#iter_format" class="code" data-type="Function">iter_format</a></td>
    <td><span>Yield (format, items, item) for all possible modes and format characters plus one random compound format string.</span></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><a href="Lib.test.test_buffer.html#is_byte_format" class="code" data-type="Function">is_byte_format</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><a href="Lib.test.test_buffer.html#is_memoryview_format" class="code" data-type="Function">is_memoryview_format</a></td>
    <td><span>format suitable for memoryview</span></td>
  </tr><tr class="variable">
    
    <td>Variable</td>
    <td><a href="Lib.test.test_buffer.html#NON_BYTE_FORMAT" class="code" data-type="Variable">NON_BYTE_FORMAT</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><a href="Lib.test.test_buffer.html#atomp" class="code" data-type="Function">atomp</a></td>
    <td><span>Tuple items (representing structs) are regarded as atoms.</span></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><a href="Lib.test.test_buffer.html#listp" class="code" data-type="Function">listp</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><a href="Lib.test.test_buffer.html#prod" class="code" data-type="Function">prod</a></td>
    <td><span>Product of list elements.</span></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><a href="Lib.test.test_buffer.html#strides_from_shape" class="code" data-type="Function">strides_from_shape</a></td>
    <td><span>Calculate strides of a contiguous array. Layout is 'C' or 'F' (Fortran).</span></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><a href="Lib.test.test_buffer.html#carray" class="code" data-type="Function">carray</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><a href="Lib.test.test_buffer.html#farray" class="code" data-type="Function">farray</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><a href="Lib.test.test_buffer.html#indices" class="code" data-type="Function">indices</a></td>
    <td><span>Generate all possible tuples of indices.</span></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><a href="Lib.test.test_buffer.html#getindex" class="code" data-type="Function">getindex</a></td>
    <td><span>Convert multi-dimensional index to the position in the flat list.</span></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><a href="Lib.test.test_buffer.html#transpose" class="code" data-type="Function">transpose</a></td>
    <td><span>Transpose flat item list that is regarded as a multi-dimensional matrix defined by shape: dest...[k][j][i] = src[i][j][k]...</span></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><a href="Lib.test.test_buffer.html#flatten" class="code" data-type="Function">flatten</a></td>
    <td><span>flatten list or return scalar</span></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><a href="Lib.test.test_buffer.html#slice_shape" class="code" data-type="Function">slice_shape</a></td>
    <td><span>Get the shape of lst after slicing: slices is a list of slice objects.</span></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><a href="Lib.test.test_buffer.html#multislice" class="code" data-type="Function">multislice</a></td>
    <td><span>Multi-dimensional slicing: slices is a list of slice objects.</span></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><a href="Lib.test.test_buffer.html#m_assign" class="code" data-type="Function">m_assign</a></td>
    <td><span>Multi-dimensional slice assignment: llst and rlst are the operands, lslices and rslices are lists of slice objects. llst and rlst must have the same structure.</span></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><a href="Lib.test.test_buffer.html#cmp_structure" class="code" data-type="Function">cmp_structure</a></td>
    <td><span>Compare the structure of llst[lslices] and rlst[rslices].</span></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><a href="Lib.test.test_buffer.html#multislice_assign" class="code" data-type="Function">multislice_assign</a></td>
    <td><span>Return llst after assigning: llst[lslices] = rlst[rslices]</span></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><a href="Lib.test.test_buffer.html#verify_structure" class="code" data-type="Function">verify_structure</a></td>
    <td><span class="undocumented">No summary</span></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><a href="Lib.test.test_buffer.html#get_item" class="code" data-type="Function">get_item</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><a href="Lib.test.test_buffer.html#memory_index" class="code" data-type="Function">memory_index</a></td>
    <td><span>Location of an item in the underlying memory.</span></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><a href="Lib.test.test_buffer.html#is_overlapping" class="code" data-type="Function">is_overlapping</a></td>
    <td><span>The structure 't' is overlapping if at least one memory location is visited twice while iterating through all possible tuples of indices.</span></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><a href="Lib.test.test_buffer.html#rand_structure" class="code" data-type="Function">rand_structure</a></td>
    <td><span class="undocumented">No summary</span></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><a href="Lib.test.test_buffer.html#randslice_from_slicelen" class="code" data-type="Function">randslice_from_slicelen</a></td>
    <td><span>Create a random slice of len slicelen that fits into listlen.</span></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><a href="Lib.test.test_buffer.html#randslice_from_shape" class="code" data-type="Function">randslice_from_shape</a></td>
    <td><span>Create two sets of slices for an array x with shape 'shape' such that shapeof(x[lslices]) == shapeof(x[rslices]).</span></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><a href="Lib.test.test_buffer.html#rand_aligned_slices" class="code" data-type="Function">rand_aligned_slices</a></td>
    <td><span>Create (lshape, rshape, tuple(lslices), tuple(rslices)) such that shapeof(x[lslices]) == shapeof(y[rslices]), where x is an array with shape 'lshape' and y is an array with shape 'rshape'.</span></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><a href="Lib.test.test_buffer.html#randitems_from_structure" class="code" data-type="Function">randitems_from_structure</a></td>
    <td><span>Return a list of random items for structure 't' with format 'fmtchar'.</span></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><a href="Lib.test.test_buffer.html#ndarray_from_structure" class="code" data-type="Function">ndarray_from_structure</a></td>
    <td><span>Return ndarray from the tuple returned by rand_structure()</span></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><a href="Lib.test.test_buffer.html#numpy_array_from_structure" class="code" data-type="Function">numpy_array_from_structure</a></td>
    <td><span>Return numpy_array from the tuple returned by rand_structure()</span></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><a href="Lib.test.test_buffer.html#cast_items" class="code" data-type="Function">cast_items</a></td>
    <td><span class="undocumented">No summary</span></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><a href="Lib.test.test_buffer.html#gencastshapes" class="code" data-type="Function">gencastshapes</a></td>
    <td><span>Generate shapes to test casting.</span></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><a href="Lib.test.test_buffer.html#genslices" class="code" data-type="Function">genslices</a></td>
    <td><span>Generate all possible slices for a single dimension.</span></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><a href="Lib.test.test_buffer.html#genslices_ndim" class="code" data-type="Function">genslices_ndim</a></td>
    <td><span>Generate all possible slice tuples for 'shape'.</span></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><a href="Lib.test.test_buffer.html#rslice" class="code" data-type="Function">rslice</a></td>
    <td><span>Generate random slice for a single dimension of length n. If zero=True, the slices may be empty, otherwise they will be non-empty.</span></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><a href="Lib.test.test_buffer.html#rslices" class="code" data-type="Function">rslices</a></td>
    <td><span>Generate random slices for a single dimension.</span></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><a href="Lib.test.test_buffer.html#rslices_ndim" class="code" data-type="Function">rslices_ndim</a></td>
    <td><span>Generate random slice tuples for 'shape'.</span></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><a href="Lib.test.test_buffer.html#rpermutation" class="code" data-type="Function">rpermutation</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="function">
    
    <td>Function</td>
    <td><a href="Lib.test.test_buffer.html#ndarray_print" class="code" data-type="Function">ndarray_print</a></td>
    <td><span>Print ndarray for debugging.</span></td>
  </tr><tr class="variable">
    
    <td>Variable</td>
    <td><a href="Lib.test.test_buffer.html#ITERATIONS" class="code" data-type="Variable">ITERATIONS</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="variable">
    
    <td>Variable</td>
    <td><a href="Lib.test.test_buffer.html#MAXDIM" class="code" data-type="Variable">MAXDIM</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="variable">
    
    <td>Variable</td>
    <td><a href="Lib.test.test_buffer.html#MAXSHAPE" class="code" data-type="Variable">MAXSHAPE</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="class">
    
    <td>Class</td>
    <td><a href="Lib.test.test_buffer.TestBufferProtocol.html" class="code" data-type="Class">TestBufferProtocol</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="variable private">
    
    <td>Variable</td>
    <td><a href="Lib.test.test_buffer.html#_testcapi" class="code" data-type="Variable">_testcapi</a></td>
    <td><span class="undocumented">Undocumented</span></td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><a href="Lib.test.test_buffer.html#_ca" class="code" data-type="Function">_ca</a></td>
    <td><span>Convert flat item list to the nested list representation of a multidimensional C array with shape 's'.</span></td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><a href="Lib.test.test_buffer.html#_fa" class="code" data-type="Function">_fa</a></td>
    <td><span>Convert flat item list to the nested list representation of a multidimensional Fortran array with shape 's'.</span></td>
  </tr><tr class="function private">
    
    <td>Function</td>
    <td><a href="Lib.test.test_buffer.html#_flatten" class="code" data-type="Function">_flatten</a></td>
    <td><span>flatten list</span></td>
  </tr>
</table>
        

          
      </div>

      <div id="childList">

        <div class="basevariable">
  
  <a name="Lib.test.test_buffer.ndarray">
    
  </a>
  <a name="ndarray">
    
  </a>
  <div class="functionHeader">
    ndarray =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basevariable">
  
  <a name="Lib.test.test_buffer.struct">
    
  </a>
  <a name="struct">
    
  </a>
  <div class="functionHeader">
    struct =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basevariable">
  
  <a name="Lib.test.test_buffer.ctypes">
    
  </a>
  <a name="ctypes">
    
  </a>
  <div class="functionHeader">
    ctypes =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basevariable">
  
  <a name="Lib.test.test_buffer.numpy_array">
    
  </a>
  <a name="numpy_array">
    
  </a>
  <div class="functionHeader">
    numpy_array =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basevariable private">
  
  <a name="Lib.test.test_buffer._testcapi">
    
  </a>
  <a name="_testcapi">
    
  </a>
  <div class="functionHeader">
    _testcapi =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basevariable">
  
  <a name="Lib.test.test_buffer.SHORT_TEST">
    
  </a>
  <a name="SHORT_TEST">
    
  </a>
  <div class="functionHeader">
    SHORT_TEST =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div> (type: <code>bool</code>)
  </div>
</div><div class="basevariable">
  
  <a name="Lib.test.test_buffer.NATIVE">
    
  </a>
  <a name="NATIVE">
    
  </a>
  <div class="functionHeader">
    NATIVE =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div> (type: <code>Dict[str, int]</code>)
  </div>
</div><div class="basevariable">
  
  <a name="Lib.test.test_buffer.STANDARD">
    
  </a>
  <a name="STANDARD">
    
  </a>
  <div class="functionHeader">
    STANDARD =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basefunction">
  
  <a name="Lib.test.test_buffer.native_type_range">
    
  </a>
  <a name="native_type_range">
    
  </a>
  <div class="functionHeader">
    
    def
    native_type_range(fmt):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Return range of a native type.</p></div>
  </div>
</div><div class="basevariable">
  
  <a name="Lib.test.test_buffer.fmtdict">
    
  </a>
  <a name="fmtdict">
    
  </a>
  <div class="functionHeader">
    fmtdict =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basevariable">
  
  <a name="Lib.test.test_buffer.MEMORYVIEW">
    
  </a>
  <a name="MEMORYVIEW">
    
  </a>
  <div class="functionHeader">
    MEMORYVIEW =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basevariable">
  
  <a name="Lib.test.test_buffer.ARRAY">
    
  </a>
  <a name="ARRAY">
    
  </a>
  <div class="functionHeader">
    ARRAY =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basevariable">
  
  <a name="Lib.test.test_buffer.BYTEFMT">
    
  </a>
  <a name="BYTEFMT">
    
  </a>
  <div class="functionHeader">
    BYTEFMT =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basevariable">
  
  <a name="Lib.test.test_buffer.MODE">
    
  </a>
  <a name="MODE">
    
  </a>
  <div class="functionHeader">
    MODE =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div> (type: <code>int</code>)
  </div>
</div><div class="basevariable">
  
  <a name="Lib.test.test_buffer.MULT">
    
  </a>
  <a name="MULT">
    
  </a>
  <div class="functionHeader">
    MULT =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div> (type: <code>int</code>)
  </div>
</div><div class="basevariable">
  
  <a name="Lib.test.test_buffer.cap">
    
  </a>
  <a name="cap">
    
  </a>
  <div class="functionHeader">
    cap =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div> (type: <code>Dict[str, Tuple]</code>)
  </div>
</div><div class="basefunction">
  
  <a name="Lib.test.test_buffer.randrange_fmt">
    
  </a>
  <a name="randrange_fmt">
    
  </a>
  <div class="functionHeader">
    
    def
    randrange_fmt(mode, char, obj):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Return random item for a type specified by a mode and a single
format character.</p></div>
  </div>
</div><div class="basefunction">
  
  <a name="Lib.test.test_buffer.gen_item">
    
  </a>
  <a name="gen_item">
    
  </a>
  <div class="functionHeader">
    
    def
    gen_item(fmt, obj):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Return single random item.</p></div>
  </div>
</div><div class="basefunction">
  
  <a name="Lib.test.test_buffer.gen_items">
    
  </a>
  <a name="gen_items">
    
  </a>
  <div class="functionHeader">
    
    def
    gen_items(n, fmt, obj):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Return a list of random items (or a scalar).</p></div>
  </div>
</div><div class="basefunction">
  
  <a name="Lib.test.test_buffer.struct_items">
    
  </a>
  <a name="struct_items">
    
  </a>
  <div class="functionHeader">
    
    def
    struct_items(n, obj):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basefunction">
  
  <a name="Lib.test.test_buffer.randitems">
    
  </a>
  <a name="randitems">
    
  </a>
  <div class="functionHeader">
    
    def
    randitems(n, obj="""ndarray""", mode=None, char=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Return random format, items, item.</p></div>
  </div>
</div><div class="basefunction">
  
  <a name="Lib.test.test_buffer.iter_mode">
    
  </a>
  <a name="iter_mode">
    
  </a>
  <div class="functionHeader">
    
    def
    iter_mode(n, obj="""ndarray"""):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Iterate through supported mode/char combinations.</p></div>
  </div>
</div><div class="basefunction">
  
  <a name="Lib.test.test_buffer.iter_format">
    
  </a>
  <a name="iter_format">
    
  </a>
  <div class="functionHeader">
    
    def
    iter_format(nitems, testobj="""ndarray"""):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Yield (format, items, item) for all possible modes and format
characters plus one random compound format string.</p></div>
  </div>
</div><div class="basefunction">
  
  <a name="Lib.test.test_buffer.is_byte_format">
    
  </a>
  <a name="is_byte_format">
    
  </a>
  <div class="functionHeader">
    
    def
    is_byte_format(fmt):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basefunction">
  
  <a name="Lib.test.test_buffer.is_memoryview_format">
    
  </a>
  <a name="is_memoryview_format">
    
  </a>
  <div class="functionHeader">
    
    def
    is_memoryview_format(fmt):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">format suitable for memoryview</p></div>
  </div>
</div><div class="basevariable">
  
  <a name="Lib.test.test_buffer.NON_BYTE_FORMAT">
    
  </a>
  <a name="NON_BYTE_FORMAT">
    
  </a>
  <div class="functionHeader">
    NON_BYTE_FORMAT =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basefunction">
  
  <a name="Lib.test.test_buffer.atomp">
    
  </a>
  <a name="atomp">
    
  </a>
  <div class="functionHeader">
    
    def
    atomp(lst):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Tuple items (representing structs) are regarded as atoms.</p></div>
  </div>
</div><div class="basefunction">
  
  <a name="Lib.test.test_buffer.listp">
    
  </a>
  <a name="listp">
    
  </a>
  <div class="functionHeader">
    
    def
    listp(lst):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basefunction">
  
  <a name="Lib.test.test_buffer.prod">
    
  </a>
  <a name="prod">
    
  </a>
  <div class="functionHeader">
    
    def
    prod(lst):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Product of list elements.</p></div>
  </div>
</div><div class="basefunction">
  
  <a name="Lib.test.test_buffer.strides_from_shape">
    
  </a>
  <a name="strides_from_shape">
    
  </a>
  <div class="functionHeader">
    
    def
    strides_from_shape(ndim, shape, itemsize, layout):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Calculate strides of a contiguous array. Layout is 'C' or
'F' (Fortran).</p></div>
  </div>
</div><div class="basefunction private">
  
  <a name="Lib.test.test_buffer._ca">
    
  </a>
  <a name="_ca">
    
  </a>
  <div class="functionHeader">
    
    def
    _ca(items, s):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Convert flat item list to the nested list representation of a
multidimensional C array with shape 's'.</p></div>
  </div>
</div><div class="basefunction private">
  
  <a name="Lib.test.test_buffer._fa">
    
  </a>
  <a name="_fa">
    
  </a>
  <div class="functionHeader">
    
    def
    _fa(items, s):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Convert flat item list to the nested list representation of a
multidimensional Fortran array with shape 's'.</p></div>
  </div>
</div><div class="basefunction">
  
  <a name="Lib.test.test_buffer.carray">
    
  </a>
  <a name="carray">
    
  </a>
  <div class="functionHeader">
    
    def
    carray(items, shape):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basefunction">
  
  <a name="Lib.test.test_buffer.farray">
    
  </a>
  <a name="farray">
    
  </a>
  <div class="functionHeader">
    
    def
    farray(items, shape):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basefunction">
  
  <a name="Lib.test.test_buffer.indices">
    
  </a>
  <a name="indices">
    
  </a>
  <div class="functionHeader">
    
    def
    indices(shape):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Generate all possible tuples of indices.</p></div>
  </div>
</div><div class="basefunction">
  
  <a name="Lib.test.test_buffer.getindex">
    
  </a>
  <a name="getindex">
    
  </a>
  <div class="functionHeader">
    
    def
    getindex(ndim, ind, strides):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Convert multi-dimensional index to the position in the flat list.</p></div>
  </div>
</div><div class="basefunction">
  
  <a name="Lib.test.test_buffer.transpose">
    
  </a>
  <a name="transpose">
    
  </a>
  <div class="functionHeader">
    
    def
    transpose(src, shape):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Transpose flat item list that is regarded as a multi-dimensional
matrix defined by shape: dest...[k][j][i] = src[i][j][k]...  </p></div>
  </div>
</div><div class="basefunction private">
  
  <a name="Lib.test.test_buffer._flatten">
    
  </a>
  <a name="_flatten">
    
  </a>
  <div class="functionHeader">
    
    def
    _flatten(lst):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">flatten list</p></div>
  </div>
</div><div class="basefunction">
  
  <a name="Lib.test.test_buffer.flatten">
    
  </a>
  <a name="flatten">
    
  </a>
  <div class="functionHeader">
    
    def
    flatten(lst):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">flatten list or return scalar</p></div>
  </div>
</div><div class="basefunction">
  
  <a name="Lib.test.test_buffer.slice_shape">
    
  </a>
  <a name="slice_shape">
    
  </a>
  <div class="functionHeader">
    
    def
    slice_shape(lst, slices):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Get the shape of lst after slicing: slices is a list of slice
objects.</p></div>
  </div>
</div><div class="basefunction">
  
  <a name="Lib.test.test_buffer.multislice">
    
  </a>
  <a name="multislice">
    
  </a>
  <div class="functionHeader">
    
    def
    multislice(lst, slices):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Multi-dimensional slicing: slices is a list of slice objects.</p></div>
  </div>
</div><div class="basefunction">
  
  <a name="Lib.test.test_buffer.m_assign">
    
  </a>
  <a name="m_assign">
    
  </a>
  <div class="functionHeader">
    
    def
    m_assign(llst, rlst, lslices, rslices):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Multi-dimensional slice assignment: llst and rlst are the operands,
lslices and rslices are lists of slice objects. llst and rlst must
have the same structure.

For a two-dimensional example, this is not implemented in Python:

  llst[0:3:2, 0:3:2] = rlst[1:3:1, 1:3:1]

Instead we write:

  lslices = [slice(0,3,2), slice(0,3,2)]
  rslices = [slice(1,3,1), slice(1,3,1)]
  multislice_assign(llst, rlst, lslices, rslices)</p></div>
  </div>
</div><div class="basefunction">
  
  <a name="Lib.test.test_buffer.cmp_structure">
    
  </a>
  <a name="cmp_structure">
    
  </a>
  <div class="functionHeader">
    
    def
    cmp_structure(llst, rlst, lslices, rslices):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Compare the structure of llst[lslices] and rlst[rslices].</p></div>
  </div>
</div><div class="basefunction">
  
  <a name="Lib.test.test_buffer.multislice_assign">
    
  </a>
  <a name="multislice_assign">
    
  </a>
  <div class="functionHeader">
    
    def
    multislice_assign(llst, rlst, lslices, rslices):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Return llst after assigning: llst[lslices] = rlst[rslices]</p></div>
  </div>
</div><div class="basefunction">
  
  <a name="Lib.test.test_buffer.verify_structure">
    
  </a>
  <a name="verify_structure">
    
  </a>
  <div class="functionHeader">
    
    def
    verify_structure(memlen, itemsize, ndim, shape, strides, offset):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Verify that the parameters represent a valid array within
the bounds of the allocated memory:
    char *mem: start of the physical memory block
    memlen: length of the physical memory block
    offset: (char *)buf - mem</p></div>
  </div>
</div><div class="basefunction">
  
  <a name="Lib.test.test_buffer.get_item">
    
  </a>
  <a name="get_item">
    
  </a>
  <div class="functionHeader">
    
    def
    get_item(lst, indices):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basefunction">
  
  <a name="Lib.test.test_buffer.memory_index">
    
  </a>
  <a name="memory_index">
    
  </a>
  <div class="functionHeader">
    
    def
    memory_index(indices, t):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Location of an item in the underlying memory.</p></div>
  </div>
</div><div class="basefunction">
  
  <a name="Lib.test.test_buffer.is_overlapping">
    
  </a>
  <a name="is_overlapping">
    
  </a>
  <div class="functionHeader">
    
    def
    is_overlapping(t):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">The structure 't' is overlapping if at least one memory location
is visited twice while iterating through all possible tuples of
indices.</p></div>
  </div>
</div><div class="basefunction">
  
  <a name="Lib.test.test_buffer.rand_structure">
    
  </a>
  <a name="rand_structure">
    
  </a>
  <div class="functionHeader">
    
    def
    rand_structure(itemsize, valid, maxdim=5, maxshape=16, shape=()):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Return random structure:
    (memlen, itemsize, ndim, shape, strides, offset)
If 'valid' is true, the returned structure is valid, otherwise invalid.
If 'shape' is given, use that instead of creating a random shape.</p></div>
  </div>
</div><div class="basefunction">
  
  <a name="Lib.test.test_buffer.randslice_from_slicelen">
    
  </a>
  <a name="randslice_from_slicelen">
    
  </a>
  <div class="functionHeader">
    
    def
    randslice_from_slicelen(slicelen, listlen):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Create a random slice of len slicelen that fits into listlen.</p></div>
  </div>
</div><div class="basefunction">
  
  <a name="Lib.test.test_buffer.randslice_from_shape">
    
  </a>
  <a name="randslice_from_shape">
    
  </a>
  <div class="functionHeader">
    
    def
    randslice_from_shape(ndim, shape):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Create two sets of slices for an array x with shape 'shape'
such that shapeof(x[lslices]) == shapeof(x[rslices]).</p></div>
  </div>
</div><div class="basefunction">
  
  <a name="Lib.test.test_buffer.rand_aligned_slices">
    
  </a>
  <a name="rand_aligned_slices">
    
  </a>
  <div class="functionHeader">
    
    def
    rand_aligned_slices(maxdim=5, maxshape=16):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Create (lshape, rshape, tuple(lslices), tuple(rslices)) such that
shapeof(x[lslices]) == shapeof(y[rslices]), where x is an array
with shape 'lshape' and y is an array with shape 'rshape'.</p></div>
  </div>
</div><div class="basefunction">
  
  <a name="Lib.test.test_buffer.randitems_from_structure">
    
  </a>
  <a name="randitems_from_structure">
    
  </a>
  <div class="functionHeader">
    
    def
    randitems_from_structure(fmt, t):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Return a list of random items for structure 't' with format
'fmtchar'.</p></div>
  </div>
</div><div class="basefunction">
  
  <a name="Lib.test.test_buffer.ndarray_from_structure">
    
  </a>
  <a name="ndarray_from_structure">
    
  </a>
  <div class="functionHeader">
    
    def
    ndarray_from_structure(items, fmt, t, flags=0):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Return ndarray from the tuple returned by rand_structure()</p></div>
  </div>
</div><div class="basefunction">
  
  <a name="Lib.test.test_buffer.numpy_array_from_structure">
    
  </a>
  <a name="numpy_array_from_structure">
    
  </a>
  <div class="functionHeader">
    
    def
    numpy_array_from_structure(items, fmt, t):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Return numpy_array from the tuple returned by rand_structure()</p></div>
  </div>
</div><div class="basefunction">
  
  <a name="Lib.test.test_buffer.cast_items">
    
  </a>
  <a name="cast_items">
    
  </a>
  <div class="functionHeader">
    
    def
    cast_items(exporter, fmt, itemsize, shape=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Interpret the raw memory of 'exporter' as a list of items with
size 'itemsize'. If shape=None, the new structure is assumed to
be 1-D with n * itemsize = bytelen. If shape is given, the usual
constraint for contiguous arrays prod(shape) * itemsize = bytelen
applies. On success, return (items, shape). If the constraints
cannot be met, return (None, None). If a chunk of bytes is interpreted
as NaN as a result of float conversion, return ('nan', None).</p></div>
  </div>
</div><div class="basefunction">
  
  <a name="Lib.test.test_buffer.gencastshapes">
    
  </a>
  <a name="gencastshapes">
    
  </a>
  <div class="functionHeader">
    
    def
    gencastshapes():
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Generate shapes to test casting.</p></div>
  </div>
</div><div class="basefunction">
  
  <a name="Lib.test.test_buffer.genslices">
    
  </a>
  <a name="genslices">
    
  </a>
  <div class="functionHeader">
    
    def
    genslices(n):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Generate all possible slices for a single dimension.</p></div>
  </div>
</div><div class="basefunction">
  
  <a name="Lib.test.test_buffer.genslices_ndim">
    
  </a>
  <a name="genslices_ndim">
    
  </a>
  <div class="functionHeader">
    
    def
    genslices_ndim(ndim, shape):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Generate all possible slice tuples for 'shape'.</p></div>
  </div>
</div><div class="basefunction">
  
  <a name="Lib.test.test_buffer.rslice">
    
  </a>
  <a name="rslice">
    
  </a>
  <div class="functionHeader">
    
    def
    rslice(n, allow_empty=(False)):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Generate random slice for a single dimension of length n.
If zero=True, the slices may be empty, otherwise they will
be non-empty.</p></div>
  </div>
</div><div class="basefunction">
  
  <a name="Lib.test.test_buffer.rslices">
    
  </a>
  <a name="rslices">
    
  </a>
  <div class="functionHeader">
    
    def
    rslices(n, allow_empty=(False)):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Generate random slices for a single dimension.</p></div>
  </div>
</div><div class="basefunction">
  
  <a name="Lib.test.test_buffer.rslices_ndim">
    
  </a>
  <a name="rslices_ndim">
    
  </a>
  <div class="functionHeader">
    
    def
    rslices_ndim(ndim, shape, iterations=5):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Generate random slice tuples for 'shape'.</p></div>
  </div>
</div><div class="basefunction">
  
  <a name="Lib.test.test_buffer.rpermutation">
    
  </a>
  <a name="rpermutation">
    
  </a>
  <div class="functionHeader">
    
    def
    rpermutation(iterable, r=None):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div class="undocumented">Undocumented</div>
  </div>
</div><div class="basefunction">
  
  <a name="Lib.test.test_buffer.ndarray_print">
    
  </a>
  <a name="ndarray_print">
    
  </a>
  <div class="functionHeader">
    
    def
    ndarray_print(nd):
    
  </div>
  <div class="docstring functionBody">
    
    
    <div><p class="pre">Print ndarray for debugging.</p></div>
  </div>
</div><div class="basevariable">
  
  <a name="Lib.test.test_buffer.ITERATIONS">
    
  </a>
  <a name="ITERATIONS">
    
  </a>
  <div class="functionHeader">
    ITERATIONS =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div> (type: <code>int</code>)
  </div>
</div><div class="basevariable">
  
  <a name="Lib.test.test_buffer.MAXDIM">
    
  </a>
  <a name="MAXDIM">
    
  </a>
  <div class="functionHeader">
    MAXDIM =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div> (type: <code>int</code>)
  </div>
</div><div class="basevariable">
  
  <a name="Lib.test.test_buffer.MAXSHAPE">
    
  </a>
  <a name="MAXSHAPE">
    
  </a>
  <div class="functionHeader">
    MAXSHAPE =
    
  </div>
  <div class="functionBody">
    
    <div class="undocumented">Undocumented</div> (type: <code>int</code>)
  </div>
</div>

      </div>
      <address>
        <a href="index.html">API Documentation</a> for Python3.8, generated by <a href="https://github.com/twisted/pydoctor/">pydoctor</a> 20.7.1 at 2020-11-24 05:11:37.
      </address>

    </div>

    <script src="pydoctor.js" type="text/javascript"></script>

  </body>
</html>